<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on qinry&#39;s blog</title>
    <link>https://qinry.github.io/categories/java/</link>
    <description>Recent content in Java on qinry&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 16 Jan 2021 19:11:45 +0800</lastBuildDate><atom:link href="https://qinry.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java开发环境搭建与介绍</title>
      <link>https://qinry.github.io/posts/2021-01-16-setup-de/</link>
      <pubDate>Sat, 16 Jan 2021 19:11:45 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2021-01-16-setup-de/</guid>
      <description>一、环境搭建 开发Java工程离不开JDK（Java Development Kit Java开发工具包），这个是最基本的必须下载和安装，还有为了方便开发者编写、运行和调试</description>
    </item>
    
    <item>
      <title>注解</title>
      <link>https://qinry.github.io/posts/2020-05-12-java-annotation/</link>
      <pubDate>Tue, 12 May 2020 22:06:42 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-05-12-java-annotation/</guid>
      <description>定义注解 import java.lang.annotation.*; @Target(ElementType.METHOND) @Retention(RetentionPolicy.RUNTIME) public @interface UseCase { int id(); String description() default &amp;#34;no description&amp;#34;; } 使用注解 import java.util.*; public class PasswordUtils { @UseCase(id = 47, description = &amp;#34;Passwords must contain at least one numeric&amp;#34;) public boolean validatePassword(String passwd) { return (passwd.matches(&amp;#34;\\w*\\d\\w*&amp;#34;)); } @UseCase(id = 48) public String encryptPassword(String passwd) { return new StringBuilder(passwd) .reverse().toString(); } @UseCase(id = 49, description = &amp;#34;New passwords</description>
    </item>
    
    <item>
      <title>泛型</title>
      <link>https://qinry.github.io/posts/2020-05-04-java-generics/</link>
      <pubDate>Sun, 03 May 2020 23:29:33 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-05-04-java-generics/</guid>
      <description>有些一些方法处理不同类型，这些方法之间只有操作的类型的不同，方法名相同，方法的行为相似甚至相同，那么可以使用参数化类型，也叫泛型，用一个方法</description>
    </item>
    
    <item>
      <title>容器</title>
      <link>https://qinry.github.io/posts/2020-05-02-java-containers/</link>
      <pubDate>Sat, 02 May 2020 21:30:16 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-05-02-java-containers/</guid>
      <description>留意 此文列出一些有可能常用的api，肯定没有文档列的全也没必要全面，还有旨在会用这些操作容器的方法即可，要了解更多回看《Thinking in J</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://qinry.github.io/posts/2020-05-02-java-arrays/</link>
      <pubDate>Sat, 02 May 2020 21:27:15 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-05-02-java-arrays/</guid>
      <description>数组的优势，在于它存储和执行的效率，支持随机访问元素。不过，数组对象使用前它的大小是固定，不可改变。这意味着创建固定大小的数组，以后要扩大其</description>
    </item>
    
    <item>
      <title>新I/O</title>
      <link>https://qinry.github.io/posts/2020-04-28-java-newio/</link>
      <pubDate>Tue, 28 Apr 2020 20:16:54 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-04-28-java-newio/</guid>
      <description>通道是数据存储的地方，缓冲器充当着通道与外部数据交换的媒介 通道Channel FileChannel可以通过FileOutputStream、</description>
    </item>
    
    <item>
      <title>文件路径与I/O流</title>
      <link>https://qinry.github.io/posts/2020-04-28-java-file-iostream/</link>
      <pubDate>Tue, 28 Apr 2020 17:42:29 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-04-28-java-file-iostream/</guid>
      <description>File类 File类作用和它的名字不太相符，File除了可以代表一个特定的文件，还可以表示一个目录（包含一组文件），最准确认为是“路径”。还</description>
    </item>
    
    <item>
      <title>对象序列化</title>
      <link>https://qinry.github.io/posts/2020-04-28-java-serialize/</link>
      <pubDate>Tue, 28 Apr 2020 16:01:24 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-04-28-java-serialize/</guid>
      <description>持久性 如果对象能够在程序不运行还能保存其状态信息。可以通过将信息写入文件或数据库来达到程序下次执行时，对象重建后与上次拥有一致的信息。在Ja</description>
    </item>
    
    <item>
      <title>压缩类</title>
      <link>https://qinry.github.io/posts/2020-04-28-java-zip/</link>
      <pubDate>Tue, 28 Apr 2020 14:50:00 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020-04-28-java-zip/</guid>
      <description>Java I/O库提供压缩功能输入、输出流，这些类是按字节方式处理，常用的压缩类有DeflaterOutputStream和它的子类ZipOutpu</description>
    </item>
    
    <item>
      <title>类型信息</title>
      <link>https://qinry.github.io/posts/2019-11-28-java-typeinfo/</link>
      <pubDate>Thu, 28 Nov 2019 18:25:37 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-11-28-java-typeinfo/</guid>
      <description>Class对象 每个类都存在包含类型信息的Class对象，Class对象属于Java类中Class类型。有两种方法获得某类型的Class 对象，</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://qinry.github.io/posts/2019-11-25-java-strings/</link>
      <pubDate>Mon, 25 Nov 2019 09:46:16 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-11-25-java-strings/</guid>
      <description>String对象不可变 String对象被创建后不可修改，某些方法看似是修改源字符串，其实是重新创建新字符串来代替。 StringBuilder 在循环体中对String</description>
    </item>
    
    <item>
      <title>异常处理</title>
      <link>https://qinry.github.io/posts/2019-11-24-java-exceptions/</link>
      <pubDate>Sun, 24 Nov 2019 08:47:23 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-11-24-java-exceptions/</guid>
      <description>异常抛出 创建一个异常对象，然后从当前环境对象抛出，阻止当前方法或作用域的执行。 语法: throw new NullPointerException, 关键字throw之后，和创建普通对象一样创建异常对</description>
    </item>
    
    <item>
      <title>内部类</title>
      <link>https://qinry.github.io/posts/2019-10-24-java-innerclass/</link>
      <pubDate>Thu, 24 Oct 2019 16:48:18 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-24-java-innerclass/</guid>
      <description>创建内部类 直接将内部类置于外围类中 // innerclasses/Parcel1.java // Creating inner classes public class Parcel1 { class Contents { private int i = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } String readLabel() { return label; } } // Using inner classes looks just like</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>https://qinry.github.io/posts/2019-10-22-java-interfaces/</link>
      <pubDate>Tue, 22 Oct 2019 16:29:48 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-22-java-interfaces/</guid>
      <description>抽象类和抽象方法 抽象方法：仅有声明而没有方法体。 如： abstract void f(); 抽象类： 包含抽象方法的类。 如果一个类包含一个或多个抽象方法，该类必须限定为抽象的。</description>
    </item>
    
    <item>
      <title>多态</title>
      <link>https://qinry.github.io/posts/2019-10-21-java-polymorphism/</link>
      <pubDate>Mon, 21 Oct 2019 17:01:44 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-21-java-polymorphism/</guid>
      <description>多态的作用 消除类型间的耦合关系 改善代码的组织结构和可读性，还能够创建可扩展程序 绑定 将一个方法调用同一个方法主体关联起来称为绑定。若在程序执行</description>
    </item>
    
    <item>
      <title>复用类</title>
      <link>https://qinry.github.io/posts/2019-10-21-java-reuse/</link>
      <pubDate>Mon, 21 Oct 2019 12:54:56 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-21-java-reuse/</guid>
      <description>从现有类生成新类型 组合： 一般将现有类型作为新类型底层实现一部分来加以复用 继承：仅仅复用接口 用到 extends关键字 继承 继承中的初始化 在构造器</description>
    </item>
    
    <item>
      <title>访问权限</title>
      <link>https://qinry.github.io/posts/2019-10-21-java-access/</link>
      <pubDate>Mon, 21 Oct 2019 09:06:40 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-21-java-access/</guid>
      <description>访问权限控制 public （公共访问权限, 谁都可以访问） private （类内私有，用户无法访问） protected （继承访问权限，也提供包内访问） 包访问权限（没有关键词修饰，供包内</description>
    </item>
    
    <item>
      <title>初始化和清理</title>
      <link>https://qinry.github.io/posts/2019-10-20-java-initialization/</link>
      <pubDate>Sun, 20 Oct 2019 09:28:44 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-20-java-initialization/</guid>
      <description>构造器确保初始化 构造器确保初始化，名字与类名一致，允许重载，且是特殊的无返回值(与void不同)的方法。 在Java中，初始化与创建绑定在一起</description>
    </item>
    
    <item>
      <title>控制流程</title>
      <link>https://qinry.github.io/posts/2019-10-19-java-control-flow/</link>
      <pubDate>Sat, 19 Oct 2019 20:27:47 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-19-java-control-flow/</guid>
      <description>关键词：if-else, while, do-while, for, return, break, continue, switch 条件判断 (if-else) 判断某个条件是否为真，若为真，则执行 if 后的语句;为假执行else后的语句 例如: int i = 47; if (i %</description>
    </item>
    
    <item>
      <title>操作符</title>
      <link>https://qinry.github.io/posts/2019-10-18-java-operator/</link>
      <pubDate>Fri, 18 Oct 2019 21:55:03 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-18-java-operator/</guid>
      <description>静态导入 通过封装，自建类库已到达更简短语句答应字符串。可以静态导入（import static LibraryName）类库中静态对象 表达式 副作用：有些运</description>
    </item>
    
    <item>
      <title>一切都是对象</title>
      <link>https://qinry.github.io/posts/2019-10-18-java-objects/</link>
      <pubDate>Fri, 18 Oct 2019 20:41:27 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019-10-18-java-objects/</guid>
      <description>对象及内存分布 在Java中一切都被视为对象，但操纵的标识符实际上是对象的“引用” 字符串可以用带引号的初始值， 如： String s = &amp;quot;sdf&amp;quot;; 关键字 new 用来创建一个</description>
    </item>
    
  </channel>
</rss>
