[{"content":"一、简介 Apache RocketMQ 是一个统一的消息引擎，轻量级的数据处理平台\n特点：\n 低延迟 以金融为导向，具有跟踪和审核功能的高可用性 行业可持续发展，万亿级消息容量保证 供应商中立 大数据友好，批量转移，具有多功能集成，可实现淹没吞吐量。 海量积累，不损失性能的情况下积累消息，前提是给足磁盘空间  二、搭建 Rocket MQ 本文在 Linux 下搭建 Rocket MQ。\n前提：\n CentOS Linux release 7.9.2009 Docker 20.10.12 Maven 3.8.4  2.1 用 Docker 安装 Rocket MQ 首先，用 git 克隆 rocketmq-docker 项目\n1  git clone https://github.com/apache/rocketmq-docker.git   接着生成 Rocket MQ 镜像，build-image.sh 脚本需要传入对应的队列版本号和基础镜像\n1 2 3  cd image-build sh build-image.sh 4.5.0 alpine cd ../   然后，以单节点方式运行镜像，stage.sh 脚本需要传入对应的版本号。\n1 2  sh stage.sh 4.5.0 cd stages/4.5.0/templates   这里需要自定义 broker 的 ip 地址，将 brokerIP1 改成对应节点的IP地址就行了，可以通过 ip addr 查询。\n1  vim data/broker/conf/broker.conf   接着修改 play-docker.sh 中 start_namesrv_broker() 里面 “# Start Broker” 下的一条命令，可以将他注释掉，然后添加以下内容：\n1  docker run -d -p 10911:10911 -p 10909:10909 -v `pwd`/data/broker/logs:/root/logs -v `pwd`/data/broker/store:/root/store -v `pwd`/data/broker/conf/broker.conf:/home/rocketmq/rocketmq-4.5.0/conf/broker.conf --name rmqbroker --link rmqnamesrv:namesrv -e \u0026#34;NAMESRV_ADDR=namesrv:9876\u0026#34; apacherocketmq/rocketmq:4.5.0 sh mqbroker -c /home/rocketmq/rocketmq-4.5.0/conf/broker.conf   最后，运行并检查\n1 2  ./play-docker.sh alpine docker ps -a   rmqnamesrv 和 rmqbroker 两个容器在运行，状态为 up 即可。\n2.2 安装 rocketmq-dashboard 首先，git 克隆 rocketmq-dashboard 项目\n1  git clone https://github.com/apache/rocketmq-dashboard.git   运行前需要安装好 nodejs 和 yarn\n1 2 3  curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash - sudo yum install nodejs npm install --global yarn   接着，这个项目是 spring boot 项目，执行下面命令，jvm 参数写队列对应的ip地址和端口即可\nmvn clean package -Dmaven.test.skip\rnohup java -jar target/rocketmq-dashboard-1.0.1-SNAPSHOT.jar -Drmq.namesrv.addr=127.0.0.1:9876 \u0026gt;\u0026gt; rocketmq-dashboard.log \u0026amp;\r或\nmvn spring-boot:run -Dspring-boot.run.jvmArguments=\u0026quot;-Drmq.namesrv.addr=127.0.0.1:9876\u0026quot;\r服务器默认端口号为 8080，用浏览器访问 rocketmq-dashboard 项目。\n 注意：建议先打包再运行\n 查看集群标签页下的默认集群中一个分片地址是否与节点的地址一致，而非 172.17.0.1。\n三、演示官网的 simple example 演示前，需要到 rocketmq-dashboard的网页，在主题标签页下添加所需的主题(topic)，例如：“TopicTest”，结果如下：\n接着是创建官网的simple example。\n比如，创建单模块的maven项目，groupId 为 com.example.rocketmqsimpleexample，artifactId 为 rocketmq-simple-example。\n再接着，添加依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.rocketmq\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rocketmq-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   陆续在包com.example.rocketmqsimpleexample下创建 SyncProducer 和 Consumer 类。\n 注意要修改为自己的生产者和消费者的组名与name server 地址，还有消息的主题、标签等。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class SyncProducer { public static void main(String[] args) throws Exception { //实例化生产者组名  DefaultMQProducer producer = new DefaultMQProducer(\u0026#34;testrmq\u0026#34;); // 指定 name server 对应的地址  producer.setNamesrvAddr(\u0026#34;10.119.6.210:9876\u0026#34;); // 启动实例.  producer.start(); for (int i = 0; i \u0026lt; 100; i++) { try { // 创建消息实例，指定主题、标签和消息体.  Message msg = new Message(\u0026#34;TopicTest\u0026#34; /* Topic */, \u0026#34;TagA\u0026#34; /* Tag */, (\u0026#34;Hello RocketMQ \u0026#34; + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); // 调用发送消息的方法分发消息给某个 broker  SendResult sendResult = producer.send(msg); System.out.printf(\u0026#34;%s%n\u0026#34;, sendResult); } catch (Exception e) { e.printStackTrace(); Thread.sleep(1000); } } // 之后不再使用，关闭生产者  producer.shutdown(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Consumer { public static void main(String[] args) throws InterruptedException, MQClientException { // 指定消费者组名并实例化.  DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\u0026#34;testrmq\u0026#34;); // 指定 name server 地址.  consumer.setNamesrvAddr(\u0026#34;10.119.6.210:9876\u0026#34;); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); // 订阅消费多个主题  consumer.subscribe(\u0026#34;TopicTest\u0026#34;, \u0026#34;*\u0026#34;); // 注册回调用于从 broker 执行拉取到达的消息.  consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List\u0026lt;MessageExt\u0026gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(\u0026#34;%s Receive New Messages: %s %n\u0026#34;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); //启动消费者  consumer.start(); System.out.printf(\u0026#34;Consumer Started.%n\u0026#34;); } }   先运行Consumer 然后 运行 SyncProducer。\nConsumer 的部分控制台消息如下：\nConsumer Started.\rConsumeMessageThread_1 Receive New Messages: [MessageExt [queueId=10, storeSize=178, queueOffset=6, sysFlag=0, bornTimestamp=1643009838234, bornHost=/10.253.129.14:52001, storeTimestamp=1643009836266, storeHost=/10.119.6.210:10911, msgId=0A7706D200002A9F00000000000045E2, commitLogOffset=17890, bodyCRC=613185359, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message{topic='TopicTest', flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=7, CONSUME_START_TIME=1643009838491, UNIQ_KEY=0200000115BC18B4AAC279CC649A0000, WAIT=true, TAGS=TagA}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 48], transactionId='null'}]] ...\r...\rSyncProducer 的部分控制台消息如下：\nSendResult [sendStatus=SEND_OK, msgId=0200000115BC18B4AAC279CC649A0000, offsetMsgId=0A7706D200002A9F00000000000045E2, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-abc, queueId=10], queueOffset=6]\rSendResult [sendStatus=SEND_OK, msgId=0200000115BC18B4AAC279CC65960001, offsetMsgId=0A7706D200002A9F0000000000004694, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-abc, queueId=11], queueOffset=6]\r...\r...\r","description":"快速上手 Rocket MQ","id":0,"section":"posts","tags":["rocketmq"],"title":"快速上手 Rocket MQ","uri":"https://qinry.github.io/posts/2022/01/quickstart-rocketmq/"},{"content":"Docker 概述 Docker 是一个用于开发、传送和运行应用程序的开放平台。使应用和基础设施隔离。像管理应用一样管理设施。\nDocker 容器：打包和运行应用的隔离环境。\nDocker提供的服务：\n 开发应用的支持性组件可以在容器中运行 容器可当作发布和测试单元 当要部署应用时，可以为应用编排服务部署到生产环境的容器中。  Docker 架构 使用客户端-服务端的架构。客户端与服务端可在同一系统，也可以客户端连接远程服务端（Docker Host）。客户端发送命令，服务端接受命令后操作，比如构建、运行和发布等。\n还一种客户端是 Docker Compose ，使用它让一组容器来组成的应用程序，就是所谓的服务编排。\n Docker Daemon - 监听 Docker API 请求和管理 Docker 对象 如：镜像images，容器containers，网络networks，数据卷volumes Docker Client - 与 Docker 交互的主要工具，当运行 docker run 时，客户端把命令发送 给 dockerd 并执行 Docker registries - 存储 Docker 镜像。Docker Hub 是官方镜像站点。使用 docker pull 从仓库获取镜像。docker push 来上传镜像 Docker objects   images - 用于创建容器说明的只读模版。docker images 可查看已拉取的镜像\n  containers - 正在运行的镜像实例。docker ps可查看运行中的容器\n   Docker Desktop - 包含了 Docker Daemon、Docker Client 和 Docker Compose等组件 在 Windows 和 Mac 下运行的桌面应用  Docker 安装 在 Linux 上的安装。Linux 的发行版是 CentOS 7。\n1 2 3 4 5 6 7 8 9 10  # 更新包 yum update # 安装依赖 yum install -y yum-utils device-mapper-persistent-data lvm2 # 设置 docker 的 yum 源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 安装 yum install -y docker-ce # 完成后，检查 docker -v   最终显示：\nDocker version 20.10.11, build dea9396\r常用命令 docker daemon 管理 1 2 3 4 5 6 7 8 9 10  # 启动 docker daemon systemctl start docker # 关闭 systemctl stop docker # 重启 systemctl restart docker # 查看进程信息 systemctl status docker # 允许开机自启 systemctl enable docker   镜像管理 1 2 3 4 5 6 7 8 9 10 11 12  # 查看本地所有镜像 docker images # 查看所有镜像id docker images -q # 从仓库搜索镜像，这里 mysql 指 镜像名称 docker search mysql # 拉取/下载镜像，可以指定镜像 mysql 版本 docker pull mysql:5.7 # 使用 CONTAINER ID(容器ID) 删除镜像，具体ID具体查看 docker rmi 59b80c0eb775 # 删除所有 docker rmi `docker images -q`   容器管理 1 2 3 4  # 查看运行的容器 docker ps # 查看所有容器，包括运行的和运行退出的 docker ps -a   1 2 3 4 5 6 7 8 9 10 11 12  # 创建并运行容器 docker run -id \\ -p 3306:3306 \\ --name mysql \\ -v ~/docker-data/mysql/data:/data \\ -e MYSQL_ROOT_PASSWORD=root \\ mysql:5.7 # 连接容器, /bin/bash 是进入容器使用的命令 docker exec -it mysql /bin/bash docker exec -it mysql mysql -uroot -p    -i - 保持容器运行。容器创建后，运行，再退出，不会删除容器。它可与d和t连用 -d - 后台运行容器 -t - 分配一个伪终端 –name - 为容器命名 -p - 端口映射，容器与宿主机隔离的，要想从宿主机访问容器，需要做端口映射，前者是宿主端口，后者才是容器端口。使用数据卷也是先宿主后容器。 -v - 使用数据卷，宿主机的目录与容器目录绑定。用于数据交互和持久化。如果宿主机目录未指定，就使用默认生成的目录。 -e - 定义容器使用的环境变量。这里指定 MySQL root 用户密码。 –volumes-from - 继承其他容器的数据卷。  1 2 3 4 5 6 7 8  # 停止容器 docker stop mysql # 启动容器 docker start mysql # 删除容器 docker rm mysql # 查看容器信息 docker inspect mysql    数据卷就是宿主机下的目录或文件，可以被多个容器挂载。容器可以挂载多个数据卷\n Docker 镜像原理 Docker镜像本质是一个分层的文件系统。\n它基于 Linux 文件系统，Linux包括了bootfs和rootfs。最底层bootfs包含引导加载程序和内核，但镜像的bootfs使用的是宿主机的。这就是镜像文件比Linux某些发行版如 CentOS 的 ISO 镜像 的尺寸还有小的原因。\n往上层的rootfs就是 Linux 的 root 文件系统，称作基础镜像。然后再往上叠加其他镜像。使用统一文件系统技术把多层文件系统虚拟化成一个文件系统。\n一个子镜像还可以放在一个父镜像上面，如 Tomcat 镜像依赖于父镜像 OpenJDK 和基础镜像。\n当镜像启动容器时，会在最顶层加载一个可读写的文件系统作为容器。\n镜像制作 将现有容器制作成镜像 1 2 3 4 5 6  # 容器49842ef82091 转镜像 mytomcat:1.0 docker commit 49842ef82091 mytomcat:1.0 # 压缩镜像 docker save -o mytomcat.tar mytomcat:1.0 # 从压缩文件导入镜像 docker load -i mytomcat.tar   用Dockerfile制作镜像 Dockerfile 是文本文件，包含构建镜像说明。当执行 docker build 会读取这个文件的指令来帮助构建镜像。Dockerfile的默认文件名就是\u0026quot;Dockerfile\u0026quot;。\n如果不使用默认名，则可命名为 Dockerfile.\u0026lt;something\u0026gt;/ \u0026lt;something\u0026gt;.Dockerfile，命令执行时用 –file（-f）指定它。项目的主Dockerfile建议使用默认的。\n按照官方的教程的构建第一个Java 应用镜像如下\n由于是在Linux下使用docker，运行 docker build 设置环境变量来启用 BuildKit，例如：\n1  DOCKER_BUILDKIT=1 docker build .   可以配置文件来默认启用\n1 2 3 4  { \u0026#34;features\u0026#34;:{\u0026#34;buildkit\u0026#34; : true} }   然后重启 docker\n从github克隆一个demo\n1 2 3  cd ~ git clone https://github.com/spring-projects/spring-petclinic.git cd spring-petclinic   可以去测试一下这个demo是否能正常运行\n1  ./mvnw spring-boot:run   用浏览器打开 http://localhost:8080，如果使用虚拟机 Linux 并从宿主机访问,localhost 要改成虚拟机的ip即可。\n接着创建一个Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 12 13  # syntax=docker/dockerfile:1FROMopenjdk:16-alpine3.13WORKDIR/appCOPY .mvn/ .mvnCOPY mvnw pom.xml ./RUN ./mvnw dependency:go-offlineCOPY src ./srcCMD [\u0026#34;./mvnw\u0026#34;, \u0026#34;spring-boot:run\u0026#34;]  第1行：告诉 docker 构建器所使用dockerfile的版本1语法。\n第3行：使用openjdk的镜像，它包含 Java JDK ，就能够运行 Java 程序\n第5行：设置镜像的工作目录。后续指令将在这个目录下进行。方便我们后续使用相对路径而非绝对路径\n第7、8行：为了后续执行 ./mvnw dependency 命令，需要将 Maven Wrapper 和 pom.xml文件放入镜像内。COPY指令有两个参数，第一个是要复制的文件，可以多个文件，第二个是复制到的目标。第7行目标是文件，第8行的目标是目录。注：最后空格后的肯定是第二个参数。\n第9行：RUN 像在shell运行命令，这里会下载maven项目的依赖项到镜像\n第11行：将源代码复制到镜像\n第13行：CMD 指定当制作的镜像在容器内执行时，将会执行的操作。\nRUN是构建时执行的命令，而CMD运行时执行的命令。\n它由一些列命令构成。每个指令基于基础镜像构成一层文件系统，最终形成镜像。\n其他更多的Dockerfile指令见\n再接着，创建 .dockeringnore 文件让 docker 构建时要忽略的文件或目录，以提高构建性能。这里 maven 测试这个 demo 会生成一个输出目录 target，可以忽略掉。\n.dockerignore的内容如下：\ntarget\r最后构建镜像\n1  docker build --tag java-docker .    --tag - 给镜像打标签 格式是 “名号:版本标签”，如：java-docker:v1.0.0。如果没指定标签，默认使用 latest . - 命令最后的 . 是构建镜像的上下文。它是指定了路径所在文件集合，这里表示当前路径下的文件集。构建过程将会处理这些文件  可以通过 docker images 查看所制作的镜像。还可以创建新的标签如： docker tag java-docker:latest docker:v1.0.0\nDockerfile 的优点：\n 保证开发人员可以为团队提供完全一致的开发环境 保证测试人员可以直接使用开发人员的构建的镜像或使用Dockerfile构建新镜像进行测试 为运维人员，部署应用时无须担心环境迁移的问题。可以无缝移植。  运行制作好的镜像为容器 1 2 3 4  docker run -dp 8080:8080 --name springboot-server java-docker curl --request GET \\ --url http://localhost:8080/actuator/health \\ --header \u0026#39;content-type: application/json\u0026#39;   输出：\n{\u0026quot;status\u0026quot;:\u0026quot;UP\u0026quot;}\r在开发应用时，可能需要其他容器作为支持，比如 Spring Boot 应用容器需要 MySQL 数据库容器支持\n首先在容器中创建 MySQL 数据库，使用数据卷让多个容器共享数据和配置\n1 2  docker volume create mysql_data docker volume create mysql_config   创建 network 让应用和数据库共享此网络以互相通信。这里的 network 为用户定义的桥接网络。为了在后面的定义 jdbc url 的时候可以作为用服务名当作连接字符串来使用。\n如：jdbc:mysql://mysqlserver/petclinic\n1  docker network create mysqlnet   运行mysql容器\n1 2 3 4 5 6 7  docker run -it --rm -d -v mysql_data:/var/lib/mysql \\ -v mysql_config:/etc/mysql/conf.d \\ --network mysqlnet \\ --name mysqlserver \\ -e MYSQL_USER=petclinic -e MYSQL_PASSWORD=petclinic \\ -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=petclinic \\ -p 3306:3306 mysql   上一节中的 springboot-server 容器想要使用 MySQL ，就要修改 Dockerfile 文件，将 CMD 的修改为：\nCMD [\u0026quot;./mvnw\u0026quot;, \u0026quot;spring-boot:run\u0026quot;, \u0026quot;-Dspring-boot.run.profiles=mysql\u0026quot;, \u0026quot;-Dmaven.test.skip\u0026quot;]\r使这个 demo 从 H2 内存数据库切换为 MySQL 数据库，重新新构建一次。然后启动容器连接 mysqlserver。\n1 2 3 4 5  docker run --rm -d \\ --name springboot-server \\ --network mysqlnet \\ -e MYSQL_URL=jdbc://mysqlserver/petclinic \\ -p 8080:8080 java-docker   Docker Compose 借助容器开发应用 编写第一个compose文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  version:\u0026#39;3.8\u0026#39;services:petclinic:build:context:.ports:- 8000:8000- 8080:8080environment:- SERVER_PORT=8080- MYSQL_URL=jdbc:mysql://mysqlserver/petclinicvolumes:- ./:/appcommand:./mvnw spring-boot:run -Dmaven.test.skip -Dspring-boot.run.profiles=mysql -Dspring-boot.run.jvmArguments=\u0026#34;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000\u0026#34;mysqlserver:image:mysql:latestports:- 3306:3306environment:- MYSQL_ROOT_PASSWORD=- MYSQL_ALLOW_EMPTY_PASSWORD=true- MYSQL_USER=petclinic- MYSQL_PASSWORD=petclinic- MYSQL_DATABASE=petclinicvolumes:- mysql_data:/var/lib/mysql- mysql_config:/etc/mysql/conf.dvolumes:mysql_data:mysql_config:  启动应用前安装 docker compose\n1 2  sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose   接着编译镜像并运行\n1  docker-compose -f docker-compose.dev.yml up --build   Dockerfile和docker-compose.yml区别\n前者是制作自定义镜像的说明，后者是容器集群做快速编排，用于部署分布式应用。\n","description":"Docker 快速开始","id":1,"section":"posts","tags":["docker"],"title":"Docker 快速开始","uri":"https://qinry.github.io/posts/2021/12/docker-quickstart/"},{"content":"创建Gradle项目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.5.6\u0026#39; id \u0026#34;com.thinkimi.gradle.MybatisGenerator\u0026#34; version \u0026#34;2.4\u0026#34; } apply plugin: \u0026#39;java\u0026#39; apply plugin: \u0026#39;io.spring.dependency-management\u0026#39; group \u0026#39;io.github.qinry\u0026#39; version \u0026#39;1.0-SNAPSHOT\u0026#39; sourceCompatibility = JavaVersion.VERSION_11 repositories { mavenCentral() } dependencies { implementation \u0026#39;org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; } test { useJUnitPlatform() }   编写 generatorConfig.xml 在项目根路径下创建generatorConfig.xml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id=\u0026#34;Mysql\u0026#34; targetRuntime=\u0026#34;Mybatis3\u0026#34;\u0026gt; \u0026lt;plugin type=\u0026#34;org.mybatis.generator.plugins.SerializablePlugin\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;plugin type=\u0026#34;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;plugin type=\u0026#34;org.mybatis.generator.plugins.FluentBuilderMethodsPlugin\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;plugin type=\u0026#34;org.mybatis.generator.plugins.ToStringPlugin\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;!-- 生成的代码没有注释 --\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql://localhost:3306/testdb\u0026#34; userId=\u0026#34;springuser\u0026#34; password=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;!-- 不强制使用BigDecimal字段，使数据库为NUMBERIC或DECIMAL字段被整型类型替换，会更易于使用 --\u0026gt; \u0026lt;javaTypeResolver\u0026gt; \u0026lt;property name=\u0026#34;forceBigDecimals\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.owk.domain\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;com.owk.mapper\u0026#34; targetProject=\u0026#34;src/main/resources\u0026#34;/\u0026gt; \u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;com.owk.mapper\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;/\u0026gt; \u0026lt;table tableName=\u0026#34;student\u0026#34; domainObjectName=\u0026#34;Student\u0026#34; \u0026gt; \u0026lt;generatedKey column=\u0026#34;ID\u0026#34; sqlStatement=\u0026#34;MySql\u0026#34; identity=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026#34;grade\u0026#34; domainObjectName=\u0026#34;Grade\u0026#34;\u0026gt; \u0026lt;generatedKey column=\u0026#34;ID\u0026#34; sqlStatement=\u0026#34;MySql\u0026#34; identity=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;    org.mybatis.generator.plugins.SerializablePlugin 生成的模型类实现Serializable接口 org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin 产生的影响是，如果生成xml映射文件的文件名已存在，则不会合并已存在的内容。这个插件按需要添加。总之就是会覆盖之前的内容 org.mybatis.generator.plugins.FluentBuilderMethodsPlugin 生成的模型类准备流畅建造者模式，在测试用例可查看到使用 org.mybatis.generator.plugins.ToStringPlugin 为模型创建 toString() 方法 \u0026lt;jdbcConnection\u0026gt; 用于连接数据库，代码生成插件是按照数据库表生成模型、映射器和 xml \u0026lt;javaModelGenerator\u0026gt; 决定生成Java模型类的位置，String类型字段使不实用 trim() 方法 \u0026lt;sqlMapGenerator\u0026gt; 决定生成映射器xml文件的位置 \u0026lt;javaClientGenerator\u0026gt; 决定生成映射器接口的位置  创建数据库表 这个插件是依赖于数据库生成代码的。所以要提前建好表格\n1 2 3 4 5 6 7 8 9 10 11 12  createtablestudent(idbigintnotnullauto_increment,stu_namevarchar(32)defaultnull,grade_idbigintdefaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;createtablegrade(idbigintnotnullauto_increment,grade_namevarchar(32)defaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;  执行生成任务 1  gradle mbGenerator   保证包 com.owk 提前创建好，这个插件默认配置不会创建层级超过一的目录。有IDE支持就更加方便。\n生成代码如下：\nsrc/main\r├── java\r│ └── com\r│ └── owk\r│ ├── mapper\r│ │ ├── GradeMapper.java\r│ │ └── StudentMapper.java\r│ └── domain\r│ ├── Grade.java\r│ ├── GradeExample.java\r│ ├── Student.java\r│ └── StudentExample.java\r└── resources\r├── com\r│ └── owk\r│ └── mapper\r│ ├── GradeMapper.xml\r│ └── StudentMapper.xml\r设置项目属性 1 2 3 4 5 6 7 8 9 10 11  spring:datasource:url:jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8driver-class-name:com.mysql.cj.jdbc.Driverusername:springuserpassword:123456mybatis:config-location:classpath:mybatis-config.xmllogging:level:com.owk.mapper:trace  设置数据源还有设置mybatis配置文件位置。\n编写mybatis-config.xml 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;aggressiveLazyLoading\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;SLF4J\u0026#34; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt;   设置mybatis，开启数据库字段的下划线写法映射为驼峰写法。开启延迟加载，取消积极加载。指定映射器路径。\n使用生成的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  /** * 测试前请先清空表数据 \u0026lt;code\u0026gt;truncate student\u0026lt;/code\u0026gt; */ @SpringBootTest @TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class StudentMapperTests { @Resource private StudentMapper studentMapper; private List\u0026lt;Long\u0026gt; ids; @BeforeEach void setUp() { System.out.println(\u0026#34;\\033[0;92m****************测试开始******************\\033[0m\u0026#34;); System.out.println(\u0026#34;\\033[0;92m***************填充三行数据**************\\033[0m\u0026#34;); studentMapper.insert(new Student().withStuName(\u0026#34;张三\u0026#34;).withGradeId(1L)); studentMapper.insert(new Student().withStuName(\u0026#34;李四\u0026#34;).withGradeId(2L)); studentMapper.insert(new Student().withStuName(\u0026#34;王五\u0026#34;).withGradeId(3L)); ids = studentMapper.selectByExample(null).stream().map(Student::getId).collect(Collectors.toList()); } /** * 增 */ @Test @Order(1) void create() { System.out.println(\u0026#34;\\033[0;92m***************插入两行行数据**************\\033[0m\u0026#34;); // 使用流畅建造者，动态插入字段值  studentMapper.insertSelective(new Student().withStuName(\u0026#34;赵六\u0026#34;).withGradeId(1L)); // [1]  // 除了主键外，所有字段值插入  studentMapper.insert(new Student().withStuName(\u0026#34;武七\u0026#34;).withGradeId(2L)); // [2]  StudentExample example = new StudentExample(); StudentExample.Criteria criteria = example.createCriteria(); criteria.andStuNameIn(List.of(\u0026#34;赵六\u0026#34;, \u0026#34;武七\u0026#34;)); System.out.println(\u0026#34;\\033[0;92m*****************查询刚插入的数据****************\\033[0m\u0026#34;); studentMapper.selectByExample(example); } /** * 查 */ @Test @Order(2) void read() { System.out.println(\u0026#34;\\033[0;92m*************查询学生姓名包含李*************\\033[0m\u0026#34;); StudentExample example = new StudentExample(); StudentExample.Criteria criteria = example.createCriteria(); criteria.andStuNameLike(\u0026#34;%李%\u0026#34;); List\u0026lt;Student\u0026gt; students = studentMapper.selectByExample(example); // [3]  List\u0026lt;Long\u0026gt; ids = students.stream().map(Student::getId).collect(Collectors.toList()); ids.forEach(id -\u0026gt; { System.out.println(\u0026#34;\\033[0;92m********查询主键\u0026#34;+id+\u0026#34;的数据********\\033[0m\u0026#34;); studentMapper.selectByPrimaryKey(id); // [4]  }); } /** * 改 */ @Test @Order(3) void update() { System.out.println(\u0026#34;\\033[0;92m*******************更新id为\u0026#34;+ids.get(0)+\u0026#34;********************\\033[0m\u0026#34;); // 动态更新字段值  studentMapper.updateByPrimaryKeySelective(new Student().withId(ids.get(0)).withStuName(\u0026#34;杨开\u0026#34;).withGradeId(2L)); // [5]  // 更新所有字段值  studentMapper.updateByPrimaryKey(new Student().withId(ids.get(1)).withStuName(\u0026#34;苏颜\u0026#34;).withGradeId(3L)); // [6]  StudentExample example = new StudentExample(); StudentExample.Criteria criteria = example.createCriteria(); //  criteria.andStuNameLike(\u0026#34;%王%\u0026#34;); studentMapper.updateByExampleSelective(new Student().withGradeId(1L), example); // [7]  Student student = studentMapper.selectByPrimaryKey(ids.get(2)); studentMapper.updateByExample(student.withStuName(\u0026#34;夏霓裳\u0026#34;), example); // [8]  System.out.println(\u0026#34;\\033[0;92m*****************查询更新后的数据****************\\033[0m\u0026#34;); studentMapper.selectByExample(null); } /** * 删 */ @Test @Order(4) void delete() { List\u0026lt;Student\u0026gt; students = studentMapper.selectByExample(null); List\u0026lt;Long\u0026gt; ids = students.stream().map(Student::getId).collect(Collectors.toList()); System.out.println(\u0026#34;\\033[0;92m*******************删除主键\u0026#34;+ids.get(0)+\u0026#34;********************\\033[0m\u0026#34;); studentMapper.deleteByPrimaryKey(ids.get(0)); // [9]  System.out.println(\u0026#34;\\033[0;92m*******************删除年级id为3********************\\033[0m\u0026#34;); StudentExample example = new StudentExample(); StudentExample.Criteria criteria = example.createCriteria(); criteria.andGradeIdEqualTo(3L); studentMapper.deleteByExample(example); // [10]  System.out.println(\u0026#34;\\033[0;92m*****************查询删除后的数据****************\\033[0m\u0026#34;); studentMapper.selectByExample(null); } @AfterEach void tearDown() { System.out.println(\u0026#34;\\033[0;92m*******************测试结束********************\\033[0m\u0026#34;); studentMapper.deleteByExample(null); } }   这个测试用例，展示了增删改查的使用，条件查询如何创建动态的条件。更多的用法细节可以查看生成映射器接口和xml映射文件。\n更多参见官方文档\n","description":"Mybatis 代码生成插件，加快开发","id":2,"section":"posts","tags":["mybatis","orm","gradle"],"title":"Mybatis Generator 快速开始","uri":"https://qinry.github.io/posts/2021/11/mybatis-generator-crash/"},{"content":"创建Gradle项目 编写build.gradle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.5.6\u0026#39; apply false id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; id \u0026#39;java\u0026#39; } group \u0026#39;io.github.qinry\u0026#39; version \u0026#39;1.0-SNAPSHOT\u0026#39; sourceCompatibility = JavaVersion.VERSION_11 repositories { mavenCentral() } dependencyManagement { imports { mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES } } dependencies { implementation \u0026#39;org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; } test { useJUnitPlatform() } jar { archiveFileName = \u0026#39;mybatis-spring-boot-starter-sample.jar\u0026#39; }   这里创建了的是spring boot 库项目，用来提供其他项目来使用。注意 Spring Boot Plugin ，它是用来创建可执行的 jar，这里没有 main() 自然不需要，禁用掉。因此有这样的配置：\n1 2 3  plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.5.6\u0026#39; apply false }   虽然不使用Spring Boot Plugin 提供的 bootJar 任务创建可执行的 jar。但是需要Spring Boot 的依赖管理，这样引入 Spring Boot 起步依赖就不需要声明版本号了。如下配置：\n1 2 3 4 5 6 7 8 9  plugins { id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; } dependencyManagement { imports { mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES } }   编写settings.gradle\n1  rootProject.name = \u0026#39;mybatis-spring-boot-starter-sample\u0026#39;   设置属性 Spring Boot 起步依赖提供了大量的自动配置类，项目启动时会加载它们，所以我们减少了甚至不用配置程序，体现了它的理念——“约定大于配置”。当然可编写 application.properties 文件，此文件可用来自定义设置程序的属性来修改程序的行为。\nspring.datasource.url=jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\rspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\rspring.datasource.username=springuser\rspring.datasource.password=123456\rmybatis.config-location=classpath:mybatis-config.\rloggin.level.com.owk.mapper=trace\r设置数据源，mybatis 配置文件位置还有日志输出的等级。\n编写mybatis xml配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;aggressiveLazyLoading\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.owk.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/owk/mapper/StudentMapper.xml\u0026#34;/\u0026gt; \u0026lt;mapper resource=\u0026#34;com/owk/mapper/GradeMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写 Spring IoC 容器的配置元数据 1 2 3 4 5  @SpringBootConfiguration @EnableAutoConfiguration @MapperScan(\u0026#34;com.owk.mapper\u0026#34;) public class MybatisConfig { }   这个 Java 类用了注解 @SpringBootConfiguration 声明，说明它是基于 Java 配置的 Spring Bean 配置。\n注解 @EnableAutoConfiguration 启动起步依赖帮我们写好的默认配置，在 IoC 容器运行时会加载一系列自动配置类，例如：MybatisAutoConfiguration等，这些自动配置类会构建一些 Spring IoC 容器实例化、装配和管理的 Bean 实例，Bean 之间的依赖注入也有容器完成。当然我们也可以写我们自己 Bean 来替换默认的 Bean，大多数时不需要我们自己写。\n对于集合了 Mybatis 的 Spring Boot 最好使用 @MapperScan 此注解，识别指定包下的映射器接口。\n创建数据库 创建数据库 testdb 并建表插入数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  createtablestudent(idbigintnotnullauto_increment,stu_namevarchar(32)defaultnull,grade_idbigintdefaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;createtablegrade(idbigintnotnullauto_increment,grade_namevarchar(32)defaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;insertintostudent(stu_name,grade_id)values(\u0026#39;王二\u0026#39;,1),(\u0026#39;张三\u0026#39;,2),(\u0026#39;李四\u0026#39;,3);insertintograde(grade_name)values(\u0026#39;一年级\u0026#39;),(\u0026#39;二年级\u0026#39;),(\u0026#39;三年级\u0026#39;);  编写pojo实体 Student实体\n1 2 3 4 5 6 7 8 9  public class Student implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String stuName; private Long gradeId; private Grade grade; // 省略 setter getter 和 toString 方法 }   Grade实体\n1 2 3 4 5 6 7 8  public class Grade implements Serializable { private static final long serialVersionUID = 2L; private Long id; private String gradeName; private List\u0026lt;Student\u0026gt; students; // 省略 setter getter 和 toString 方法 }   编写 xml 映射文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.owk.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;sql id=\u0026#34;column_list\u0026#34;\u0026gt; id,stu_name,grade_id \u0026lt;/sql\u0026gt; \u0026lt;resultMap id=\u0026#34;studentResult\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;stu_id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;stuName\u0026#34; column=\u0026#34;stu_name\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeId\u0026#34; column=\u0026#34;grade_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;grade\u0026#34; column=\u0026#34;grade_id\u0026#34; resultMap=\u0026#34;gradeResult\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026#34;gradeResult\u0026#34; type=\u0026#34;Grade\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;grade_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeName\u0026#34; column=\u0026#34;grade_name\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultMap=\u0026#34;studentResult\u0026#34;\u0026gt; select s.id as stu_id, s.stu_name as stu_name, g.id as grade_id, g.grade_name as grade_name from student s left outer join grade g on s.grade_id = g.id \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   编写映射器接口 1 2 3 4  @Mapper public interface StudentMapper { List\u0026lt;Student\u0026gt; findAll(); }   如果之前的 MybatisConfig 没使用注解 @MapperScan 就会在这个配置类所在基础包下自动搜索用 @Mapper 标记的映射器接口。\n如果使用 @MapperScan，直接扫描指定包下的映射器接口，就可以不需要用 @Mapper 标记接口了。@MapperScan 注解还有属性 annotationClass 和 markerInterface。annotationClass找出指定注解的映射器接口；markerInterface找出指定标记父接口的映射器。\n编写测试用例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @SpringBootTest @ContextConfiguration(classes = {MybatisConfig.class}) public class StudentMapperTests { @Autowired private StudentMapper studentMapper; @Test void findAll() { List\u0026lt;Student\u0026gt; students = studentMapper.findAll(); System.out.println(\u0026#34;size:\u0026#34;+students.size()); System.out.println(\u0026#34;students:\u0026#34;); students.forEach(System.out::println); System.out.println(\u0026#34;grades:\u0026#34;); students.stream().map(Student::getGrade).forEach(System.out::println); } }   输出部分信息：\n021-11-11 13:03:07.065 DEBUG 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : ==\u0026gt; Preparing: select s.id as stu_id, s.stu_name as stu_name, g.id as grade_id, g.grade_name as grade_name from student s left outer join grade g on s.grade_id = g.id\r2021-11-11 13:03:07.192 DEBUG 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : ==\u0026gt; Parameters: 2021-11-11 13:03:07.309 TRACE 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : \u0026lt;== Columns: stu_id, stu_name, grade_id, grade_name\r2021-11-11 13:03:07.310 TRACE 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : \u0026lt;== Row: 1, 王二, 1, 一年级\r2021-11-11 13:03:07.313 TRACE 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : \u0026lt;== Row: 2, 张三, 2, 二年级\r2021-11-11 13:03:07.314 TRACE 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : \u0026lt;== Row: 3, 李四, 3, 三年级\r2021-11-11 13:03:07.318 DEBUG 61145 --- [ Test worker] com.owk.mapper.StudentMapper.findAll : \u0026lt;== Total: 3\rsize:3\rstudents:\rStudent{id=1, stuName='王二', gradeId=1, grade=Grade{id=1, gradeName='一年级', students=null}}\rStudent{id=2, stuName='张三', gradeId=2, grade=Grade{id=2, gradeName='二年级', students=null}}\rStudent{id=3, stuName='李四', gradeId=3, grade=Grade{id=3, gradeName='三年级', students=null}}\rgrades:\rGrade{id=1, gradeName='一年级', students=null}\rGrade{id=2, gradeName='二年级', students=null}\rGrade{id=3, gradeName='三年级', students=null}\r","description":"Mybatis-Spring-Boot-Starter 快速开始","id":3,"section":"posts","tags":["mybatis","spring","gradle","orm"],"title":"Mybatis-Spring-Boot-Starter 快速开始","uri":"https://qinry.github.io/posts/2021/11/mybatis-spring-boot-starter-crash/"},{"content":"创建Gradle项目 使用 IDEA 创建一个初始的Gradle项目\n编写项目配置和项目构建脚本\n1  rootProject.name = \u0026#39;mybatis-spring-sample\u0026#39;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  plugins { id \u0026#39;java\u0026#39; } group \u0026#39;io.github.qinry\u0026#39; version \u0026#39;1.0-SNAPSHOT\u0026#39; repositories { mavenCentral() } dependencies { implementation \u0026#39;org.springframework:spring-context:5.3.9\u0026#39; implementation \u0026#39;org.springframework:spring-jdbc:5.3.9\u0026#39; implementation \u0026#39;com.zaxxer:HikariCP:4.0.3\u0026#39; implementation \u0026#39;org.mybatis:mybatis:3.5.6\u0026#39; implementation \u0026#39;org.mybatis:mybatis-spring:2.0.6\u0026#39; implementation \u0026#39;ch.qos.logback:logback-classic:1.2.6\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java:8.0.27\u0026#39; testImplementation \u0026#39;org.springframework:spring-test:5.3.9\u0026#39; testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api:5.8.1\u0026#39; testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine:5.8.1\u0026#39; } test { useJUnitPlatform() } jar { archiveFileName = \u0026#39;mybatis-spring-sample.jar\u0026#39; }   引入mybatis-spring相关的依赖：\n spring相关：spring-context、spring-jdbc 和 spring-test mybatis相关：mybatis-spring、mybatis 连接池：HikariCP 数据库驱动：mysql-connector-java 日志：logback 单元测试：junit-jupiter-api 和 junit-jupiter-engine  配置 Spring IoC 容器元数据 编写applicationContext.xml，用于定义 IoC 容器实例化、组装和管理的对象及其依赖关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:/jdbc.properties\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.zaxxer.hikari.HikariDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${url}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${driver}\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis/mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath*:mybatis/mappers/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;io.github.qinry.mapper\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionTemplateBeanName\u0026#34; value=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   这里是使用解析属性占位符的配置，\u0026lt;context:property-placeholder /\u0026gt;，可以使用外部属性注入到这个xml配置。\napplicationContext.xml可以引入jdbc.propertis的属性。\ndriver=com.mysql.cj.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\rusername=springuser\rpassword=123456\rjdbc.propertis用于配置数据源所需的属性，使用${...}引用外部属性\n这里要配置数据源、事务管理器，还有与mybatis相关的SqlSessionFactory、SqlSessionTemplate 以及 MapperScannerConfigurer。事务管理器和SqlSessionFactory都依赖数据源，而SqlSessionTemplate依赖SqlSessionFactory。\nSqlSessionFactoryBean的属性还有两个经常要配置：configLocation和mapperLocations。分别指定 mybatis xml配置的位置和 xml 映射文件的位置（使用ant风格的路径指定多个mapper xml文件）。\nSpring IoC会帮我们创建 mapper和SqlSession，无须我们自己创建，使用@Autowired这个注解装配就可使用。\nmybatis xml配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;aggressiveLazyLoading\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;SLF4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;io.github.qinry.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt;   mybatis xml配置一般常常只要配置 settings 和 typeAliases即可。\n因为mybatis-spring提供了环境的配置，所以这里再配置环境会被忽略。\n映射文件的路径也不再用mappers标签设置，因为 SqlSessionFactoryBean 的 mapLocations 是更好的选择。\n这里使用了日志框架logback，它实现slf4j的接口，所以配置的值为SLF4J。\n编写logback日志输出配置\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;io.github.qinry.mapper\u0026#34; level=\u0026#34;trace\u0026#34;/\u0026gt; \u0026lt;root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt;   MapperScannerConfigurer这个组件用于扫描发现映射器接口。它属性basePackage指定接口所在的包。而 SqlSessionTemplate 是 SqlSession 接口的实现类，由 mybatis-spring 提供，它是线程安全的，它也负责将 MyBatis 的异常翻译成 Spring 中的 DataAccessExceptions。\n创建数据库 在mysql建库testdb还有创建两张表。\n1 2 3 4 5 6  createtablestudent(idbigintnotnullauto_increment,stu_namevarchar(32)defaultnull,grade_idbigintdefaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;  1 2 3 4 5  createtablegrade(idbigintnotnullauto_increment,grade_namevarchar(32)defaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;  测试数据：\n为grade表插入三条数据\n1 2 3 4  insertintograde(grade_name)values(\u0026#39;一年级\u0026#39;),(\u0026#39;二年级\u0026#39;),(\u0026#39;三年级\u0026#39;);  为student表插入三条数据\n1 2 3 4  insertintostudent(stu_name,grade_id)values(\u0026#39;王二\u0026#39;,1),(\u0026#39;张三\u0026#39;,2),(\u0026#39;李四\u0026#39;,3);  编写pojo 编写Student实体\n1 2 3 4 5 6 7 8 9 10  public class Student implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String stuName; private Long gradeId; private Grade grade; // 构造器、setter、getter和toString方法省略 }   编写Grade实体\n1 2 3 4 5 6 7 8  public class Grade implements Serializable { private static final long serialVersionUID = 2L; private Long id; private String gradeName; private List\u0026lt;Student\u0026gt; students; // 构造器、setter、getter和toString方法省略 }   编写映射器接口 编写StudentMapper\n1 2 3  public interface StudentMapper { List\u0026lt;Student\u0026gt; findAll(); }   编写xml映射文件 编写StudentMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;io.github.qinry.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;sql id=\u0026#34;column_list\u0026#34;\u0026gt; id,stu_name,grade_id \u0026lt;/sql\u0026gt; \u0026lt;resultMap id=\u0026#34;studentResult\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;stu_id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;stuName\u0026#34; column=\u0026#34;stu_name\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeId\u0026#34; column=\u0026#34;grade_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;grade\u0026#34; column=\u0026#34;grade_id\u0026#34; resultMap=\u0026#34;gradeResult\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026#34;gradeResult\u0026#34; type=\u0026#34;Grade\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;grade_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeName\u0026#34; column=\u0026#34;grade_name\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultMap=\u0026#34;studentResult\u0026#34;\u0026gt; select s.id as stu_id, s.stu_name as stu_name, g.id as grade_id, g.grade_name as grade_name from student s left outer join grade g on s.grade_id = g.id \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   编写junit5测试整合spring5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @ExtendWith(SpringExtension.class) @ContextConfiguration(locations = \u0026#34;classpath:/applicationContext.xml\u0026#34;) public class StudentMapperTests { @Autowired private SqlSession sqlSession; @Autowired private StudentMapper studentMapper; @Test void findAll() throws IOException { List\u0026lt;Student\u0026gt; students = studentMapper.findAll(); System.out.println(students.size()); students.stream().map(Student::getGrade).forEach(System.out::println); } }   测试类使用 SpringExtension.class 扩展，测试用的 spring 上下文配置为applicationContext.xml。@Autowired装配StudentMapper可以直接使用。\n输出：\n10:59:57.991 [Test worker] DEBUG io.github.qinry.mapper.StudentMapper - Cache Hit Ratio [io.github.qinry.mapper.StudentMapper]: 0.0\r10:59:58.806 [Test worker] DEBUG i.g.q.mapper.StudentMapper.findAll - ==\u0026gt; Preparing: select s.id as stu_id, s.stu_name as stu_name, g.id as grade_id, g.grade_name as grade_name from student s left outer join grade g on s.grade_id = g.id\r10:59:58.878 [Test worker] DEBUG i.g.q.mapper.StudentMapper.findAll - ==\u0026gt; Parameters: 10:59:58.972 [Test worker] TRACE i.g.q.mapper.StudentMapper.findAll - \u0026lt;== Columns: stu_id, stu_name, grade_id, grade_name\r10:59:58.973 [Test worker] TRACE i.g.q.mapper.StudentMapper.findAll - \u0026lt;== Row: 1, 王二, 1, 一年级\r10:59:58.976 [Test worker] TRACE i.g.q.mapper.StudentMapper.findAll - \u0026lt;== Row: 2, 张三, 2, 二年级\r10:59:58.977 [Test worker] TRACE i.g.q.mapper.StudentMapper.findAll - \u0026lt;== Row: 3, 李四, 3, 三年级\r10:59:58.978 [Test worker] DEBUG i.g.q.mapper.StudentMapper.findAll - \u0026lt;== Total: 3\r3\rGrade{id=1, gradeName='一年级', students=null}\rGrade{id=2, gradeName='二年级', students=null}\rGrade{id=3, gradeName='三年级', students=null}\r","description":"Mybatis-Spring 快速开始","id":4,"section":"posts","tags":["mybatis","spring","gradle","orm"],"title":"Mybatis-Spring 快速开始","uri":"https://qinry.github.io/posts/2021/11/mybatis-spring-crash/"},{"content":"为Mybatis创建Gradle项目 使用idea创建gradle项目\n项目结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  ├── build.gradle ├── gradle │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat ├── settings.gradle └── src ├── main │ ├── java │ └── resources └── test ├── java └── resources 9 directories, 6 files   编写build.gradle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  plugins { id \u0026#39;java\u0026#39; } group \u0026#39;io.github.qinry\u0026#39; version \u0026#39;1.0-SNAPSHOT\u0026#39; jar { archivesBaseName = \u0026#39;mybatis-sample\u0026#39; } repositories { mavenCentral() } dependencies { implementation \u0026#39;org.mybatis:mybatis:3.5.7\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java:8.0.27\u0026#39; testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api:5.7.0\u0026#39; testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine:5.7.0\u0026#39; } test { useJUnitPlatform() }   添加依赖org.mybatis:mybatis:3.5.7和mysql:mysql-connector-java:8.0.27，mybatis编译和运行都使用，作用域设置为implement，mysql-connector-java在运行时有效设置为runtimeOnly。设置打包的jar的文档基名为mybatis-sample。\n编写settings.gradle 1  rootProject.name = \u0026#39;mybatis-sample\u0026#39;   根项目名为 mybatis-sample，如果有子项目，要使用include后跟子项目的名称，把子项目声明在这里让gradle知道。\nMybatis配置 编写mybatis的xml配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;/db.properties\u0026#34;\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;setting name=\u0026#34;aggressiveLazyLoading\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;io/github/qinry/mapper/StudentMapper.xml\u0026#34; /\u0026gt; \u0026lt;mapper resource=\u0026#34;io/github/qinry/mapper/GradeMapper.xml\u0026#34; /\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   # src/main/resources/db.properties\rdriver=com.mysql.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/testdb?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\rusername=springuser\rpassword=123456\r配置最重要的两项，分别是environment和mappers。environment里最重要的是配置transactionManger和dataSource。\ntransactionManager事务管理器一般用JDBC。dataSource数据源的类型是Mybatis的POOLED，设置数据源的url、username、password还有driver。mappers配置的xml映射文件的位置。\n创建数据库表 在mysql建库testdb还有创建两张表。\n1 2 3 4 5 6  createtablestudent(idbigintnotnullauto_increment,stu_namevarchar(32)defaultnull,grade_idbigintdefaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;  1 2 3 4 5  createtablegrade(idbigintnotnullauto_increment,grade_namevarchar(32)defaultnull,primarykey(id))engine=innodbdefaultcharset=utf8mb4;  测试数据：\n为grade表插入三条数据\n1 2 3 4  insertintograde(grade_name)values(\u0026#39;一年级\u0026#39;),(\u0026#39;二年级\u0026#39;),(\u0026#39;三年级\u0026#39;);  为student表插入三条数据\n1 2 3 4  insertintostudent(stu_name,grade_id)values(\u0026#39;王二\u0026#39;,1),(\u0026#39;张三\u0026#39;,2),(\u0026#39;李四\u0026#39;,3);  创建实体pojo 创建Student类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  package io.github.qinry.pojo; public class Student implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String stuName; private Long gradeId; private Grade grade; public Student() { } public Student(Long id, String stuName, Long gradeId) { this.id = id; this.stuName = stuName; this.gradeId = gradeId; } public Student(String stuName, Long gradeId) { this.stuName = stuName; this.gradeId = gradeId; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public Long getGradeId() { return gradeId; } public void setGradeId(Long gradeId) { this.gradeId = gradeId; } public Grade getGrade() { return grade; } public void setGrade(Grade grade) { this.grade = grade; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, stuName=\u0026#39;\u0026#34; + stuName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, gradeId=\u0026#34; + gradeId + \u0026#34;, grade=\u0026#34; + grade + \u0026#39;}\u0026#39;; } }   Student类属性为id、stuName、gradeId，还有关联属性grade。\n创建Grade类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package io.github.qinry.pojo; import java.util.List; public class Grade implements Serializable { private static final long serialVersionUID = 2L; private Long id; private String gradeName; private List\u0026lt;Student\u0026gt; students; public Grade() { } public Grade(String gradeName) { this.gradeName = gradeName; } public Grade(Long id, String gradeName) { this.id = id; this.gradeName = gradeName; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getGradeName() { return gradeName; } public void setGradeName(String gradeName) { this.gradeName = gradeName; } public List\u0026lt;Student\u0026gt; getStudents() { return students; } public void setStudents(List\u0026lt;Student\u0026gt; students) { this.students = students; } @Override public String toString() { return \u0026#34;Grade{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, gradeName=\u0026#39;\u0026#34; + gradeName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, students=\u0026#34; + students + \u0026#39;}\u0026#39;; } }   Grade类的属性id、gradeName，还有关联属性grades。\nStudent和Grade两表之间关系是一对多。\n编写xml映射文件 改写mybatis-config.xml，在environments标签前添加typeAliases标签。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; ... \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;io.github.qinry.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; ... \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; ... \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   在编写xml映射文件时，使用pojo类型时可以直接使用类名（如Student），无须完全限定名（如io.github.qinry.pojo.Student）。\n编写StudentMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;io.github.qinry.mapper.StudentMapper\u0026#34;\u0026gt; \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;sql id=\u0026#34;column_list\u0026#34;\u0026gt; id,stu_name,grade_id \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; \u0026gt; select \u0026lt;include refid=\u0026#34;column_list\u0026#34; /\u0026gt; from student \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   编写GradeMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;io.github.qinry.mapper.GradeMapper\u0026#34;\u0026gt; \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;sql id=\u0026#34;column_list\u0026#34;\u0026gt; id,grade_name \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultType=\u0026#34;Grade\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;column_list\u0026#34; /\u0026gt; from grade \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   update、insert、delete的编写类似，就不重复描述。\n编写测试 测试StudentMapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class StudentMapperTests { private SqlSessionFactory sqlSessionFactory; @BeforeEach void setUp() throws IOException { InputStream inputStream = Resources.getResourceAsStream(\u0026#34;mybatis/mybatis-config.xml\u0026#34;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test void findAll() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { List\u0026lt;Student\u0026gt; students = session.selectList(\u0026#34;io.github.qinry.mapper.StudentMapper.findAll\u0026#34;); students.forEach(System.out::println); } } }   输出：\n1 2 3  Student{id=1, stuName=\u0026#39;王二\u0026#39;, gradeId=1, grade=null} Student{id=2, stuName=\u0026#39;张三\u0026#39;, gradeId=2, grade=null} Student{id=3, stuName=\u0026#39;李四\u0026#39;, gradeId=3, grade=null}   测试GradeMapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class GradeMapperTests { private SqlSessionFactory sqlSessionFactory; @BeforeEach void setUp() throws IOException { InputStream inputStream = Resources.getResourceAsStream(\u0026#34;mybatis/mybatis-config.xml\u0026#34;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test void findAll() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { List\u0026lt;Grade\u0026gt; grades = session.selectList(\u0026#34;io.github.qinry.mapper.GradeMapper.findAll\u0026#34;); grades.forEach(System.out::println); } } }   输出：\n1 2 3  Grade{id=1, gradeName=\u0026#39;一年级\u0026#39;, students=null} Grade{id=2, gradeName=\u0026#39;二年级\u0026#39;, students=null} Grade{id=3, gradeName=\u0026#39;三年级\u0026#39;, students=null}   添加映射器接口 接口名与xml映射文件命名空间一致，方法名与映射文件的与sql相关标签的id一致，比如select标签\n添加接口StudentMapper\n1 2 3  public interface StudentMapper { List\u0026lt;Student\u0026gt; findAll(); }   添加接口与GradeMapper\n1 2 3  public interface GradeMapper { List\u0026lt;Grade\u0026gt; findAll(); }   修改mybatis-config.xml的mappers标签\n1 2 3  \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;io.github.qinry.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt;   修改测试用例\n1 2 3 4 5 6 7  @Test void findAll() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { StudentMapper mapper = session.getMapper(StudentMapper.class); mapper.findAll().forEach(System.out::println); } }   1 2 3 4 5 6 7  @Test void findAll() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { GradeMapper mapper = session.getMapper(GradeMapper.class); mapper.findAll().forEach(System.out::println); } }   得到输出结果与未修改一样，不这种方式（getMapper），使用SqlSession相对简洁。\n编写高级结果集映射 修改StudentMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;resultMap id=\u0026#34;studentResult\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;stu_id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;stuName\u0026#34; column=\u0026#34;stu_name\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeId\u0026#34; column=\u0026#34;grade_id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;grade\u0026#34; column=\u0026#34;grade_id\u0026#34; resultMap=\u0026#34;gradeResult\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026#34;gradeResult\u0026#34; type=\u0026#34;Grade\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;grade_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeName\u0026#34; column=\u0026#34;grade_name\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultMap=\u0026#34;studentResult\u0026#34;\u0026gt; select s.id as stu_id, s.stu_name as stu_name, g.id as grade_id, g.grade_name as grade_name from student s left outer join grade g on s.grade_id = g.id \u0026lt;/select\u0026gt;   测试用例输出：\n1 2 3  Student{id=1, stuName=\u0026#39;王二\u0026#39;, gradeId=1, grade=Grade{id=1, gradeName=\u0026#39;一年级\u0026#39;, students=null}} Student{id=2, stuName=\u0026#39;张三\u0026#39;, gradeId=2, grade=Grade{id=2, gradeName=\u0026#39;二年级\u0026#39;, students=null}} Student{id=3, stuName=\u0026#39;李四\u0026#39;, gradeId=3, grade=Grade{id=3, gradeName=\u0026#39;三年级\u0026#39;, students=null}}   修改GradeMapper.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;resultMap id=\u0026#34;gradeResult\u0026#34; type=\u0026#34;Grade\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;grade_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;gradeName\u0026#34; column=\u0026#34;grade_name\u0026#34; /\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34; resultMap=\u0026#34;studentResult\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;resultMap id=\u0026#34;studentResult\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;id\u0026#34; column=\u0026#34;stu_id\u0026#34; /\u0026gt; \u0026lt;result property=\u0026#34;stuName\u0026#34; column=\u0026#34;stu_name\u0026#34; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;findAll\u0026#34; resultMap=\u0026#34;gradeResult\u0026#34;\u0026gt; select g.id as grade_id, g.grade_name as grade_name, s.id as stu_id, s.stu_name as stu_name from grade g left outer join student s on g.id = s.grade_id \u0026lt;/select\u0026gt;   测试用例输出：\n1 2 3  Grade{id=1, gradeName=\u0026#39;一年级\u0026#39;, students=[Student{id=1, stuName=\u0026#39;王二\u0026#39;, gradeId=null, grade=null}]} Grade{id=2, gradeName=\u0026#39;二年级\u0026#39;, students=[Student{id=2, stuName=\u0026#39;张三\u0026#39;, gradeId=null, grade=null}]} Grade{id=3, gradeName=\u0026#39;三年级\u0026#39;, students=[Student{id=3, stuName=\u0026#39;李四\u0026#39;, gradeId=null, grade=null}]}   高级结果集映射，使用级联查询（联表查询），实体必须实现Serializable接口。\r 了解更多  更多的高级结果集映射信息 mybatis3-动态sql mybatis3官方文档  ","description":"Mybatis 快速入门","id":5,"section":"posts","tags":["mybatis","gradle","orm"],"title":"Mybatis 快速入门","uri":"https://qinry.github.io/posts/2021/11/mybatis-crash/"},{"content":"Files和Paths快速使用 演示用的文本：\n1 2 3  Hi, I\u0026#39;m qinry! I am learning java8. Files and Paths are new untilty classes for input/output.   创建demo.txt的符号链接demo.link\n1  ln -s demo.txt demo.link   以上命令在MacOS运行，Windows可通过创建快捷方式，效果类似。\n查看三种路径的常用信息：这里所遇到方法，都能见名知意，就不解释了，获取路径的惯用静态方法Paths.get(\u0026quot;demo.txt\u0026quot;)。\n重点是toRealPath()和toAbsolutePath()的不同。\n相对路径\r绝对路径\r真实路径\r\r1 2 3 4 5 6 7 8 9  Path path = Paths.get(\u0026#34;demo.txt\u0026#34;); System.out.println(\u0026#34;toString: \u0026#34; + path); System.out.println(\u0026#34;Exists: \u0026#34; + Files.exists(path)); System.out.println(\u0026#34;RegularFile: \u0026#34; + Files.isRegularFile(path)); System.out.println(\u0026#34;Directory: \u0026#34; + Files.isDirectory(path)); System.out.println(\u0026#34;Absolute: \u0026#34; + path.isAbsolute()); System.out.println(\u0026#34;FileName: \u0026#34; + path.getFileName()); System.out.println(\u0026#34;Parent: \u0026#34; + path.getParent()); // [1] 父路径 System.out.println(\u0026#34;Root: \u0026#34; + path.getRoot()); // [2 ]根路径   \r\r1 2 3 4 5 6 7 8 9 10  Path path = Paths.get(\u0026#34;demo.txt\u0026#34;); Path absPath = path.toAbsolutePath(); // [1] System.out.println(\u0026#34;toString: \u0026#34; + absPath); System.out.println(\u0026#34;Exists: \u0026#34; + Files.exists(absPath)); System.out.println(\u0026#34;RegularFile: \u0026#34; + Files.isRegularFile(absPath)); System.out.println(\u0026#34;Directory: \u0026#34; + Files.isDirectory(absPath)); System.out.println(\u0026#34;Absolute: \u0026#34; + absPath.isAbsolute()); System.out.println(\u0026#34;FileName: \u0026#34; + absPath.getFileName()); System.out.println(\u0026#34;Parent: \u0026#34; + absPath.getParent()); System.out.println(\u0026#34;Root: \u0026#34; + absPath.getRoot());   \r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Path path = Paths.get(\u0026#34;demo.link\u0026#34;); // [1] Path realPath = null; try { realPath = path.toRealPath(); // [2]  System.out.println(\u0026#34;toString: \u0026#34; + realPath); System.out.println(\u0026#34;Exists: \u0026#34; + Files.exists(realPath)); System.out.println(\u0026#34;RegularFile: \u0026#34; + Files.isRegularFile(realPath)); System.out.println(\u0026#34;Directory: \u0026#34; + Files.isDirectory(realPath)); System.out.println(\u0026#34;Absolute: \u0026#34; + realPath.isAbsolute()); System.out.println(\u0026#34;FileName: \u0026#34; + realPath.getFileName()); System.out.println(\u0026#34;Parent: \u0026#34; + realPath.getParent()); System.out.println(\u0026#34;Root: \u0026#34; + realPath.getRoot()); } catch(IOException e) { System.out.println(e); }   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"3db12d2cd9e408b1\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r 输出：\n相对路径\r绝对路径\r真实路径\r\r1 2 3 4 5 6 7 8  toString: demo.txt Exists: true RegularFile: true Directory: false Absolute: false FileName: demo.txt Parent: null Root: null   \r\r1 2 3 4 5 6 7 8  toString: /Users/qinry/demo.txt Exists: true RegularFile: true Directory: false Absolute: true FileName: demo.txt Parent: /Users/qinry Root: /   \r\r1 2 3 4 5 6 7 8  toString: /Users/qinry/demo.txt Exists: true RegularFile: true Directory: false Absolute: true FileName: demo.txt Parent: /Users/qinry Root: /   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"e7abcd0eb47fdf10\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r\n由于是在MacOS运行，文件系统的根路径是“/”\n所指的三种路径：\n 相对路径：指相对于当前工作目录的路径，这里工作目录是/Users/qinry，所以文件的相对路径为demo.txt 绝对路径：指相对于根路径的路径，等于工作目录路径加上相对路径，即/Users/qinry/demo.txt 真实路径：符号链接所指向文件真正路径，如果不是符号链接，就是本身的绝对路径，demo.link是demo.txt的软链接，它的真实路径是/Users/qinry/demo.txt  toRealPath()方法可以解析符号链接，如果符号链接对应的真实文件不存在时，则会抛出异常。\r 查看路径的各部分片段 getNameCount()获取路径片段的数量。getName(int)获取指定的片段\n1 2 3 4 5  Path p = Paths.get(\u0026#34;demo.txt\u0026#34;).toAbsolutePath(); System.out.println(p); for (int i = 0; i \u0026lt; p.getNameCount(); i++) { System.out.println(p.getName(i)); }   输出：\n1 2 3 4  /Users/qinry/demo.txt Users qinry demo.txt   路径分析 其实就是查看文件属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { System.out.println(System.getProperty(\u0026#34;os.name\u0026#34;)); Path p = Paths.get(\u0026#34;demo.txt\u0026#34;).toAbsolutePath(); System.out.println(\u0026#34;存在：\u0026#34;+Files.exists(p)); System.out.println(\u0026#34;目录：\u0026#34;+Files.isDirectory(p)); System.out.println(\u0026#34;可执行：\u0026#34;+Files.isExecutable(p)); System.out.println(\u0026#34;可读：\u0026#34;+Files.isReadable(p)); System.out.println(\u0026#34;普通文件：\u0026#34;+Files.isRegularFile(p)); System.out.println(\u0026#34;可写\u0026#34;+Files.isWritable(p)); System.out.println(\u0026#34;不存在\u0026#34;+Files.notExists(p)); System.out.println(\u0026#34;隐藏：\u0026#34;+Files.isHidden(p)); System.out.println(\u0026#34;大小：\u0026#34;+Files.size(p)); System.out.println(\u0026#34;文件存储：\u0026#34;+Files.getFileStore(p)); System.out.println(\u0026#34;上次修改时间：\u0026#34;+Files.getLastModifiedTime(p)); System.out.println(\u0026#34;拥有者：\u0026#34;+Files.getOwner(p)); System.out.println(\u0026#34;内容类型：\u0026#34;+Files.probeContentType(p)); System.out.println(\u0026#34;符号链接：\u0026#34;+Files.isSymbolicLink(p)); if (Files.isSymbolicLink(p)) { System.out.println(\u0026#34;符号链接：\u0026#34;+Files.readSymbolicLink(p)); // 读取链接的目标  } if (FileSystems.getDefault().supportedFileAttributeViews().contains(\u0026#34;posix\u0026#34;)) { System.out.println(\u0026#34;Posix文件权限：\u0026#34;+Files.getPosixFilePermissions(p)); } } catch(IOException e) { System.out.println(e); }   输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Mac OS X 存在：true 目录：false 可执行：false 可读：true 普通文件：true 可写true 不存在false 隐藏：false 大小：94 文件存储：/System/Volumes/Data (/dev/disk2s1) 上次修改时间：2021-11-04T13:50:51.559655Z 拥有者：qinry 内容类型：text/plain 符号链接：false Posix文件权限：[OWNER_READ, GROUP_READ, OTHERS_READ, OWNER_WRITE]   路径的增删修改 resolve()添加尾路径，normalize()可以去除冗余的路径片段。\n1 2 3  Path base = Paths.get(\u0026#34;.\u0026#34;).toAbsolutePath().normalize(); Path p = base.resolve(\u0026#34;files\u0026#34;).resolve(\u0026#34;demo.txt\u0026#34;); System.out.println(p);   输出：\n1  /Users/qinry/files/demo.txt   \u0026quot;.\u0026quot;表示当前的工作目录，\u0026quot;..\u0026quot;表示当前的工作目录的父路目录\nrelativize(()去除基部路径\n1 2 3  Path base = Paths.get(\u0026#34;files\u0026#34;); Path p = Paths.get(\u0026#34;files/demo.txt\u0026#34;); System.out.println(base.relativize(p));   输出：\n1  demo.txt   目录和文件增删 删除目录和文件 假如工作目录下有目录test，删除目录有两个方法：delete(path)和deleteIfExists(path)。第一个如果路径不存在这个目录，则抛出异常；第二个只有存在该路径才删除\ndelete\rdeleteIfExists\r\r1 2 3 4 5 6  Path dir = Paths.get(\u0026#34;test\u0026#34;); try { Files.delete(dir); } catch(IOException) { e.printStackTrace(); }   \r\r1 2 3 4 5 6  Path dir = Paths.get(\u0026#34;test\u0026#34;); try { Files.deleteIfExists(dir); } catch(IOException) { e.printStackTrace(); }   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"e6efcd508af2706a\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r 文件删除与目录同理。把路径该为文件的路径即可\n比如：\n1 2 3 4 5 6  Path file = Paths.get(\u0026#34;readme.txt\u0026#34;); try { Files.deleteIfExists(file); } catch(IOException) { e.printStackTrack(); }   如果目录的内容不为空，则删除目录是会抛出异常的。意味着Java标准库没有删除目录树的方法，需要自己实现。见下！\r 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void rmdir(Path dir) throws IOException { Files.walkFileTree(dir, new SimpleFileVisitor\u0026lt;Path\u0026gt;(){ @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { Files.delete(dir); return FileVisitResult.CONTINUE; } }); }   Files.walkFileTree访问目录下的文件树，即遍历该目录下所有的文件及其子目录。在遍历过程中，提供一个访问者的机制对访问的文件和目录执行操作。\nFileVistor有四个抽象方法：\n preVisitDirectory()：在访问目录项之前运行 visitFile()：访问文件时运行 visitFileFailed()：访问文件失败时运行 postVisitDirectory：访问目录项后运行  创建目录和文件 要在工作目录下创建目录：\n1 2 3 4 5 6 7  Path dir = Paths.get(\u0026#34;test\u0026#34;,\u0026#34;a\u0026#34;); try { //Files.createDirectory(dir);  Files.createDirectories(dir); } catch(Exception e) { System.out.println(\u0026#34;不能正常工作\u0026#34;); }   createDirectory(dir)不能创建多级目录，只可单级目录，故会抛出异常；createDirectories(dir)可以创建完整的目录。\n创建文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13  Path dir = Paths.get(\u0026#34;test\u0026#34;); Path file = dir.resolve(\u0026#34;hello.txt\u0026#34;); try { if (Files.exists(dir)) { Files.delete(dir); } if (!Files.exists(dir)) { Files.createDirectory(dir); } Files.createFile(file); } catch(IOException e) { e.printStackTrace(); }   创建临时的文件和目录 1 2 3 4 5 6 7 8 9 10 11 12 13  Path test = Paths.get(\u0026#34;test\u0026#34;); try { if (Files.exists(test)) { Files.delete(test); } if (!Files.exists(test)) { Files.createDirectory(test); } Path tempDir = Files.createTempDirectory(test, \u0026#34;DIR_\u0026#34;); Files.createTempFile(tempDir, \u0026#34;pre\u0026#34;, \u0026#34;.non\u0026#34;); } catch(IOException e) { e.printStackTrace(); }   创建前缀为DIR_的临时目录，创建前缀为pre，后缀为.non的临时文件。\n文件系统 查看文件系统相关信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  System.out.println(System.getProperty(\u0026#34;os.name\u0026#34;)); FileSystem fsys = FileSystems.getDefault(); for (FileStore fileStore : fsys.getFileStores()) { System.out.println(\u0026#34;File Store:\u0026#34;+fileStore); } for (Path rd : fsys.getRootDirectories()) { System.out.println(\u0026#34;Root Directory:\u0026#34;+rd); } System.out.println(\u0026#34;Separator:\u0026#34;+fsys.getSeparator()); System.out.println(\u0026#34;UserPrincipalLookupService:\u0026#34;+fsys.getUserPrincipalLookupService()); System.out.println(\u0026#34;isOpen:\u0026#34;+fsys.isOpen()); System.out.println(\u0026#34;isReadOnly:\u0026#34;+fsys.isReadOnly()); System.out.println(\u0026#34;FileSystemProvider:\u0026#34;+fsys.provider()); System.out.println(\u0026#34;File Attribute Views:\u0026#34;+fsys.supportedFileAttributeViews());   输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  Mac OS X File Store:/ (/dev/disk2s5) File Store:/dev (devfs) File Store:/System/Volumes/Data (/dev/disk2s1) File Store:/private/var/vm (/dev/disk2s4) File Store:/System/Volumes/Data/home (map auto_home) File Store:/Volumes/share (/dev/disk0s1) Root Directory:/ Separator:/ UserPrincipalLookupService:sun.nio.fs.UnixFileSystem$LookupService$1@7852e922 isOpen:true isReadOnly:false FileSystemProvider:sun.nio.fs.MacOSXFileSystemProvider@4e25154f File Attribute Views:[owner, basic, posix, unix]   文件查找 Path dir = Paths.get(\u0026quot;test\u0026quot;);\rPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\u0026quot;glob:**/*.{tmp,txt}\u0026quot;);\rtry {\rFiles.walk(dir)\r.filter(matcher::matches)\r.forEach(System.out::println);\r} catch (IOException e) {\re.printStackTrace();\r}\rFiles.walk(dir)获取目录树的全部内容的流。通过在 FileSystem 对象上调用 getPathMatcher() 获得一个 PathMatcher，然后传入您感兴趣的模式。这里使用glob，简化正则表达式的一种匹配模式。**表示“当前目录及所有子目录”不包含.和..开头的，*代表除了分割符的任意字符。{}表示一系列的可能性。这里表示可能使 tmp 结尾 或 txt\n文件读写 读文件 Files.readAllLines(path)得到所有行组成的字符串列表。可以创建为流进行操作：\n1 2 3 4 5 6  // cheese.txt Not much of a cheese shop really, is it? Finest in the district, sir. And what leads you to that conclusion? Well, it\u0026#39;s so clean. It\u0026#39;s certainly uncontaminated by cheese.   1 2 3 4 5 6 7 8 9  try { Files.readAllLines( Paths.get(\u0026#34;cheese.txt\u0026#34;)) .stream() .filter(s -\u0026gt; !s.startsWith(\u0026#34;//\u0026#34;)) .forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); }   输出：\n1 2 3 4 5  Not much of a cheese shop really, is it? Finest in the district, sir. And what leads you to that conclusion? Well, it\u0026#39;s so clean. It\u0026#39;s certainly uncontaminated by cheese.   写文件 Files.write(path, bytes)或Files.write(path, lines)。写完文件可写入byte数组或String列表的内容。\nbytes\rlines\r\r1 2 3 4 5 6 7 8 9  Path path = Paths.get(\u0026#34;bytes.dat\u0026#34;); byte[] bytes = new byte[1024]; new Random(47).nextBytes(bytes); try { Files.write(path, bytes); System.out.println(\u0026#34;bytes.dat: \u0026#34; + Files.size(path)); } catch (IOException e) { e.printStackTrace(); }   \r\r1 2 3 4 5 6 7  Path path = Paths.get(\u0026#34;cheese.txt\u0026#34;); try { List\u0026lt;String\u0026gt; lines = Files.lines(path).filter(s -\u0026gt; !s.startsWith(\u0026#34;//\u0026#34;)).collect(Collectors.toList()); Files.write(Paths.get(\u0026#34;hello.txt\u0026#34;), lines); } catch (IOException e) { e.printStackTrace(); }   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"7b95dfe55d96243d\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r\n路径监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  public class TreeWatcher { static void watchDir(Path dir) { try { WatchService watcher = FileSystems.getDefault().newWatchService(); dir.register(watcher, ENTRY_DELETE); Executors.newSingleThreadExecutor().submit(() -\u0026gt; { try { WatchKey key = watcher.take(); for(WatchEvent evt : key.pollEvents()) { System.out.println( \u0026#34;evt.context(): \u0026#34; + evt.context() + \u0026#34;\\nevt.count(): \u0026#34; + evt.count() + \u0026#34;\\nevt.kind(): \u0026#34; + evt.kind()); System.exit(0); } } catch(InterruptedException e) { return; } }); } catch(IOException e) { throw new RuntimeException(e); } } public static void main(String[] args) { try { Files.walk(Paths.get(\u0026#34;test\u0026#34;)) .filter(Files::isDirectory) .forEach(TreeWatcher::watchDir); Files.walk(Paths.get(\u0026#34;test\u0026#34;)) .filter(f -\u0026gt; f.toString() .endsWith(\u0026#34;.txt\u0026#34;)) .forEach(f -\u0026gt; { try { System.out.println(\u0026#34;deleting \u0026#34; + f); Files.delete(f); } catch(IOException e) { throw new RuntimeException(e); } }); } catch (IOException e) { e.printStackTrace(); } } }   在 watchDir() 方法中给 WatchSevice 提供参数 ENTRY_DELETE，并启动一个独立的线程来监视该WatchService。这里是监听删除事件。还有其他的：ENTRY_CREATE，ENTRY_MODIFY(其中创建和删除不属于修改)。\n","description":"快速开始 Java8 文件IO","id":6,"section":"posts","tags":["io"],"title":"快速开始 Java8 文件IO","uri":"https://qinry.github.io/posts/2021/11/quickstart-java8-io/"},{"content":"流是什么 流（Streams）是与任何特定存储机制无关的元素序列——实际上，我们说流是 “没有存储 “的。\n 集合优化了对象的存储，而流（Streams）则是关于一组组对象的处理。\n 取代了在集合中迭代元素的做法，使用流即可从管道中提取元素并对其操作。这些管道通常被串联在一起形成一整套的管线，来对流进行操作,它使得程序更加短小并且更易理解。\n快速开始的入门示例 1 2 3 4 5 6 7 8 9 10  public class Randoms { public static void main(String[] args) { new Random(47) .ints(5, 20) // 流的创建  .distinct() // 3个中间操作  .limit(7) .sorted() .forEach(System.out::println); // 终结操作  } }   5到20的随机数不重复，限制7个后排序，再打印输出。\n 这里只描述了流的行为，并未明确指明具体的操作。这是声明式编程风格，而非命令式编程风格，语义更加清晰，语法更加简洁。\n  流有一个重要特征，就是懒加载，只有在必要时进行计算，又称惰性求值。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。\n 将上方的声明式编程风格的代码用命令式编程风格重写如下：\n1 2 3 4 5 6 7 8 9 10 11 12  public class Randoms { public static void main(String[] args) { Random rand = new Random(47); SortedSet\u0026lt;Integer\u0026gt; rints = new TreeSet\u0026lt;\u0026gt;(); // distinct sorted  while(rints.size() \u0026lt; 7) { // limit  int r = rand.nextInt(20); // \u0026lt; 20  if(r \u0026lt; 5) continue; // \u0026gt;= 5  rints.add(r); } System.out.println(rints); } }   流式编程有三个部分：流创建、中间操作、终端操作。中间操作可以更改流，终端操作会等到某种结果。\n流的创建  流的简单工厂（of/stream） 随机数流 int类型的范围（range/rangeClosed） 生成（generate） 迭代（iterate） 流的建造者（builder） 数组转换流 （stream） 正则表达式（splitAsStream）  流的简单工厂 of方法 Stream.of有两个重载方法，一个是单参数的，另一个是可变参数，参数类型是泛型。\n1 2  Stream.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); Stream.of(1, 2, 3, 4,);   泛型的重载方法，实际委托给Arrays.stream方法来创建流\n1 2 3 4 5  @SafeVarargs @SuppressWarnings(\u0026#34;varargs\u0026#34;) // Creating a stream from an array is safe public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; of(T... values) { return Arrays.stream(values); }   stream方法 Collection接口默认实现了stream方法来创建，这个方法实际工作最终委托给StreamSupport这个底层工具类来完成。Arrays.stream方法与Stream.of单参数版本也是如此。\n1 2 3  default Stream\u0026lt;E\u0026gt; stream() { return StreamSupport.stream(spliterator(), false); }   Java的集合框架中实现Collection及其子接口的类都可以使用stream方法创建流\n1 2 3 4 5 6 7 8 9 10  List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;b\u0026#34;); list.add(\u0026#34;c\u0026#34;); list.stream(); Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;a\u0026#34;, \u0026#34;apple\u0026#34;); map.put(\u0026#34;b\u0026#34;, \u0026#34;banana\u0026#34;); map.put(\u0026#34;c\u0026#34;, \u0026#34;cookie\u0026#34;); map.entrySet().stream();   随机数流 ints、longs和doubles得到是原始数据类型的流，boxed将原始数据类型转化为包装类型流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class RandomGenerators { public static \u0026lt;T\u0026gt; void show(Stream\u0026lt;T\u0026gt; stream) { stream .limit(4) .forEach(System.out::println); System.out.println(\u0026#34;++++++++\u0026#34;); } public static void main(String[] args) { Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限：  show(rand.ints(10, 20).boxed()); show(rand.longs(50, 100).boxed()); show(rand.doubles(20, 30).boxed()); // 控制流大小：  show(rand.ints(2).boxed()); show(rand.longs(2).boxed()); show(rand.doubles(2).boxed()); // 控制流的大小和界限  show(rand.ints(3, 3, 9).boxed()); show(rand.longs(3, 12, 22).boxed()); show(rand.doubles(3, 11.5, 12.3).boxed()); } }   输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  -1172028779 1717241110 -2014573909 229403722 ++++++++ 2955289354441303771 3476817843704654257 -8917117694134521474 4941259272818818752 ++++++++ 0.2613610344283964 0.0508673570556899 0.8037155449603999 0.7620665811558285 ++++++++ 16 10 11 12 ++++++++ 65 99 54 58 ++++++++ 29.86777681078574 24.83968447804611 20.09247112332014 24.046793846338723 ++++++++ 1169976606 1947946283 ++++++++ 2970202997824602425 -2325326920272830366 ++++++++ 0.7024254510631527 0.6648552384607359 ++++++++ 6 7 7 ++++++++ 17 12 20 ++++++++ 12.27872414236691 11.732085449736195 12.196509449817267 ++++++++   流的生成 Stream.generate方法的方法签名，接受一个Supplier类型。\n1 2 3 4 5  public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; generate(Supplier\u0026lt;T\u0026gt; s) { Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef\u0026lt;\u0026gt;(Long.MAX_VALUE, s), false); }   可以实现Supplier接口，传入generate方法，也可以使用lambda表达式以及方法引用形式\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Generator implements Supplier\u0026lt;String\u0026gt; { Random rand = new Random(47); char[] letters = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.toCharArray(); public String get() { return \u0026#34;\u0026#34; + letters[rand.nextInt(letters.length)]; } public static void main(String[] args) { String word = Stream.generate(new Generator()) .limit(30) .collect(Collectors.joining()); System.out.println(word); } }   输出：\n1  YNZBRNYGCFOWZNTCQRGSEGZMMJMROE   流的迭代 Stream.iterate的方法签名，接受一个泛型种子（初始值），还有一个UnaryOperator类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; iterate(final T seed, final UnaryOperator\u0026lt;T\u0026gt; f) { Objects.requireNonNull(f); final Iterator\u0026lt;T\u0026gt; iterator = new Iterator\u0026lt;T\u0026gt;() { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T t = (T) Streams.NONE; @Override public boolean hasNext() { return true; } @Override public T next() { return t = (t == Streams.NONE) ? seed : f.apply(t); } }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); }   与generate类似，可以实现接口，或者使用函数式编程来传入第二参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Fibonacci { int x = 1; Stream\u0026lt;Integer\u0026gt; numbers() { return Stream.iterate(0, i -\u0026gt; { int result = x + i; x = i; return result; }); } public static void main(String[] args) { new Fibonacci().numbers() .skip(20) // 过滤前 20 个  .limit(10) // 然后取 10 个  .forEach(System.out::println); } }   输出：\n1 2 3 4 5 6 7 8 9 10  6765 10946 17711 28657 46368 75025 121393 196418 317811 514229   流的建造者 Stream.builder方法的返回值是一个Builder类型，实际上是Streams.StreamBuilderImpl对象\n1 2 3  public static\u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; builder() { return new Streams.StreamBuilderImpl\u0026lt;\u0026gt;(); }   Streams.StreamBuilderImpl有两个重要的方法一个是add，还有一个是build。add用来链式添加流中的元素，build则是完成构建流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  static final class StreamBuilderImpl\u0026lt;T\u0026gt; extends AbstractStreamBuilderImpl\u0026lt;T, Spliterator\u0026lt;T\u0026gt;\u0026gt; implements Stream.Builder\u0026lt;T\u0026gt; { public Stream.Builder\u0026lt;T\u0026gt; add(T t) { accept(t); return this; } @Override public Stream\u0026lt;T\u0026gt; build() { int c = count; if (c \u0026gt;= 0) { // Switch count to negative value signalling the builder is built  count = -count - 1; // Use this spliterator if 0 or 1 elements, otherwise use  // the spliterator of the spined buffer  return (c \u0026lt; 2) ? StreamSupport.stream(this, false) : StreamSupport.stream(buffer.spliterator(), false); } throw new IllegalStateException(); } }   add委托给accpet方法将元素添加到buffer中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // The first element in the stream // valid if count == 1 T first; // The first and subsequent elements in the stream // non-null if count == 2 SpinedBuffer\u0026lt;T\u0026gt; buffer; @Override public void accept(T t) { if (count == 0) { first = t; count++; } else if (count \u0026gt; 0) { if (buffer == null) { buffer = new SpinedBuffer\u0026lt;\u0026gt;(); buffer.accept(first); count++; } buffer.accept(t); } else { throw new IllegalStateException(); } }   一旦调用build后，count会变成负数，再调用add/accept方法，就会抛出IllegalStateException。所以，Stream.Builder调用builder()后不可再添加元素。\n1 2  Stream.Builder\u0026lt;String\u0026gt; builder = Stream.builder(); Stream\u0026lt;String\u0026gt; stream = builder.add(\u0026#34;I\u0026#34;).add(\u0026#34;Love\u0026#34;).add(\u0026#34;Java8\u0026#34;).build();   数组转换成流 1 2 3 4 5 6  String[] stringArray = new String[4]; stringArray[0] = \u0026#34;I\u0026#34;; stringArray[1] = \u0026#34;Love\u0026#34;; stringArray[2] = \u0026#34;Java\u0026#34;; stringArray[3] = \u0026#34;!\u0026#34;; Arrays.stream(stringArray).forEach(System.out::println);   输出：\n1 2 3 4  I Love Java !   stream()的调用有两个额外的参数。第一个参数告诉 stream() 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止（不包含）。\n1 2 3 4 5 6 7 8 9 10 11 12  Arrays.stream(new double[] { 3.14159, 2.718, 1.618 }) .forEach(n -\u0026gt; System.out.format(\u0026#34;%f \u0026#34;, n)); System.out.println(); Arrays.stream(new int[] { 1, 3, 5 }) .forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)); System.out.println(); Arrays.stream(new long[] { 11, 22, 44, 66 }) .forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)); System.out.println(); // 选择一个子域: Arrays.stream(new int[] { 1, 3, 5, 7, 15, 28, 37 }, 3, 6) .forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n));   输出：\n1 2 3 4  3.141590 2.718000 1.618000 1 3 5 11 22 44 66 7 15 28   正则表达式 Java 8 在 java.util.regex.Pattern 中增加了一个新的方法 splitAsStream()。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 CharSequence，因此不能将流作为 splitAsStream() 的参数。\ncheese.txt文件内容：\n1 2 3 4 5 6  // cheese.txt Not much of a cheese shop really, is it? Finest in the district, sir. And what leads you to that conclusion? Well, it\u0026#39;s so clean. It\u0026#39;s certainly uncontaminated by cheese.   读取cheese.txt文件的每一行，然后跳过第一行，每一行用空格连接成一个字符串。接着使用正则表达式将字符串转化为单词流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class FileToWordsRegexp { private String all; public FileToWordsRegexp(String filePath) throws Exception { all = Files.lines(Paths.get(filePath)) .skip(1) // First (comment) line  .collect(Collectors.joining(\u0026#34; \u0026#34;)); } public Stream\u0026lt;String\u0026gt; stream() { return Pattern .compile(\u0026#34;[ .,?]+\u0026#34;).splitAsStream(all); } public static void main(String[] args) throws Exception { FileToWordsRegexp fw = new FileToWordsRegexp(\u0026#34;Cheese.txt\u0026#34;); fw.stream() .limit(7) .map(w -\u0026gt; w + \u0026#34; \u0026#34;) .forEach(System.out::print); fw.stream() .skip(7) .limit(2) .map(w -\u0026gt; w + \u0026#34; \u0026#34;) .forEach(System.out::print); } }   输出：\n1  Not much of a cheese shop really is it   中间操作  帮助调试（peek） 给流排序（sorted） 去除元素（distinct/filter） 映射（map/flatmap）  帮助调试 peek()它允许你无修改地查看流中的元素。\n1 2 3 4 5 6 7 8 9  Stream\u0026lt;String\u0026gt; stream = Files.lines(Paths.get(\u0026#34;cheese.txt\u0026#34;)).skip(1).flatMap(line -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(line)); stream.skip(21) .limit(4) .map(w -\u0026gt; w+\u0026#34; \u0026#34;) .peek(System.out::print) .map(String::toUpperCase) .peek(System.out::print) .map(String::toLowerCase) .forEach(System.out::print);   输出：\n1  Well WELL well it IT it s S s so SO so   元素排序 sorted() 预设了一些默认的比较器。但也可以自提供比较器\n1 2 3 4 5 6  Stream\u0026lt;String\u0026gt; stream = Files.lines(Paths.get(\u0026#34;cheese.txt\u0026#34;)).skip(1).flatMap(line -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(line)); stream.skip(10) .limit(10) .sorted(Comparator.reverseOrder()) .map(w -\u0026gt; w + \u0026#34; \u0026#34;) .forEach(System.out::print);   输出：\n1  you what to the that sir leads in district And   去除元素   distinct():distinct() 可用于消除流中的重复元素。\n  filter(Predicate):过滤操作，保留如下元素：若元素传递给过滤函数产生的结果为true 。\n  1 2 3 4 5 6 7 8 9 10  Stream.iterate(2, i -\u0026gt; i + 1) .filter(n -\u0026gt; LongStream.rangeClosed(2, (long)Math.sqrt(n)).noneMatch(i -\u0026gt; n % i == 0)) .limit(10) .forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)); System.out.println(); Stream.iterate(2, i -\u0026gt; i + 1) .filter(n -\u0026gt; LongStream.rangeClosed(2, (long)Math.sqrt(n)).noneMatch(i -\u0026gt; n % i == 0)) .skip(90) .limit(10) .forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n));   输出：\n1 2  2 3 5 7 11 13 17 19 23 29 467 479 487 491 499 503 509 521 523 541   映射   map(Function)：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。\n  mapToInt(ToIntFunction)：操作同上，但结果是 IntStream。\n  mapToLong(ToLongFunction)：操作同上，但结果是 LongStream。\n  mapToDouble(ToDoubleFunction)：操作同上，但结果是 DoubleStream。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  System.out.println(\u0026#34;add brackets\u0026#34;); Arrays.stream(new String[]{\u0026#34;12\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;45\u0026#34;}) .map( s -\u0026gt; \u0026#34;[\u0026#34; + s + \u0026#34;]\u0026#34;) .forEach(System.out::println); System.out.println(\u0026#34;Increment\u0026#34;); Arrays.stream(new String[]{\u0026#34;12\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;45\u0026#34;}) .map( s -\u0026gt; { try { return Integer.parseInt(s) + 1 + \u0026#34;\u0026#34;; } catch(NumberFormatException e) { return s; } }) .forEach(System.out::println); System.out.println(\u0026#34;Replace\u0026#34;); Arrays.stream(new String[]{\u0026#34;12\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;45\u0026#34;}) .map( s -\u0026gt; s.replace(\u0026#34;2\u0026#34;, \u0026#34;9\u0026#34;)) .forEach(System.out::println); System.out.println(\u0026#34;Take last digit\u0026#34;); Arrays.stream(new String[]{\u0026#34;12\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;45\u0026#34;}) .map( s -\u0026gt; s.length() \u0026gt; 0 ? s.charAt(s.length() - 1) + \u0026#34;\u0026#34; : s) .forEach(System.out::println);   输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  add brackets [12] [] [23] [45] Increment 13 24 46 Replace 19 93 45 Take last digit 2 3 5   如果Function的返回值类型是Stream类型时使用。flatMap() 做了两件事：将产生流的函数应用在每个元素上（与 map() 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。\n  flatMap(Function)：当 Function 产生流时使用。\n  flatMapToInt(Function)：当 Function 产生 IntStream 时使用。\n  flatMapToLong(Function)：当 Function 产生 LongStream 时使用。\n  flatMapToDouble(Function)：当 Function 产生 DoubleStream 时使用。\n  1 2 3  Stream.of(1, 2, 3) .flatMap(i -\u0026gt; Stream.of(\u0026#34;Gonzo\u0026#34;, \u0026#34;Fozzie\u0026#34;, \u0026#34;Beaker\u0026#34;)) .forEach(System.out::println);   输出：\n1 2 3 4 5 6 7 8 9  Gonzo Fozzie Beaker Gonzo Fozzie Beaker Gonzo Fozzie Beaker   Optional类 以下几种流的终端操作的方法返回值类型为Optional对象，所以要了解Optional对象的使用。\n findFirst() 返回一个包含第一个元素的 Optional 对象，如果流为空则返回 Optional.empty findAny() 返回包含任意元素的 Optional 对象，如果流为空则返回 Optional.empty max()和mix() 返回一个包含最大值或者最小值的 Optional 对象，如果流为空则返回 Optional.empty reduce(BinaryOperator) 返回包含调用BinaryOperator的apply方法结果的Optional对象。 对于数字流 IntStream、LongStream 和 DoubleStream，average() 会将结果包装在 Optional 以防止流为空。  注意，空流是通过 Stream.empty() 创建的。\n1 2 3 4 5 6 7 8 9 10 11 12  System.out.println(Stream.\u0026lt;String\u0026gt;empty() .findFirst()); System.out.println(Stream.\u0026lt;String\u0026gt;empty() .findAny()); System.out.println(Stream.\u0026lt;String\u0026gt;empty() .max(String.CASE_INSENSITIVE_ORDER)); System.out.println(Stream.\u0026lt;String\u0026gt;empty() .min(String.CASE_INSENSITIVE_ORDER)); System.out.println(Stream.\u0026lt;String\u0026gt;empty() .reduce((s1, s2) -\u0026gt; s1 + s2)); System.out.println(IntStream.empty() .average());   输出：\n1 2 3 4 5 6  Optional.empty Optional.empty Optional.empty Optional.empty Optional.empty OptionalDouble.empty   Optional基本用法 1 2 3 4 5 6  // opt是Optional对象 if (opt.isPresent()) { // 如果不为空进行的行为 } else { // 如果为空进行的行为 }   有许多便利函数可以解包 Optional ，这简化了上述“对所包含的对象的检查和执行操作”的过程：\n ifPresent(Consumer)：当值存在时调用 Consumer，否则什么也不做。 orElse(otherObject)：如果值存在则直接返回，否则生成 otherObject。 orElseGet(Supplier)：如果值存在则直接返回，否则使用 Supplier 函数生成一个可替代对象。 orElseThrow(Supplier)：如果值存在直接返回，否则使用 Supplier 函数生成一个异常。  Optional\u0026lt;String\u0026gt; opt = Optional.ofNullable(\u0026quot;Hello Optional\u0026quot;);\ropt.ifPresent(System.out::println);\ropt = Optional.ofNullable(null);\rSystem.out.println(opt.orElse(\u0026quot;Hello\u0026quot;));\rSystem.out.println(opt.orElseGet(() -\u0026gt; \u0026quot;Hello\u0026quot;));\rtry {\ropt.orElseThrow(() -\u0026gt; new Exception(\u0026quot;Supplied\u0026quot;));\r} catch(Exception e) {\rSystem.out.println(\u0026quot;Caught \u0026quot;+e);\r}\r输出：\n1 2 3 4  Hello Optional Hello Hello Caught java.lang.Exception: Supplied   Optional的创建方法：\n empty() 生成一个空 Optional。 of(value) 将一个非空值包装到 Optional 里。 ofNullable(value) 针对一个可能为空的值，为空时自动生成 Optional.empty，否则将值包装在 Optional 中。  Optional对象操作：\n  filter(Predicate)：对 Optional 中的内容应用Predicate 并将结果返回。如果 Optional 不满足 Predicate ，将 Optional 转化为空 Optional 。如果 Optional 已经为空，则直接返回空Optional 。\n  map(Function)：如果 Optional 不为空，应用 Function 于 Optional 中的内容，并返回结果。否则直接返回 Optional.empty。\n  flatMap(Function)：同 map()，但是提供的映射函数将结果包装在 Optional 对象中，因此 flatMap() 不会在最后进行任何包装。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  String[] elements = { \u0026#34;Foo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bar\u0026#34;, \u0026#34;Baz\u0026#34;, \u0026#34;Bingo\u0026#34; }; System.out.println(\u0026#34;true\u0026#34;); IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().filter(str -\u0026gt; true)); }); System.out.println(\u0026#34;false\u0026#34;); IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().filter(str -\u0026gt; false)); }); System.out.println(\u0026#34;str != \\\u0026#34;\\\u0026#34;\u0026#34;); IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().filter(str -\u0026gt; str != \u0026#34;\u0026#34;)); }); System.out.println(\u0026#34;str.length() == 3\u0026#34;); IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().filter(str -\u0026gt; str.length() == 3)); }); System.out.println(\u0026#34;startsWith(\\\u0026#34;B\\\u0026#34;)\u0026#34;); IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().filter(str -\u0026gt; str.startsWith(\u0026#34;B\u0026#34;))); });   输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  true Optional[Foo] Optional[] Optional[Bar] Optional[Baz] Optional[Bingo] Optional.empty false Optional.empty Optional.empty Optional.empty Optional.empty Optional.empty Optional.empty str != \u0026#34;\u0026#34; Optional[Foo] Optional.empty Optional[Bar] Optional[Baz] Optional[Bingo] Optional.empty str.length() == 3 Optional[Foo] Optional.empty Optional[Bar] Optional[Baz] Optional.empty Optional.empty startsWith(\u0026#34;B\u0026#34;) Optional.empty Optional.empty Optional[Bar] Optional[Baz] Optional[Bingo] Optional.empty   map()\n1 2 3 4 5 6  String[] elements = { \u0026#34;Foo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bar\u0026#34;, \u0026#34;Baz\u0026#34;, \u0026#34;Bingo\u0026#34; }; IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().map(s -\u0026gt; \u0026#34;[\u0026#34;+s+\u0026#34;]\u0026#34;)); });   输出：\n1 2 3 4 5 6  Optional[[Foo]] Optional[[]] Optional[[Bar]] Optional[[Baz]] Optional[[Bingo]] Optional.empty   flatMap()\n1 2 3 4 5 6  String[] elements = { \u0026#34;Foo\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bar\u0026#34;, \u0026#34;Baz\u0026#34;, \u0026#34;Bingo\u0026#34; }; IntStream.rangeClosed(0, elements.length).forEach(i -\u0026gt; { System.out.println(Arrays.stream(elements).skip(i).findFirst().flatMap(s -\u0026gt; Optional.of(\u0026#34;[\u0026#34;+s+\u0026#34;]\u0026#34;))); });   终端操作 终端操作可以等到结果：\n 数组 循环 集合 组合 匹配 查找 信息 数字流信息  数组  toArray()：将流转换成适当类型的数组。 toArray(generator)：在特殊情况下，生成自定义类型的数组。 例如：toArray(Person[]::new)  1 2  int[] arr = new Random(48).ints(0, 1000).limit(10).toArray(); System.out.println(Arrays.toString(arr));   输出：\n1  [368, 316, 831, 244, 877, 911, 522, 100, 987, 794]   循环  forEach(Consumer)常见如 System.out::println 作为 Consumer 函数。 forEachOrdered(Consumer)： 保证 forEach 按照原始流顺序操作。  1 2 3 4 5 6  Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .limit(14).forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)); Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .limit(14).parallel().forEach(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)); Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .limit(14).parallel().forEachOrdered(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n));   输出：\n1 2 3  258 555 693 861 961 429 868 200 522 207 288 128 551 589 551 589 200 522 868 288 128 207 555 693 258 861 961 429 258 555 693 861 961 429 868 200 522 207 288 128 551 589   对于并行流，forEach是无序的，forEachOrder确保有序\n集合  collect(Collector)：使用 Collector 收集流元素到结果集合中。 collect(Supplier, BiConsumer, BiConsumer)：同上，第一个参数 Supplier 创建了一个新的结果集合，第二个参数 BiConsumer 将下一个元素收集到结果集合中，第三个参数 BiConsumer 用于将两个结果集合合并起来。  1 2 3 4 5 6 7 8  Set\u0026lt;String\u0026gt; words = Files.lines(Paths.get(\u0026#34;cheese.txt\u0026#34;)) .flatMap(s -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(s)) .filter(s -\u0026gt; !s.matches(\u0026#34;\\\\d+\u0026#34;)) .map(String::trim) .filter(s -\u0026gt; s.length() \u0026gt; 2) .limit(100) .collect(Collectors.toCollection(TreeSet::new)); System.out.println(words);   输出：\n1 2  [And, Finest, Not, Well, certainly, cheese, clean, conclusion, district, leads, much, really, shop, sir, that, the, txt, uncontaminated, what, you]   组合 reduce(BinaryOperator)：使用 BinaryOperator 来组合所有流中的元素。因为流可能为空，其返回值为 Optional。\nreduce(identity, BinaryOperator)：功能同上，但是使用 identity 作为其组合的初始值。因此如果流为空，identity 就是结果。\n1  IntStream.rangeClosed(0, 100).reduce((s1,s2) -\u0026gt; s1 + s2).ifPresent(System.out::println);   输出：\n1  5050   匹配  allMatch(Predicate) ：如果流的每个元素提供给 Predicate 都返回 true ，结果返回为 true。在第一个 false 时，则停止执行计算。 anyMatch(Predicate)：如果流的任意一个元素提供给 Predicate 返回 true ，结果返回为 true。在第一个 true 是停止执行计算。 noneMatch(Predicate)：如果流的每个元素提供给 Predicate 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。  1 2 3 4 5 6  System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).allMatch(n -\u0026gt; n \u0026lt; 10)); System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).allMatch(n -\u0026gt; n \u0026lt; 4)); System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).anyMatch(n -\u0026gt; n \u0026lt; 2)); System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).anyMatch(n -\u0026gt; n \u0026lt; 0)); System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).noneMatch(n -\u0026gt; n \u0026lt; 5)); System.out.println(IntStream.rangeClosed(1, 9).boxed().peek(n -\u0026gt; System.out.format(\u0026#34;%d \u0026#34;, n)).noneMatch(n -\u0026gt; n \u0026lt; 0));   输出：\n1 2 3 4 5 6  1 2 3 4 5 6 7 8 9 true 1 2 3 4 false 1 true 1 2 3 4 5 6 7 8 9 false 1 false 1 2 3 4 5 6 7 8 9 true   查找  findFirst()：返回第一个流元素的 Optional，如果流为空返回 Optional.empty。 findAny(：返回含有任意流元素的 Optional，如果流为空返回 Optional.empty。  1 2 3 4 5 6 7 8 9 10 11 12  System.out.println( Arrays.stream(new Random(47).ints(0, 1000) .limit(100).toArray()).findFirst().getAsInt()); System.out.println( Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .parallel().findFirst().getAsInt()); System.out.println( Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .findAny().getAsInt()); System.out.println( Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .parallel().findAny().getAsInt());   输出：\n1 2 3 4  258 258 258 402   信息  count()：流中的元素个数。 max(Comparator)：根据所传入的 Comparator 所决定的“最大”元素。 min(Comparator)：根据所传入的 Comparator 所决定的“最小”元素。  1 2 3 4 5 6 7 8 9 10 11  System.out.println( Files.lines(Paths.get(\u0026#34;Cheese.txt\u0026#34;)).skip(1).flatMap(s -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(s)) .count()); System.out.println( Files.lines(Paths.get(\u0026#34;Cheese.txt\u0026#34;)).skip(1).flatMap(s -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(s)) .min(String.CASE_INSENSITIVE_ORDER) .orElse(\u0026#34;NONE\u0026#34;)); System.out.println( Files.lines(Paths.get(\u0026#34;Cheese.txt\u0026#34;)).skip(1).flatMap(s -\u0026gt; Pattern.compile(\u0026#34;\\\\W+\u0026#34;).splitAsStream(s)) .max(String.CASE_INSENSITIVE_ORDER) .orElse(\u0026#34;NONE\u0026#34;));   输出：\n1 2 3  32 a you   数字流信息  average() ：求取流元素平均值。 max() 和 min()：数值流操作无需 Comparator。 sum()：对所有流元素进行求和。 summaryStatistics()：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。  1 2 3 4 5 6 7 8 9 10  System.out.println(Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .average().getAsDouble()); System.out.println(Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .max().getAsInt()); System.out.println(Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .min().getAsInt()); System.out.println(Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .sum()); System.out.println(Arrays.stream(new Random(47).ints(0, 1000).limit(100).toArray()) .summaryStatistics());   输出：\n1 2 3 4 5  507.94 998 8 50794 IntSummaryStatistics{count=100, sum=50794, min=8, average=507.940000, max=998}   上例操作对于 LongStream 和 DoubleStream 同样适用\n","description":"快速开始Java8流式编程","id":7,"section":"posts","tags":null,"title":"快速开始Java8流式编程","uri":"https://qinry.github.io/posts/2021/11/quickstart-java8-stream-programming/"},{"content":"Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。函数式编程抽象行为，通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。可以把函数当作方法入参传递给方法，以来控制方法的行为，类似设计模式的策略模式。\nLambda表达式 Lambda表达式，从语法上看是一个函数，而非对象。实际上，Java虚拟机会动态生成一个对象，它的方法会包含这个函数描述的行为。\n例如：\ninterface Description {\rString brief();\r}\rinterface Body {\rString detailed(String head);\r}\rinterface Multi {\rString twoArg(String head, Double d);\r}\rBody bod = h -\u0026gt; h + \u0026quot;No Parens\u0026quot;;\rBody bod2 = (h) -\u0026gt; h + \u0026quot;More details\u0026quot;;\rDescription desc = () -\u0026gt; \u0026quot;Short info\u0026quot;;\rMulti mult = (h, n) -\u0026gt; h + n;\rDescription moreLines = () -\u0026gt; {\rSystem.out.println(\u0026quot;moreLines\u0026quot;);\rreturn \u0026quot;from moreLines\u0026quot;;\r};\rlambda表示有三个部分，第一部分就是参数，第二部分是箭头-\u0026gt;，第三部分就是方法体。\n 当只有一个参数时，可以省略圆括号。\n当方法体只有一行时，可以省略花括号和return，还有分号。多行时，编写与方法一致。\n lambda表达式只能赋值给只有一个抽象方法的接口，或只有一个抽象方法的抽象类。\nlambda表达式使用递归\ninterface IntCall {\rint call(int arg);\r}\rpublic class RecursiveFibonacci {\rIntCall fib;\rRecursiveFibonacci() {\rfib = n -\u0026gt; n == 0 ? 0 :\rn == 1 ? 1 :\rfib.call(n - 1) + fib.call(n - 2);\r}\rint fibonacci(int n) { return fib.call(n); }\rpublic static void main(String[] args) {\rRecursiveFibonacci rf = new RecursiveFibonacci();\rfor(int i = 0; i \u0026lt;= 10; i++)\rSystem.out.println(rf.fibonacci(i));\r}\r}\r 递归方法必须是实例变量或静态变量，否则会出现编译时错误。\n 方法引用 方法引用组成：类名/对象名,后面跟 ::，然后跟方法名称。\ninterface Callable { // [1]\rvoid call(String s);\r}\rclass Describe {\rvoid show(String msg) { // [2]\rSystem.out.println(msg);\r}\r}\rpublic class MethodReferences {\rstatic void hello(String name) { // [3]\rSystem.out.println(\u0026quot;Hello, \u0026quot; + name);\r}\rstatic class Description {\rString about;\rDescription(String desc) { about = desc; }\rvoid help(String msg) { // [4]\rSystem.out.println(about + \u0026quot; \u0026quot; + msg);\r}\r}\rstatic class Helper {\rstatic void assist(String msg) { // [5]\rSystem.out.println(msg);\r}\r}\rpublic static void main(String[] args) {\rDescribe d = new Describe();\rCallable c = d::show; // [6] 实例方法引用\rc.call(\u0026quot;call()\u0026quot;); // [7]\rc = MethodReferences::hello; // [8] 外部类的静态方法引用\rc.call(\u0026quot;Bob\u0026quot;);\rc = new Description(\u0026quot;valuable\u0026quot;)::help; // [9] 静态内部类对象的实例方法引用\rc.call(\u0026quot;information\u0026quot;);\rc = Helper::assist; // [10] 静态内部类的静态方法引用\rc.call(\u0026quot;Help!\u0026quot;);\r}\r}\r方法引用的方法签名符合要赋值的接口方法的方法签名，例如Describe的show()与Callable的call()，对已实例化对象的方法的引用，有时称为绑定方法引用。\n未绑定的方法引用是指没有关联对象的普通（非静态）方法。\nclass X {\rString f() { return \u0026quot;X::f()\u0026quot;; }\r}\rinterface MakeString {\rString make();\r}\rinterface TransformX {\rString transform(X x);\r}\rpublic class UnboundMethodReference {\rpublic static void main(String[] args) {\r// MakeString ms = X::f; // [1]\rTransformX sp = X::f;\rX x = new X();\rSystem.out.println(sp.transform(x)); // [2]\rSystem.out.println(x.f()); // 同等效果\r}\r}\r 未绑定的方法引用的类名与要赋值的接口的方法第一参数类型名要一致。在调用此接口时要传入对象，该对象与方法引用进行绑定。这个用法非常妙\n 构造器的方法引用，形如：String::new，String[]::new，构造器有分无参和有参构造器，赋值给参数不同方法的接口，对应使用相应参数数量的构造器。\nclass Dog {\rString name;\rint age = -1; // For \u0026quot;unknown\u0026quot;\rDog() { name = \u0026quot;stray\u0026quot;; }\rDog(String nm) { name = nm; }\rDog(String nm, int yrs) { name = nm; age = yrs; }\r}\rinterface MakeNoArgs {\rDog make();\r}\rinterface Make1Arg {\rDog make(String nm);\r}\rinterface Make2Args {\rDog make(String nm, int age);\r}\rpublic class CtorReference {\rpublic static void main(String[] args) {\rMakeNoArgs mna = Dog::new; // [1]\rMake1Arg m1a = Dog::new; // [2]\rMake2Args m2a = Dog::new; // [3]\rDog dn = mna.make();\rDog d1 = m1a.make(\u0026quot;Comet\u0026quot;);\rDog d2 = m2a.make(\u0026quot;Ralph\u0026quot;, 4);\r}\r}\r函数式接口 由于lambda表达式包含类型推导，要想让编译器能推断出参数和返回值的类型，需要函数式接口。Java有内置的函数接口，不过也可以自定义函数式接口。Java1.8以前的函数式接口有：Runnable、Callable\u0026lt;T\u0026gt;。\nJava1.8引入了java.util.function这个包，里面包含大量的函数式接口，它们只包含单独的方法，即函数式方法。查看这些接口的源代码，会发现它们都使用了一个注解FunctionalInterface，强制使此接口只能有一个抽象方法。\n常用的函数时接口如下：\n   接口 函数式方法     Supplier T get()   Consumer void accept(T t)   Function\u0026lt;T,R\u0026gt; R apply(T t)   Predicate boolean test(T t)   UnaryOperator T apply(T t)   BinaryOperator T apply(T t1, T t2)    还有其他接口，这里就不列举，都是通过以上接口衍生的。例如：LongConsumer，参数类型是Long、LongSupplier，返回值类型是Long、IntToLongFunction，参数是Integer，返回值是Long等等。详情请看源代码或Java API Docs。\n高阶函数 Lambda表达式和方法引用可以充当方法的参数或返回值，也可以理解为消费和产生函数的方法被称为高阶函数。例如：很多的函数式接口都有默认实现的一个方法andThen，这个方法的参数after类型与对应接口类型一致，在接口调用函数式方法后再调用参数的函数式方法。\n例如：Function接口的andThen方法实现\ndefault \u0026lt;V\u0026gt; Function\u0026lt;T, V\u0026gt; andThen(Function\u0026lt;? super R, ? extends V\u0026gt; after) {\rObjects.requireNonNull(after);\rreturn (t) -\u0026gt; {\rreturn after.apply(this.apply(t));\r};\r}\rclass I {\r@Override\rpublic String toString() { return \u0026quot;I\u0026quot;; }\r}\rclass O {\r@Override\rpublic String toString() { return \u0026quot;O\u0026quot;; }\r}\rpublic class TransformFunction {\rstatic Function\u0026lt;I,O\u0026gt; transform(Function\u0026lt;I,O\u0026gt; in) {\rreturn in.andThen(o -\u0026gt; {\rSystem.out.println(o);\rreturn o;\r});\r}\rpublic static void main(String[] args) {\rFunction\u0026lt;I,O\u0026gt; f2 = transform(i -\u0026gt; {\rSystem.out.println(i);\rreturn new O();\r});\rO o = f2.apply(new I());\r}\r}\r输出：\nI\rO\r闭包 可以简单理解为使用函数作用域之外的变量的lambda表达式作为方法返回值的类。有时称为词法定界（lexically scoped ）或变量捕获（variable capture）\n闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。（此处见维基百科——闭包）\n正面教材1：\npublic class Closure1 {\rint i;\rIntSupplier makeFun(int x) {\rreturn () -\u0026gt; x + i++;\r}\r}\rpublic class SharedStorage {\rpublic static void main(String[] args) {\rClosure1 c1 = new Closure1();\rIntSupplier f1 = c1.makeFun(0);\rIntSupplier f2 = c1.makeFun(0);\rIntSupplier f3 = c1.makeFun(0);\rSystem.out.println(f1.getAsInt());\rSystem.out.println(f2.getAsInt());\rSystem.out.println(f3.getAsInt());\r}\r}\r输出：\n0\r1\r2\r最大特征是，Closure1对象调用makeFun方法产生的三个IntSupplier对象都共享了Closure1的属性i的存储。\n正面教材2:\npublic class Closure2 {\rIntSupplier makeFun(int x) {\rint i = 0;\rreturn () -\u0026gt; x + i;\r}\r}\rmakeFun返回的IntSupplier会仍然保持i和x的内存不会消失。一般的方法的局部变量在调用完之后将会消失。\n 这里的变量i是等同final效果，lambda表达式引用的局部变量应该是不可变的，即要使用final修饰，但是Java8引入这个特性，可以省略final，在编译的时候编译器会帮我们自动加上。所以反面教材4，举例语法不正确的情况。\n 正面教材3:\npublic class Closure3 {\rSupplier\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; makeFun() {\rfinal List\u0026lt;Integer\u0026gt; ai = new ArrayList\u0026lt;\u0026gt;();\rai.add(1);\rreturn () -\u0026gt; ai;\r}\rpublic static void main(String[] args) {\rClosure3 c7 = new Closure3();\rList\u0026lt;Integer\u0026gt;\rl1 = c7.makeFun().get(),\rl2 = c7.makeFun().get();\rSystem.out.println(l1);\rSystem.out.println(l2);\rl1.add(42);\rl2.add(96);\rSystem.out.println(l1);\rSystem.out.println(l2);\r}\r}\r输出：\n[1]\r[1]\r[1, 42]\r[1, 96]\r输出的第三和第四行说明，两个makeFun方法返回的Supplier对象持有的ArrayList对象是各自独立的，而非共享。\n反面教材4:\npublic class Closure4 {\rIntSupplier makeFun(int x) {\rint i = 0;\r// x++ 和 i++ 都会报错：\rreturn () -\u0026gt; x++ + i++;\r}\r}\r或\npublic class Closure5 {\r// {无法编译成功}\rIntSupplier makeFun(int x) {\rint i = 0;\ri++;\rx++;\rreturn () -\u0026gt; x + i;\r}\r}\r如何解决：\npublic class Closure6 {\rIntSupplier makeFun(int x) {\rint i = 0;\ri++;\rx++;\rfinal int iFinal = i;\rfinal int xFinal = x;\rreturn () -\u0026gt; xFinal + iFinal;\r}\r}\rJava8以前的闭包\npublic class AnonymousClosure {\rIntSupplier makeFun(int x) {\rint i = 0;\r// 同样规则的应用:\r// i++; // 非等同 final 效果\r// x++; // 同上\rreturn new IntSupplier() {\rpublic int getAsInt() { return x + i; }\r};\r}\r}\r 实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。\n 函数组合 在高阶函数时使用Function的andThen方法，就是一个将多个函数组合成新函数的方法。\n例如；\n   组合方法 支持的接口 解释     andThen(arg) Function、Consumer、UnaryOperator、BinaryOperator 先执行操作，再执行参数操作   compose(arg) Function、UnaryOperator、IntUnaryOperator 先执行参数操作，再执行原操作   negate() Predicate 该谓词的逻辑非   and(arg) Predicate 原谓词(Predicate)和参数谓词的短路逻辑与   or(arg) Predicate 原谓词和参数谓词的短路逻辑或    衍生出来的接口就不列举了\nFunction调用andThen和compose的例子：\npublic class FunctionComposition {\rstatic Function\u0026lt;String, String\u0026gt;\rf1 = s -\u0026gt; {\rSystem.out.println(s);\rreturn s.replace('A', '_');\r},\rf2 = s -\u0026gt; s.substring(3),\rf3 = s -\u0026gt; s.toLowerCase(),\rf4 = f1.compose(f2).andThen(f3);\rpublic static void main(String[] args) {\rSystem.out.println(\rf4.apply(\u0026quot;GO AFTER ALL AMBULANCES\u0026quot;));\r}\r}\r输出：\nAFTER ALL AMBULANCES\r_fter _ll _mbul_nces\rPredicate调用negate、and和or的例子：\npublic class PredicateComposition {\rstatic Predicate\u0026lt;String\u0026gt;\rp1 = s -\u0026gt; s.contains(\u0026quot;bar\u0026quot;),\rp2 = s -\u0026gt; s.length() \u0026lt; 5,\rp3 = s -\u0026gt; s.contains(\u0026quot;foo\u0026quot;),\rp4 = p1.negate().and(p2).or(p3);\rpublic static void main(String[] args) {\rStream.of(\u0026quot;bar\u0026quot;, \u0026quot;foobar\u0026quot;, \u0026quot;foobaz\u0026quot;, \u0026quot;fongopuckey\u0026quot;)\r.filter(p4)\r.forEach(System.out::println);\r}\r}\r输出：\nfoobar\rfoobaz\rp4等价于s-\u0026gt;!s.contains(\u0026quot;bar\u0026quot;)\u0026amp;\u0026amp;s.length()\u0026lt;5||s.contains(\u0026quot;foo\u0026quot;)\n 这里使用流式编程，对于四个字符串组成的流，使用p4这个断言过滤出为出true的结果，最终再打印出来。\n 柯里化和部分求值  柯里化意为：将一个多参数的函数，转换为一系列单参数函数。\n 例如：\npublic class CurryingAndPartials {\r// 未柯里化:\rstatic String uncurried(String a, String b) {\rreturn a + b;\r}\rpublic static void main(String[] args) {\r// 柯里化的函数:\rFunction\u0026lt;String, Function\u0026lt;String, String\u0026gt;\u0026gt; sum =\ra -\u0026gt; b -\u0026gt; a + b; // [1]\rSystem.out.println(uncurried(\u0026quot;Hi \u0026quot;, \u0026quot;Ho\u0026quot;));\rFunction\u0026lt;String, String\u0026gt;\rhi = sum.apply(\u0026quot;Hi \u0026quot;); // [2]\rSystem.out.println(hi.apply(\u0026quot;Ho\u0026quot;));\r// 部分应用:\rFunction\u0026lt;String, String\u0026gt; sumHi =\rsum.apply(\u0026quot;Hup \u0026quot;);\rSystem.out.println(sumHi.apply(\u0026quot;Ho\u0026quot;));\rSystem.out.println(sumHi.apply(\u0026quot;Hey\u0026quot;));\r}\r}\r输出：\nHi Ho\rHi Ho\rHup Ho\rHup Hey\r注意接口的声明，第二类型参数是一个Function类型。\n可以通过继续添加层级来柯里化一个三参数函数：\n// functional/Curry3Args.java\rimport java.util.function.*;\rpublic class Curry3Args {\rpublic static void main(String[] args) {\rFunction\u0026lt;String,\rFunction\u0026lt;String,\rFunction\u0026lt;String, String\u0026gt;\u0026gt;\u0026gt; sum =\ra -\u0026gt; b -\u0026gt; c -\u0026gt; a + b + c;\rFunction\u0026lt;String,\rFunction\u0026lt;String, String\u0026gt;\u0026gt; hi =\rsum.apply(\u0026quot;Hi \u0026quot;);\rFunction\u0026lt;String, String\u0026gt; ho =\rhi.apply(\u0026quot;Ho \u0026quot;);\rSystem.out.println(ho.apply(\u0026quot;Hup\u0026quot;));\r}\r}\r输出：\nHi Ho Hup\r再来一个例子\n1 2 3 4 5 6 7 8  public class CurriedIntAdd { public static void main(String[] args) { IntFunction\u0026lt;IntUnaryOperator\u0026gt; curriedIntAdd = a -\u0026gt; b -\u0026gt; a + b; IntUnaryOperator add4 = curriedIntAdd.apply(4); System.out.println(add4.applyAsInt(5)); } }   输出：\n9\r","description":"快速开始Java8函数式编程","id":8,"section":"posts","tags":null,"title":"快速开始Java8函数式编程","uri":"https://qinry.github.io/posts/2021/11/quickstart-java8-functional-programming/"},{"content":"简介 MongoDB，是一款分布式文件存储数据库系统。是NoSQL类型（Not Only SQL）。旨在为WEB应用提供可扩展的高性能数据存储解决方案。其数据结构非常松散，类似JSON的BSON格式，作为其数据传输和存储的格式。BSON，理解为二进制的JSON，可以用来表示一些简答数据类型，还有对象和数组等。\n其特点：\n 面向集合存储，易存储对象类型数据。 支持动态查询 支持完全索引 支持复制和故障恢复 支持多语言开发 使用高效的二进制存储  适合场景：\n 网站实时数据处理。实时插入、更新和查询； 缓存。充当关系型数据库数据的缓存，避免关系型数据库过载访问； 高伸缩性的场景，非常适合由数十或数百台服务器组成的数据库，它的路线图中已经包含对 MapReduce引擎的内置支持。  不适合场景：\n 要求高度事务性的系统 传统的商业智能应用 复杂跨文档查询，即级联查询  与关系型数据库类比概念\n   关系型数据库 MongoDB 说明     database database 数据库   table collection 表/集合   row document 行/文档   column field 列/字段   index index 索引   table joins - MongoDB不支持联表查询   primary key primary key 主键，MongoDB自动生成_id字段设为主键    安装 Linux CentOS7 发行版安装MongoDB\n到MongoDB官网找到相应版本，拷贝连接，使用wget下载\n# 安装mongodb依赖\rsudo yum install libcurl openssl xz-libs\r# 下载mongodb-community server和database-tools\rwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.3.tgz\rwget https://fastdl.mongodb.org/tools/db/mongodb-database-tools-rhel70-x86_64-100.5.1.tgz\r# 解压安装\rtar zxvf mongodb-linux-x86_64-rhel70-5.0.3.tgz\rmv mongodb-linux-x86_64-rhel70-5.0.3 /usr/local/mongodb\rtar zxvf mongodb-database-tools-rhel70-x86_64-100.5.1.tgz\rcd mongodb-database-tools-rhel70-x86_64-100.5.1/bin\rcp * /usr/local/mongodb/bin/\rln -s /usr/local/mongodb/bin/* /usr/local/bin/\rcd ../../\r创建数据库目录和日志目录\nmkdir -p /var/lib/mongo\rmkdir -p /var/log/mongodb\rchown -R `whoami` /var/lib/mongo\rchown -R `whomai` var/log/mongodb\r安装emacs\nyum install -y emacs\rcd /usr/local/mongodb/bin\remacs -nw mongod.conf\r编辑mongod.conf\nsystemLog:\rdestination: file\rpath: \u0026quot;/var/log/mongodb/mongod.log\u0026quot;\rlogAppend: true\rstorage:\rdbPath: \u0026quot;/var/lib/mongo\u0026quot;\rjournal:\renabled: true\rprocessManagement:\rfork: true\rnet:\rbindIp: 0.0.0.0\rport: 27017\rC-x C-s 保存，C-x C-c 退出emacs（C指control键，x、s、c字母键）\n运行 mongod -f /usr/local/mongodb/bin/mongod.conf\r可编写脚本运行\n退出运行\nmongod -f /usr/local/mongodb/bin/mongod.conf --shutdown\r连接MongoDB 在shell中输入命令mongo就可以进入客户端交互界面。\nmongo 127.0.0.1 # shell没有指定ip，默认使用127.0.0.1\r常见数据类型 {\u0026quot;x\u0026quot;: null} # null类型\r{\u0026quot;x\u0026quot;: true} # 布尔类型\r{\u0026quot;x\u0026quot;: 2.32} # 默认数字类型为64位浮点数\r{\u0026quot;x\u0026quot;: NumberInt(2)} # 32整数\r{\u0026quot;x\u0026quot;: NumberLong(2)} # 64位整数\r{\u0026quot;x\u0026quot;: \u0026quot;string\u0026quot;} # 字符串\r{\u0026quot;x\u0026quot;: new Date()} # 日期\r{\u0026quot;x\u0026quot;: [\u0026quot;hello\u0026quot;,\u0026quot;world\u0026quot;]} # 数组\r{\u0026quot;x\u0026quot;: /mongodb/i} # 正则表达式\r{\u0026quot;x\u0026quot;:{\u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;}} # 内嵌文档\r{\u0026quot;_id\u0026quot;: ObjectId()} # _id和ObjectId，_id可以是任何类型；不指定_id时，会生成ObjectId对象\rObjectId是12字节（24个十六进制数）存储空间，数据组织：\n0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 时间戳 | 机器码 |进程PID| 计数器\r常见指令 show dbs # 查看数据库\ruse db0 # use \u0026lt;database name\u0026gt; 切换数据库/创建再切换数据库\rdb # 当前所在数据库\rshow collections # 查看所有数据集\rdb.dropDatabase() # 删除当前数据库\rdb.createCollection(\u0026quot;users\u0026quot;) # 创建数据集\rdb.users.drop() # db.\u0026lt;collection name\u0026gt;.drop()删除数据集\rdb.users.renameCollection(\u0026quot;user\u0026quot;) # db.\u0026lt;old collection name\u0026gt;.renameCollection(\u0026quot;new name\u0026quot;) 改数据集名称\rdb.user.insert({\u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;, age: 18}) # db.\u0026lt;collection name\u0026gt;.insert({\u0026quot;key\u0026quot;: value}) 新增数据\rdb.user.save({\u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;, age: 18}) # db.\u0026lt;collection name\u0026gt;.save({\u0026quot;key\u0026quot;: value}) 新增数据\rdb.user.find() # db.\u0026lt;collection name\u0026gt;.find() 全查\r# db.\u0026lt;collection name\u0026gt;.find(condition) 条件查询\rdb.user.find({\u0026quot;age\u0026quot;: 18}) # 等于18\rdb.user.find({\u0026quot;age\u0026quot;: {$gt:14}}) # 大于14\rdb.user.find({\u0026quot;age\u0026quot;: {$gte:14}}) # 大于等于14\rdb.user.find({\u0026quot;age\u0026quot;: {$lt:14}}) # 小于14\rdb.user.find({\u0026quot;age\u0026quot;: {$lte:14}}) # 小于等于14\rdb.user.find().pretty() # 人性化格式化输出\r# or关系：{$or:[{k1:v1},{k2:v2}]}\rdb.user.find({$or: [{\u0026quot;name\u0026quot;: \u0026quot;zhangsan\u0026quot;},{\u0026quot;age\u0026quot;: {$gt:12}}]}) # name等于zhangsan或者age大于12\r# db.\u0026lt;collection name\u0026gt;.remove(condition) 条件删除\rdb.user.remove({\u0026quot;age\u0026quot;: {$lt:12}}) db.user.findOne() # db.\u0026lt;collection name\u0026gt;.findOne() 查询一条数据\rdb.user.find({},{name:1}) # 查询指定字段，1表示只包含该字段，0表示排除该字段\rdb.user.distinct('name') # db.\u0026lt;collection name\u0026gt;.distinct('field name') 查询指定字段，并去重\rdb.user.find().sort({name:1}) # 升序， -1则表示降序\rdb.user.find().count() # 查询条数\rdb.user.find().limit(3) # 查询限定数量\rdb.user.find().limit(3).skip(5) # 先跳过前5个，再查询3个\r# db.\u0026lt;collection name\u0026gt;.update(query, update, upsert, multi) query查询条件，update更新的字段，\r# upsert为true，不存在值插入，默认为false不插入\r# multi为true，更新所有查询的数据，为false更新第一条数据\rdb.user.update({name:'tom'},{$set:{age: 21}},false, true)\r索引 创建索引\n# db.\u0026lt;collection name\u0026gt;.createIndex(keys, options)\rdb.users.createIndex({\u0026quot;name\u0026quot;: 1}) # 1表示升序，-1表示降序\roptions含义：\n   参数 类型 说明     background boolean 建索引过程会阻塞其它数据库操作，background可指定 以后台方式创建索引，即增加 \u0026ldquo;background\u0026rdquo; 可选参数。 \u0026ldquo;background\u0026rdquo; 默认值为false。   unique boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值 为false.   name String 索引的名称。如果未指定，MongoDB的通过连接索引的 字段名和排序顺序生成一个索引名称。例如：name_1   dropDups boolean 3.0+版本已废弃。在建立唯一索引时是否删除重复记录, 指定 true 创建唯一索引。默认值为 false.   sparse boolean 对文档中不存在的字段数据不启用索引;这个参数需要特 别注意，如果设置为true的话，在索引字段中不会查询出 不包含对应字段的文档.。默认值为 false.   expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的 生存时间。   v index version 索引的版本号。默认的索引版本取决于mongod创建索引 时运行的版本。   weigths document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对 于其他索引字段的得分权重。   default_language String 对于文本索引，该参数决定了停用词列表及词干分析器和分词器的规则。 默认为 english   language_override String 对于文本索引，该参数的值是集合文档中字段名，此字段包含索引指定使用的语言，默认值为 language.    索引分类：\n用创建的索引的参数来说明\n 默认索引：集合创建后，系统自动创建名为_id的主键和名为_id_的索引，此索引无法删除 单列索引：例如{\u0026ldquo;name\u0026rdquo;:1} 组合索引；例如{\u0026ldquo;name\u0026rdquo;:1,\u0026ldquo;age\u0026rdquo;:1} 唯一索引：例如{\u0026ldquo;name\u0026rdquo;:1},{unique:true} TTL索引：例如{\u0026ldquo;createAt\u0026rdquo;:1},{expireAfterSeconds:3600}  删除索引\n# db.\u0026lt;collection name\u0026gt;.dropIndex(\u0026quot;index name\u0026quot;)\rdb.users.dropIndex(\u0026quot;name\u0026quot;)\rdb.users.dropIndexes()  用remove删除集合数据不会删除索引，drop又删除集合数据又删除索引\n 备份和恢复 备份\nmongodump -h 127.0.0.1:27017 -d db0 -o /Users/yourname\r -h指定主机ip和port，默认127.0.0.1和27017 -d指定数据库名，这里是db0 -o指定备份到目标目录  也可以不指定以上参数，将使用默认参数，并将有数据的数据库全部备份到当前目录\nmongodump\rtree dump\rdump\r├── admin\r│ ├── system.version.bson\r│ └── system.version.metadata.json\r└── db0\r├── users.bson\r└── users.metadata.json\r将当前MongoDB服务实例的数据备份到当前目录下，在当前目录下会创建一个dump文件夹，该文件夹下又有与数据库同名的文件夹，如admin和db0。数据文件是.bson后缀的文件\n恢复\nmongorestore -h 127.0.0.1:27017 -d test dump/db0/users.bson\r -h指定主机ip和port，默认127.0.0.1和27017 -d指定目标数据库名，这里是test dump/db0/users.bson指备份数据的路径，未指定则为当前目录下的dump中数据  将当前目录下的dump/db0/users.bson数据恢复到新数据库test中\n搭建集群 在三个主机安装MongoDB，假如他们的主机地址分别为；192.168.123.181、192.168.123.182和192.168.123.183\n三个不同主机的MongoDB实例，分别改写配置文件mongod.conf\nemacs -nw /usr/local/mongodb/bin/mongod.conf\rsystemLog:\rdestination: file\rpath: \u0026quot;/var/log/mongodb/mongod.log\u0026quot;\rlogAppend: true\rstorage:\rdbPath: \u0026quot;/var/lib/mongo\u0026quot;\rjournal:\renabled: true\rprocessManagement:\rfork: true\rnet:\rbindIp: 0.0.0.0\rport: 27017\r# 添加副本集，名为rs0\rreplication:\rreplSetName: \u0026quot;rs0\u0026quot;\r初始化副本集\nmongo\r\u0026gt; rs.initiate({_id:'rs0'},members:[{_id:1,host:'192.168.123.181:27017'},{_id:2,host:'192.168.123.182:27017'},{_id:3,host:'192.168.123.183:27017'}])\r查看状态\nrs0.PRIMARY\u0026gt; rs.status()\r# 部分信息如下\r{\r# ...\rmembers: [{\r\u0026quot;_id\u0026quot; : 1,\r\u0026quot;name\u0026quot; : \u0026quot;192.168.123.181:27017\u0026quot;,\r\u0026quot;health\u0026quot; : 1,\r\u0026quot;state\u0026quot; : 1,\r\u0026quot;stateStr\u0026quot; : \u0026quot;PRIMARY\u0026quot;,\r# ...\r},{\r\u0026quot;_id\u0026quot; : 2,\r\u0026quot;name\u0026quot; : \u0026quot;192.168.123.182:27017\u0026quot;,\r\u0026quot;health\u0026quot; : 1,\r\u0026quot;state\u0026quot; : 2,\r\u0026quot;stateStr\u0026quot; : \u0026quot;SECONDARY\u0026quot;,\r},\r# ...\r],\r}\r要在从机查询数据，需要调用secondaryOK()方法\nrs0.SECONDARY\u0026gt; rs.secondaryOk()\r删除节点\nrs0.PRIMARY\u0026gt; rs.remove(\u0026quot;192.168.123.183:27017\u0026quot;) # rs.remove(\u0026quot;ip:port\u0026quot;)\r{\r\u0026quot;ok\u0026quot; : 1,\r\u0026quot;$clusterTime\u0026quot; : {\r\u0026quot;clusterTime\u0026quot; : Timestamp(1635336751, 1),\r\u0026quot;signature\u0026quot; : {\r\u0026quot;hash\u0026quot; : BinData(0,\u0026quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=\u0026quot;),\r\u0026quot;keyId\u0026quot; : NumberLong(0)\r}\r},\r\u0026quot;operationTime\u0026quot; : Timestamp(1635336751, 1)\r}\r添加节点与删除节点类似，rs.add(\u0026ldquo;ip:port\u0026rdquo;)\n添加仲裁者\nrs0.PRIMARY\u0026gt; db.adminCommand({setDefaultRWConcern:1,defaultWriteConcern:{\u0026quot;w\u0026quot;:1}})\rrs0.PRIMARY\u0026gt; rs.addArb(\u0026quot;192.168.123.183:27017\u0026quot;)\r 添加仲裁者之前需要强制修改Default Write Concern，从5.0开始。\n注：仲裁者对偶数集群有效。在一主一从关系中，任意节点宕机都无法选举出主节点，无法提供写操作。此时需要加入仲裁者节点即可。\n ","description":"MongoDB快速开始使用","id":9,"section":"posts","tags":["mongodb"],"title":"Mongodb 快速开始","uri":"https://qinry.github.io/posts/2021/10/mongodb-crash/"},{"content":"IO模型 有三个重要的IO模型：\n  BIO 同步阻塞IO\n  NIO 同步非阻塞IO\n  AIO 异步IO\n   同步与异步。它们是相对于应用程序与系统内核交互讨论的。\n  同步是应用触发IO操作等待或轮询数据读写就绪；异步采取订阅-发布模式，应用发送IO请求给内核，然后应用进行其他操作并订阅回复的消息，是内核触发IO操作，当数据的读写完成时，发布消息回给应用。\n  阻塞与非阻塞。它们是相对于IO的就绪状态，应用采取的处理方式讨论的。\n  当数据不可写入，或者是说，无数据可读时，如果采取阻塞方式，应用将等待数据可读可写为止，线程自然会挂起；如果采用非阻塞方式，有数据可读可写则进行操作，没有则不等待直接返回，常常通过循环来轮询数据读写是否就绪，线程不挂起，比起阻塞有更好的响应速度。\n BIO模型 BIO模型简单，适合连接数量少且固定的场景（这里的少是指千量级及其以下）。一个连接对应一个线程处理IO，可通过线程池方式来缓冲连接请求，提升高可用。\n简单例子：\nServerSocket\n 创建ServerSocket，绑定端口10086； ServerSocket接受连接得到Socket，获取输入和输出流； 通过输出流发送和输入流接受数据。  public class BIOServer {\rpublic static void main(String[] args) {\rtry {\rExecutorService exec = Executors.newFixedThreadPool(10);\rServerSocket server = new ServerSocket(10086);\rSystem.out.println(\u0026quot;服务端端口号--10086\u0026quot;);\rwhile (true) {\rSocket client = server.accept();\rSystem.out.println(\u0026quot;客户端连接成功\u0026quot;);\rexec.submit(()-\u0026gt;{\rSystem.out.println(\u0026quot;线程ID:\u0026quot;+Thread.currentThread().getId());\rSystem.out.println(\u0026quot;线程名称:\u0026quot;+Thread.currentThread().getName());\rtry {\rInputStream in = client.getInputStream();\rBufferedReader reader = new BufferedReader(new InputStreamReader(in));\rwhile (true) {\rOptional\u0026lt;String\u0026gt; msg = Optional.ofNullable(reader.readLine());\rif (!msg.isPresent()) {\rbreak;\r}\rSystem.out.println(\u0026quot;客户端消息:\u0026quot;+msg);\r}\r} catch (IOException e) {\re.printStackTrace();\r}\r});\r}\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rSocket\n 创建Socket，绑定ip和端口，然后发送连接 Socket获得输入流和输出流 通过输入流接受和输出流发送数据  public class BIOClient {\rpublic static void main(String[] args) {\rtry (Socket socket = new Socket(\u0026quot;127.0.0.1\u0026quot;, 10086)) {\rOutputStream out = socket.getOutputStream();\rSystem.out.println(\u0026quot;客户端连接成功\u0026quot;);\rPrintWriter writer = new PrintWriter(out, true);\rwriter.println(\u0026quot;hello\u0026quot;);\rSystem.in.read();\r} catch (UnknownHostException e) {\re.printStackTrace();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rNIO模型 NIO模型复杂度稍微高了一点，适合请求量较多且短连接的场景（至少大到十万量级别）。\nBIO单向的流处理输入输出，而NIO是以块的形式处理，而且是双向的。\nBIO是基于字节流和字符流操作，而BIO是基于缓冲区(Buffer)和通道(Channel)操作的，进一步可通过同一个轮询器(Selector)监听多个客户端通道和一个服务器通道事件，进行读写操作，即多路复用。\n数据总是通过缓冲区写入通道，亦或者从通道读入缓冲区。\n核心类是：Selector（包括SelectionKey）、Channel、Buffer\n简单例子:\nServerSocketChannel\n初始化\n 创建ServerSocketChannel，绑定端口，设置非阻塞； 将ServerSocketChannel注册到Selector，设为监听接受连接事件；  轮询\n通过Selector轮询通道，0表示未选择到通道，大于0表示有可选择通道； 通过selectionKeys方法获取数据已就绪的通道； 通过key.isAcceptable判断，ServerSocketChannel接受客户端通道并注册到Selector，设为监听读数据事件；  读/写数据\n通过key.isReadable判断，处理Readable，接受数据。read大于0表示通道还连接可读数据。为-1时，表示客户端断开连接。  public class NIOServer {\rpublic static void main(String[] args) {\rtry(Selector selector = Selector.open();\rServerSocketChannel server = ServerSocketChannel.open()) {\rserver.bind(new InetSocketAddress(10086));\r// 通道设为非阻塞\rserver.configureBlocking(false);\rserver.register(selector, SelectionKey.OP_ACCEPT);\rwhile (true) {\rif (selector.select(3000) == 0) {\rSystem.out.println(\u0026quot;Server: 等待接受连接中。。。先忙别的\u0026quot;);\rcontinue;\r}\rSet\u0026lt;SelectionKey\u0026gt; selectionKeys = selector.selectedKeys();\rIterator\u0026lt;SelectionKey\u0026gt; keyIterator = selectionKeys.iterator();\rwhile (keyIterator.hasNext()) {\rSelectionKey key = keyIterator.next();\rif (key.isAcceptable()) {\rSocketChannel client = server.accept();\rclient.configureBlocking(false);\rSystem.out.println(\u0026quot;有客户端连接了-\u0026quot;+client.hashCode());\rclient.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));\r} else if (key.isReadable()) {\rSocketChannel client = (SocketChannel) key.channel();\rByteBuffer buffer = (ByteBuffer) key.attachment();\rint read = client.read(buffer);\rif (read \u0026gt; 0) {\rbuffer.flip();\rSystem.out.println(\u0026quot;客户端消息：\u0026quot; + new String(buffer.array(), 0, buffer.limit(), StandardCharsets.UTF_8));\r} else if (read == -1){\rclient.close();\r}\r}\rkeyIterator.remove();\r}\r}\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rSocketChannel\n 创建SocketChannel，绑定ip和端口，设置非阻塞 发送连接，通过循环finishConnect完成连接 SocketChannel通过ByteBuffer读/写数据  public class NIOClient {\rpublic static void main(String[] args) {\rtry (SocketChannel client = SocketChannel.open()) {\rclient.configureBlocking(false);\rInetSocketAddress address = new InetSocketAddress(\u0026quot;127.0.0.1\u0026quot;, 10086);\rif (!client.connect(address)) {\rwhile (!client.finishConnect()) {\rSystem.out.println(\u0026quot;连接服务端中。。。可先忙别的\u0026quot;);\r}\r}\rString msg = \u0026quot;hi\u0026quot;;\rByteBuffer buf = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8));\rclient.write(buf);\rSystem.in.read();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\r 注：不熟悉的方法查看api文档\n ","description":"了解NIO网络编程，与BIO的区别","id":10,"section":"posts","tags":["io"],"title":"NIO 网络编程","uri":"https://qinry.github.io/posts/2021/10/nio-network/"},{"content":"概述 Vue，一套用于构建用户界面的渐进式框架，被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，还支持事件驱动。\n什么是MVVM\nMVVM代表Mode-View-ViewModel，一种软件架构。\n Model：模型层，数据保存 View：视图层，用户界面 ViewModel：视图模型层，还可以理解为数据绑定器，负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。  ViewModel层采用双向数据绑定，View发生变动，自动反映ViewModel，反之亦然。ViewModel和Model之间则是双向通信。\nVue可以理解为实现MVVM理念的前端框架。\n第一个Vue程序 Vue中的data的属性表示模型数据，视图模板中用两个花括号来代表绑定的相应名称的模型数据，也可以是使用v-为前缀的指令来绑定数据。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r{{message}}\r\u0026lt;span v-bind:title=\u0026quot;message\u0026quot;\u0026gt;鼠标悬停在这里几秒\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata:{ // 模型\rmessage:\u0026quot;hello,Vue!\u0026quot;\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r显示：\n当Model数据发生改变时，ViewModel会同步View的改变，例如在浏览器的控制台修改vm.message的值，反映到视图。\n基本语法 if-else判断和for循环，指令分别有v-if、v-else-if、v-else和v-for\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;h2 v-if=\u0026quot;type==='A'\u0026quot;\u0026gt;A\u0026lt;/h2\u0026gt;\r\u0026lt;h2 v-else-if=\u0026quot;type==='B'\u0026quot;\u0026gt;B\u0026lt;/h2\u0026gt;\r\u0026lt;h2 v-else-if=\u0026quot;type==='C'\u0026quot;\u0026gt;C\u0026lt;/h2\u0026gt;\r\u0026lt;h2 v-else\u0026gt;D\u0026lt;/h2\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;app2\u0026quot;\u0026gt;\r\u0026lt;li v-for=\u0026quot;(item,index) in items\u0026quot;\u0026gt;\r{{item.message}}-{{index}}\r\u0026lt;/li\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\rtype: 'A'\r}\r});\rvar vm2 = new Vue({\rel: \u0026quot;#app2\u0026quot;,\rdata: {\ritems: [\r{message: \u0026quot;foo\u0026quot;},\r{message: \u0026quot;bar\u0026quot;}\r]\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r显示：\n绑定事件 vue的methods属性声明了用于绑定事件的方法，使用v-on:事件的指令来绑定事件(事件名和jQuery一致)\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;button v-on:click=\u0026quot;sayHi\u0026quot;\u0026gt;点我\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: { // 模型\rmessage: \u0026quot;hello,Vue!\u0026quot;\r},\rmethods: {\rsayHi: function() {\ralert('hello, vue!');\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r显示：\n数据双向绑定 使用v-model指令绑定表单的输入域\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;uname\u0026quot; name=\u0026quot;text\u0026quot; v-model=\u0026quot;message\u0026quot;\u0026gt;\r{{message}} \u0026lt;br\u0026gt;\r\u0026lt;select name=\u0026quot;option\u0026quot; v-model=\u0026quot;selected\u0026quot;\u0026gt;\r\u0026lt;option value=\u0026quot;\u0026quot; disabled\u0026gt;--请选择--\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;A\u0026quot;\u0026gt;A\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;B\u0026quot;\u0026gt;B\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\r{{selected}} \u0026lt;br\u0026gt;\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;sex\u0026quot; value=\u0026quot;男\u0026quot; v-model=\u0026quot;sex\u0026quot; \u0026gt;男\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;sex\u0026quot; value=\u0026quot;女\u0026quot; v-model=\u0026quot;sex\u0026quot; \u0026gt;女\r{{sex}}\u0026lt;br\u0026gt;\r\u0026lt;textarea name=\u0026quot;info\u0026quot; id=\u0026quot;\u0026quot; cols=\u0026quot;30\u0026quot; rows=\u0026quot;10\u0026quot; v-model=\u0026quot;textarea\u0026quot; style=\u0026quot;resize:none;\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt;\r{{textarea}} \u0026lt;br\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: { // 模型\rmessage: 'hello,Vue!',\rselected: '',\rsex: '男',\rtextarea: '123'\r},\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rvue组件 组件可设置名称，如名为list，使用组件与使用标签一样。组件的模版与普通vue视图编写一致。还有props属性用于组件的数据绑定。v-bind:item与props属性数组中item直接相关，模板中{{item}}也与props中的item相关。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;vue-component\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;list\rv-for=\u0026quot;item in items\u0026quot;\rv-bind:item=\u0026quot;item\u0026quot;\r\u0026gt;\u0026lt;/list\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// vue 组件\rVue.component('list', {\rprops: ['item'],\rtemplate: '\u0026lt;li\u0026gt;{{item}}\u0026lt;/li\u0026gt;'\r});\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: { // 模型\ritems: ['Java', 'JavaScript', 'C']\r},\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\raxios通信 要导入vue文件后，导入axios文件。vue对象具有生命周期，其中许多钩子函数，例如beforeCreate、mounted等等。mounted函数用于一次ajax的请求。详情 axios-js\nGET请求语法，如下：\naxios.get('/getUser',{id:1})\r.then(response=\u0026gt;{console.log(response)})\r.catch(error=\u0026gt;{console.log(error)});\rPOST类似。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;axios\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\r/* 解决闪烁问题 */\r[v-clock] {\rdisplay: none;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;vue\u0026quot; v-clock\u0026gt;\r\u0026lt;h2\u0026gt;{{info.name}}\u0026lt;/h2\u0026gt;\r\u0026lt;a v-bind:href=\u0026quot;info.url\u0026quot;\u0026gt;百度一下\u0026lt;/a\u0026gt;\r\u0026lt;p\u0026gt;{{info.description}}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026quot;https://unpkg.com/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#vue\u0026quot;,\rdata() {\rreturn { info:{} }\r},\rmounted() {\raxios.get('../data.json').then(response=\u0026gt;(this.info=response.data))\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r{\r\u0026quot;name\u0026quot;: \u0026quot;百度\u0026quot;,\r\u0026quot;url\u0026quot;: \u0026quot;https://www.baidu.com\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;有问题找度娘\u0026quot;\r}\r计算属性 computed属性与methods属性的写法一致，但有区别，使用methods不会缓存计算结果，而computed则会缓存结果。在浏览器控制台每调用一次vm.currentTime1()会产生不同结果，而vm.currentTime2则每次调用结果都与第一次的结果是一样，除非起内部的方法里字段发生修改或页面刷新。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;computed\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视图 --\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;currentTime1 {{currentTime1()}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;currentTime2 {{currentTime2}}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 1. 导入vue.js --\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\r// 视图模型\rvar vm = new Vue({\rel: \u0026quot;#app\u0026quot;,\rdata: {\rmessage: \u0026quot;Hello, Vue!\u0026quot;\r}\rmethods: {\rcurrentTime1: function() {\rreturn Date.now();\r}\r},\rcomputed: {\rcurrentTime2: function() {\rreturn Date.now();\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r插槽 模板需要指定slot属性，组件中template属性内部slot标签需要指定name。通过使用插槽，使得模板视图更加灵活，不嵌入静态数据。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;slot\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;todo\u0026gt;\r\u0026lt;todo-title slot=\u0026quot;todo-title\u0026quot; :title=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;/todo-title\u0026gt;\r\u0026lt;todo-list slot=\u0026quot;todo-list\u0026quot; v-for=\u0026quot;item in items\u0026quot; :item=\u0026quot;item\u0026quot;\u0026gt;\u0026lt;/todo-list\u0026gt;\r\u0026lt;/todo\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rVue.component('todo', {\rtemplate: '\u0026lt;div\u0026gt;' +\r'\u0026lt;slot name=\u0026quot;todo-title\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;' +\r'\u0026lt;ul\u0026gt;' +\r'\u0026lt;slot name=\u0026quot;todo-list\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;' +\r'\u0026lt;/ul\u0026gt;' +\r'\u0026lt;/div\u0026gt;'\r});\rVue.component('todo-title', {\rprops: ['title'],\rtemplate: '\u0026lt;div\u0026gt;{{title}}\u0026lt;/div\u0026gt;'\r});\rVue.component('todo-list', {\rprops: ['item'],\rtemplate: '\u0026lt;li\u0026gt;{{item}}\u0026lt;/li\u0026gt;'\r});\rvar vm = new Vue({\rel: '#app',\rdata: {\rtitle: '编程语言',\ritems: ['Java', 'JavaScript', 'C']\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r自定义事件内容分发 组件要自删除的按钮的实现，需要自定义事件内容分发来完成。Vue对象是直接参与模型数据删除，其方法为removeItems。组件需要监听鼠标点击事件，触发remove方法。remove方法再通过调用特殊函数this.$emit('自定义事件名称', 参数列表)，这个自定义事件还需要模板绑定自定义事件，自定义事件触发的方法正是直接参与删除的removeItems，比如：@removeItems=\u0026quot;removeItems(idx)\u0026quot;。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;custom-event-content-deliver\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;todo\u0026gt;\r\u0026lt;todo-title slot=\u0026quot;todo-title\u0026quot; :title=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;/todo-title\u0026gt;\r\u0026lt;todo-list slot=\u0026quot;todo-list\u0026quot; v-for=\u0026quot;(item, idx) in items\u0026quot;\r:item=\u0026quot;item\u0026quot; :idx=\u0026quot;idx\u0026quot; @removeItems=\u0026quot;removeItems(idx)\u0026quot;\r\u0026gt;\u0026lt;/todo-list\u0026gt;\r\u0026lt;/todo\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rVue.component('todo', {\rtemplate: '\u0026lt;div\u0026gt;' +\r'\u0026lt;slot name=\u0026quot;todo-title\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;' +\r'\u0026lt;ul\u0026gt;' +\r'\u0026lt;slot name=\u0026quot;todo-list\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;' +\r'\u0026lt;/ul\u0026gt;' +\r'\u0026lt;/div\u0026gt;'\r});\rVue.component('todo-title', {\rprops: ['title'],\rtemplate: '\u0026lt;div\u0026gt;{{title}}\u0026lt;/div\u0026gt;'\r});\rVue.component('todo-list', {\rprops: ['item', 'idx'],\rtemplate: '\u0026lt;li\u0026gt;{{idx}}--{{item}} \u0026lt;button @click=\u0026quot;remove\u0026quot;\u0026gt;删除\u0026lt;/button\u0026gt;\u0026lt;/li\u0026gt;',\rmethods: {\rremove: function (idx) {\rthis.$emit('removeItems', idx);\r}\r}\r});\rvar vm = new Vue({\rel: '#app',\rdata: {\rtitle: '编程语言',\ritems: ['Java', 'JavaScript', 'C']\r},\rmethods: {\rremoveItems: function (idx) {\rconsole.log('删除了' + this.items[idx] + ' OK');\rthis.items.splice(idx, 1);\r}\r}\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r总之，组件的点击删除事件需要委托给自定义事件removeItems\nvue-cli 使用vue-cli之前需要安装nodejs，根据平台安装最近的长期维护版本。\n安装后，测试\nnode -v\rnpm -v\r成功则显示：\n然后使用 npm 这个包管理工具，下载相应的前端模块化工具，需要以管理员权限运行：\nnpm install vue-cli -g\rnpm install cnpm -g # cnpm是下载淘宝镜像npm包的工具\r同样测试 vue-cli 是否安装成功：\nvue list\r显示：\n接着使用 vue-cli 初始化一个 vue.js项目\ncd ~/Desktop\rmkdir vue\rcd vue\rvue init webpack myvue\r创建项目时，如果会出现一些输入时，则默认回车，如果出现一些选项，统统按n回车，还有选择编译器时选择运行时加编译器。\n下一步是以开发模式启动项目\ncd myvue\rnpm install\rnpm audit fix\rnpm run dev\r打开浏览器，输入localhost:8080，查看\n查看myvue项目的目录结构，本质也是一个webpack目录结构\n简单了解重要目录与文件：\n src：项目源代码编写的地方 static：存放静态资源，例如html、css、json、图片等等 node_modules：项目依赖库 build：webpack的相关文件存放的地方 config：项目开发环境的配置文件 index.html：项目的入口页面 package.json：项目打包的配置文件  详情见Project Structure\nwebpack 安装webpack\nsudo npm install webpack webpack-cli -g\rwebpack -v\rwebpack-cli -v\r结果：\n创建第一个webpack项目\ncd ~/Desktop\rmkdir webpack-study \u0026amp;\u0026amp; cd webpack-study\rmkdir modules\rcd modules\rtouch main.js\rtouch hello.js\rcd ../\rtouch webpack.config.js\rtouch index.html\rhello.js\n\u0026quot;use strict\u0026quot;;\rexport function sayHi() {\rdocument.write(\u0026quot;\u0026lt;h2\u0026gt;Hello, World!\u0026lt;/h2\u0026gt;\u0026quot;)\r}\rmain.js\n'use strict';\rimport * as hello from './hello';\rhello.sayHi();\rwebpack.config.js\nmodule.exports = {\rentry: \u0026quot;./modules/main.js\u0026quot;,\routput: {\rfilename: \u0026quot;./js/bundle.js\u0026quot;\r}\r}\r然后运行webpack命令，输出dist/js/bundle.js\nindex.html\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;webpack-study\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;script src=\u0026quot;./dist/js/bundle.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r结果：\nvue-router 创建一个vue-cli项目，项目名不为vue-router\n在当前项目下，安装vue-router插件\nsudo npm install vue-router --save-dev\r在src下创建文件夹router，这里存放路由配置\nrouter/index.js\nimport Vue from 'vue';\rimport VueRouter from \u0026quot;vue-router\u0026quot;;\rimport Content from '../components/Content';\rimport Main from '../components/Main'\r// 安装路由\rVue.use(VueRouter)\r// 配置导出路由\rexport default new VueRouter ({\rroutes: [\r{\r// 路径\rpath: '/content',\rname: 'content',\r// 跳转组件\rcomponent: Content\r},\r{\r// 路径\rpath: '/main',\rname: 'main',\r// 跳转组件\rcomponent: Main\r}\r]\r});\r接着编写，路由组件\ncomponents/Main.vue\n\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;首页\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Main\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\rcomponents/Content.vue\n\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;内容页\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Content\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\r在main.js中引入router的相关配置\nimport Vue from 'vue'\rimport App from './App'\r// 导入路由配置\rimport router from './router'\rVue.config.productionTip = false\rnew Vue({\rel: '#app',\rrouter, // 使用路由\rcomponents: { App },\rtemplate: '\u0026lt;App/\u0026gt;'\r})\r最后，在App.vue编写模板\n\u0026lt;template\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;h2\u0026gt;Vue-Router\u0026lt;/h2\u0026gt;\r\u0026lt;router-link to=\u0026quot;/main\u0026quot;\u0026gt;首页\u0026lt;/router-link\u0026gt;\r\u0026lt;router-link to=\u0026quot;/content\u0026quot;\u0026gt;内容页\u0026lt;/router-link\u0026gt;\r\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: 'App',\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r#app {\rfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r-webkit-font-smoothing: antialiased;\r-moz-osx-font-smoothing: grayscale;\rtext-align: center;\rcolor: #2c3e50;\rmargin-top: 60px;\r}\r\u0026lt;/style\u0026gt;\rnpm run dev 运行查看效果效果：\nelementUI 在新的vue-cli项目中，安装element-ui插件\nsudo npm install vue-router --save-dev\rsudo npm i element-ui -S\r# 安装依赖\rsudo npm install\r# 安装 sass-loader 和 node-sass\rsudo cnpm install sass-loader node-sass --save-dev\r# 启动测试\rnpm run dev\r首先编写视图，在src下创建views文件夹\nviews/Main.vue\n\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;主页\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Main\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\rviews/Login.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;el-form ref=\u0026quot;loginForm\u0026quot; :model=\u0026quot;form\u0026quot; :rules=\u0026quot;rules\u0026quot; label-width=\u0026quot;80px\u0026quot; class=\u0026quot;login-box\u0026quot;\u0026gt;\r\u0026lt;h3 class=\u0026quot;login-title\u0026quot;\u0026gt;欢迎登录\u0026lt;/h3\u0026gt;\r\u0026lt;el-form-item label=\u0026quot;账号\u0026quot; prop=\u0026quot;username\u0026quot;\u0026gt;\r\u0026lt;el-input type=\u0026quot;text\u0026quot; placeholder=\u0026quot;请输入账号\u0026quot; v-model=\u0026quot;form.username\u0026quot;\u0026gt;\u0026lt;/el-input\u0026gt;\r\u0026lt;/el-form-item\u0026gt;\r\u0026lt;el-form-item label=\u0026quot;密码\u0026quot; prop=\u0026quot;password\u0026quot;\u0026gt;\r\u0026lt;el-input type=\u0026quot;password\u0026quot; placeholder=\u0026quot;请输入密码\u0026quot; v-model=\u0026quot;form.password\u0026quot;\u0026gt;\u0026lt;/el-input\u0026gt;\r\u0026lt;/el-form-item\u0026gt;\r\u0026lt;el-form-item\u0026gt;\r\u0026lt;el-button type=\u0026quot;primary\u0026quot; @click=\u0026quot;onSubmit('loginForm')\u0026quot;\u0026gt;提交\u0026lt;/el-button\u0026gt;\r\u0026lt;/el-form-item\u0026gt;\r\u0026lt;/el-form\u0026gt;\r\u0026lt;el-dialog\rtitle=\u0026quot;温馨提示\u0026quot;\r:visible.sync=\u0026quot;dialogVisible\u0026quot;\rwidth=\u0026quot;30%\u0026quot;\u0026gt;\r\u0026lt;span\u0026gt;请输入账号和密码\u0026lt;/span\u0026gt;\r\u0026lt;span slot=\u0026quot;footer\u0026quot; class=\u0026quot;el-dialog__footer\u0026quot;\u0026gt;\r\u0026lt;el-button type=\u0026quot;primary\u0026quot; @click=\u0026quot;dialogVisible = false\u0026quot;\u0026gt;确定\u0026lt;/el-button\u0026gt;\r\u0026lt;/span\u0026gt;\r\u0026lt;/el-dialog\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Login\u0026quot;,\rdata() {\rreturn {\rform: {\rusername: '',\rpassword: ''\r},\rrules: {\rusername: [\r{required: true, message: '账号不为空', trigger: 'blur'}\r],\rpassword: [\r{required: true, message: '密码不为空', trigger: 'blur'}\r]\r},\rdialogVisible: false\r}\r},\rmethods: {\ronSubmit(formName) {\rthis.$refs[formName].validate((valid) =\u0026gt; {\rif (valid) {\rthis.$router.push('/main');\r} else {\rthis.dialogVisible = true;\rreturn false;\r}\r});\r}\r}\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r.login-box {\rborder: 1px solid #DCDFE6;\rwidth: 350px;\rmargin: 180px auto;\rpadding: 35px 35px 15px 35px;\rborder-radius: 5px;\r-webkit-border-radius: 5px;\r-moz-border-radius: 5px;\rbox-shadow: 0 0 25px #909399;\r}\r.login-title {\rtext-align: center;\rmargin: 0 auto 40px auto;\rcolor: #303133;\r}\r\u0026lt;/style\u0026gt;\r接着，编写路由相关配置\nrouter/index.js\nimport Vue from 'vue';\rimport Router from \u0026quot;vue-router\u0026quot;;\rimport Main from \u0026quot;../views/Main\u0026quot;;\rimport Login from \u0026quot;../views/Login\u0026quot;;\r// 安装路由\rVue.use(Router); // 配置导出路由\rexport default new Router({\rroutes: [\r{\rpath: '/main',\rname: 'main',\rcomponent: Main\r},\r{\rpath: '/login',\rname: 'login',\rcomponent: Login\r}\r]\r});\r最后，导入Element-UI并使用\nmain.js\nimport Vue from 'vue'\r// 导入ElementUI相关的库\rimport ElementUI from 'element-ui';\rimport 'element-ui/lib/theme-chalk/index.css';\rimport App from './App';\rimport router from './router';\rVue.use(ElementUI); // Vue使用ElementUI\rnew Vue({\rel: '#app',\rrouter,\rrender: h =\u0026gt; h(App) // 在App中渲染ElementUI的组件\r})\r更多ElementUI组件见，点这里\n嵌套路由 在views下，增加user目录，里面再新增Profile.vue和List.vue\nProfile.vue\n\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;个人信息\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;UserProfile\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\rList.vue\n\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;用户列表\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;UserList\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\r修改views/Main.vue\nviews/Main.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;el-container\u0026gt;\r\u0026lt;el-aside width=\u0026quot;200px\u0026quot;\u0026gt;\r\u0026lt;el-menu :default-openeds=\u0026quot;['1']\u0026quot;\u0026gt;\r\u0026lt;el-submenu index=\u0026quot;1\u0026quot;\u0026gt;\r\u0026lt;template slot=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;el-icon-caret-right\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;用户管理\u0026lt;/template\u0026gt;\r\u0026lt;el-menu-item-group\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;1-1\u0026quot;\u0026gt;\r\u0026lt;!--插入的地方--\u0026gt;\r\u0026lt;router-link to=\u0026quot;/user/profile\u0026quot;\u0026gt;个人信息\u0026lt;/router-link\u0026gt;\r\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;1-2\u0026quot;\u0026gt;\r\u0026lt;!--插入的地方--\u0026gt;\r\u0026lt;router-link to=\u0026quot;/user/list\u0026quot;\u0026gt;用户列表\u0026lt;/router-link\u0026gt;\r\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;/el-menu-item-group\u0026gt;\r\u0026lt;/el-submenu\u0026gt;\r\u0026lt;el-submenu index=\u0026quot;2\u0026quot;\u0026gt;\r\u0026lt;template slot=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;el-icon-caret-right\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;内容管理\u0026lt;/template\u0026gt;\r\u0026lt;el-menu-item-group\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;2-1\u0026quot;\u0026gt;分类管理\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;2-2\u0026quot;\u0026gt;内容列表\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;/el-menu-item-group\u0026gt;\r\u0026lt;/el-submenu\u0026gt;\r\u0026lt;/el-menu\u0026gt;\r\u0026lt;/el-aside\u0026gt;\r\u0026lt;el-container\u0026gt;\r\u0026lt;el-header style=\u0026quot;text-align: right; font-size: 12px\u0026quot;\u0026gt;\r\u0026lt;el-dropdown\u0026gt;\r\u0026lt;i class=\u0026quot;el-icon-setting\u0026quot; style=\u0026quot;margin-right: 15px\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;el-dropdown-menu slot=\u0026quot;dropdown\u0026quot;\u0026gt;\r\u0026lt;el-dropdown-item\u0026gt;个人信息\u0026lt;/el-dropdown-item\u0026gt;\r\u0026lt;el-dropdown-item\u0026gt;退出登录\u0026lt;/el-dropdown-item\u0026gt;\r\u0026lt;/el-dropdown-menu\u0026gt;\r\u0026lt;/el-dropdown\u0026gt;\r\u0026lt;/el-header\u0026gt;\r\u0026lt;el-main\u0026gt;\r\u0026lt;!--在这里展示视图--\u0026gt;\r\u0026lt;router-view /\u0026gt;\r\u0026lt;/el-main\u0026gt;\r\u0026lt;/el-container\u0026gt;\r\u0026lt;/el-container\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Main\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r.el-header {\rbackground-color: #B3C0D1;\rcolor: #333;\rline-height: 60px;\r}\r.el-aside {\rcolor: #333;\r}\r\u0026lt;/style\u0026gt;\r修改router/index.js\nimport Vue from 'vue';\rimport Router from \u0026quot;vue-router\u0026quot;;\rimport Main from \u0026quot;../views/Main\u0026quot;;\rimport Login from \u0026quot;../views/Login\u0026quot;;\rimport UserList from '../views/user/List';\rimport UserProfile from '../views/user/Profile';\r// 安装路由\rVue.use(Router);\r// 配置导出路由\rexport default new Router({\rroutes: [\r{\rpath: '/main',\rcomponent: Main,\r// 嵌套路由\rchildren: [\r{path: '/user/list', component: UserList},\r{path: '/user/profile', component: UserProfile }\r]\r},\r{\rpath: '/login',\rcomponent: Login,\r}\r]\r});\r最后，npm run dev 查看\n参数传递与重定向 修改views/Main.vue，将个人信息的路由链接的路径修改，使用:to来绑定路径和参数，用一个对象来表达，例如{name: '命名路径', parmas: {参数名: 值}}\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;el-container\u0026gt;\r\u0026lt;el-aside width=\u0026quot;200px\u0026quot;\u0026gt;\r\u0026lt;el-menu :default-openeds=\u0026quot;['1']\u0026quot;\u0026gt;\r\u0026lt;el-submenu index=\u0026quot;1\u0026quot;\u0026gt;\r\u0026lt;template slot=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;el-icon-caret-right\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;用户管理\u0026lt;/template\u0026gt;\r\u0026lt;el-menu-item-group\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;1-1\u0026quot;\u0026gt;\r\u0026lt;!--参数传递--\u0026gt;\r\u0026lt;router-link :to=\u0026quot;{name: 'UserProfile', params:{id: id}}\u0026quot;\u0026gt;个人信息\u0026lt;/router-link\u0026gt;\r\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;1-2\u0026quot;\u0026gt;\r\u0026lt;router-link to=\u0026quot;/user/list\u0026quot;\u0026gt;用户列表\u0026lt;/router-link\u0026gt;\r\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;1-3\u0026quot;\u0026gt;\r\u0026lt;!--重定向--\u0026gt;\r\u0026lt;router-link to=\u0026quot;/goHome\u0026quot;\u0026gt;回到主页\u0026lt;/router-link\u0026gt;\r\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;/el-menu-item-group\u0026gt;\r\u0026lt;/el-submenu\u0026gt;\r\u0026lt;el-submenu index=\u0026quot;2\u0026quot;\u0026gt;\r\u0026lt;template slot=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;el-icon-caret-right\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;内容管理\u0026lt;/template\u0026gt;\r\u0026lt;el-menu-item-group\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;2-1\u0026quot;\u0026gt;分类管理\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;el-menu-item index=\u0026quot;2-2\u0026quot;\u0026gt;内容列表\u0026lt;/el-menu-item\u0026gt;\r\u0026lt;/el-menu-item-group\u0026gt;\r\u0026lt;/el-submenu\u0026gt;\r\u0026lt;/el-menu\u0026gt;\r\u0026lt;/el-aside\u0026gt;\r\u0026lt;el-container\u0026gt;\r\u0026lt;el-header style=\u0026quot;text-align: right; font-size: 12px\u0026quot;\u0026gt;\r\u0026lt;el-dropdown\u0026gt;\r\u0026lt;i class=\u0026quot;el-icon-setting\u0026quot; style=\u0026quot;margin-right: 15px\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\r\u0026lt;el-dropdown-menu slot=\u0026quot;dropdown\u0026quot;\u0026gt;\r\u0026lt;el-dropdown-item\u0026gt;个人信息\u0026lt;/el-dropdown-item\u0026gt;\r\u0026lt;el-dropdown-item\u0026gt;退出登录\u0026lt;/el-dropdown-item\u0026gt;\r\u0026lt;/el-dropdown-menu\u0026gt;\r\u0026lt;/el-dropdown\u0026gt;\r\u0026lt;/el-header\u0026gt;\r\u0026lt;el-main\u0026gt;\r\u0026lt;!--在这里展示视图--\u0026gt;\r\u0026lt;router-view /\u0026gt;\r\u0026lt;/el-main\u0026gt;\r\u0026lt;/el-container\u0026gt;\r\u0026lt;/el-container\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;Main\u0026quot;,\rdata() {\rreturn {id:1}\r}\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r.el-header {\rbackground-color: #B3C0D1;\rcolor: #333;\rline-height: 60px;\r}\r.el-aside {\rcolor: #333;\r}\r\u0026lt;/style\u0026gt;\r在此还需要修改router/index.js，给对于组件UserProfile的路由命名。允许使用props来解耦视图与数据。这里还举例重定向的例子('/goHome')\nimport Vue from 'vue';\rimport Router from \u0026quot;vue-router\u0026quot;;\rimport Main from \u0026quot;../views/Main\u0026quot;;\rimport Login from \u0026quot;../views/Login\u0026quot;;\rimport UserList from '../views/user/List';\rimport UserProfile from '../views/user/Profile';\r// 安装路由\rVue.use(Router);\r// 配置导出路由\rexport default new Router({\rroutes: [\r{\rpath: '/main',\rcomponent: Main,\rchildren: [\r{path: '/user/list', component: UserList},\r{path: '/user/profile/:id',name: 'UserProfile',component: UserProfile, props: true }\r]\r},\r{\rpath: '/login',\rcomponent: Login,\r},\r{\rpath: '/goHome',\rredirect: '/main'\r}\r]\r});\r修改views/UserProfile.vue，在template标签下，用一个div标签包含之前的h2，在其下面，嵌入{{id}}，还有组件新添属性props。\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;个人信息\u0026lt;/h2\u0026gt;\r{{id}}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: ['id'],\rname: \u0026quot;UserProfile\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\r404和路由钩子 编写404视图组件views/NotFound.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r404，页面丢失了\r\u0026lt;hr\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: \u0026quot;NotFound\u0026quot;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\r在 router/index.js 加写NotFound组件的路由。路径属性用'*'匹配。路由模式有两种：一是默认的hash，url带有'#'；二是history，不带'#'\nimport Vue from 'vue';\rimport Router from \u0026quot;vue-router\u0026quot;;\rimport Main from \u0026quot;../views/Main\u0026quot;;\rimport Login from \u0026quot;../views/Login\u0026quot;;\rimport UserList from '../views/user/List';\rimport UserProfile from '../views/user/Profile';\rimport NotFound from '../views/NotFound';\r// 安装路由\rVue.use(Router);\r// 配置导出路由\rexport default new Router({\rmode: 'history',\rroutes: [\r{\rpath: '/main/:name',\rcomponent: Main,\rprops: true,\rchildren: [\r{path: '/user/list', component: UserList},\r{path: '/user/profile/:id',name: 'UserProfile',component: UserProfile, props: true }\r]\r},\r{\rpath: '/login',\rcomponent: Login,\r},\r{\rpath: '/goHome',\rredirect: '/main'\r},\r{\rpath: '*',\rcomponent: NotFound\r}\r]\r});\r路由钩子重点看beforeRouteEnter和beforeRouteLeave\n在组件Profile添加路由钩子\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;个人信息\u0026lt;/h2\u0026gt;\r{{id}}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: ['id'],\rname: \u0026quot;UserProfile\u0026quot;,\rbeforeRouteEnter: function(to, from, next) {\rconsole.log('进入路由前');\rnext();\r},\rbeforeRouteLeave: function(to, from, next) {\rconsole.log('进入路由后');\rnext();\r}\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\r\u0026lt;/style\u0026gt;\r钩子函数默认带有三个参数 (to, from, next)。还有next方法来解析此钩子。\n  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。\n  next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。\n  next('/') 或者 next({ path: \u0026lsquo;/\u0026rsquo; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: \u0026lsquo;home\u0026rsquo; 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。\n  next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。\n  next(function): 可以通过传一个回调给 next 来访问组件实例，例如 next(vm=\u0026gt;{// 通过vm访问组件})\n  在路由钩子中发送ajax请求\n首先安装axios插件\nsudo npm install vue-axios axios --save\r在main.js配置导入axios\nimport Vue from 'vue';\rimport axios from 'axios';\rimport VueAxios from 'vue-axios';\rVue.use(VueAxios, axios);\r改写beforeRouteEnter方法\nexport default {\rprops: ['id'],\rname: \u0026quot;UserProfile\u0026quot;,\rbeforeRouteEnter: function(to, from, next) {\rconsole.log('进入路由前');\rnext(vm=\u0026gt;{\rvm.getData();\r});\r},\rbeforeRouteLeave: function(to, from, next) {\rconsole.log('进入路由后');\rnext();\r},\rmethods: {\rgetData: function() {\rthis.axios({\rmethod: \u0026quot;GET\u0026quot;,\rurl: \u0026quot;/static/mock/data.json\u0026quot;\r}).then(function(response) {\rconsole.log(response);\r});\r}\r}\r}\r更多资源  Vue官网 Axios文档 Vue-CLI文档 Vue-Router文档 ElementUI文档  ","description":"Vue入门学习","id":11,"section":"posts","tags":["vue"],"title":"Vue.js入门","uri":"https://qinry.github.io/posts/2021/09/vue-js/"},{"content":"概述 数据库（database） 保存有组织的数据的容器（通常是一个或一组文件）\n数据库管理系统（DBMS，Database Management System） 一种软件，创建和操控数据库\n表（table） 某种特定类型数据的结构化清单。表名相对于同一个数据库唯一，但不同的数据库中可以使用相同的表名。\n模式（schema） 关于数据库和表的布局及特性信息。\n列（column） 表中的一个字段。所有表都是由一个列或多个列组成。每个列都有相应的数据类型\n数据类型（datatype） 所容许的数据的类型。每个列对应的数据类型来限制，该列存储的数据。比如有 int、varchar、datatime、double等（重点）\n行（row） 表中的一个记录\n主键（primary key） 一列中或一组列，其值唯一区分表中的每一个行。\n定义主键方便只涉及相关行的操作。\n任意两行主键值不相同。每行的主键不能为空（NULL）。\n建议不更新主键列的值，不主键列的值，不把经常需要修改的列设置主键列，例如什么什么的名称\nSQL（Structured Query Language） 专门用于与数据库通信的语言\n数据库分类：\n 关系型数据库 （SQL）  MySQL、Oracle、SQL Server、DB2、SQLite\n 非关系型数据库 （NoSQL， Not Only SQL）  Redis、MongoDB\nMySQL版本  4 InnoDB引擎，事务处理，并，改进全文本搜索 4.1 对函数库、子查询、集成帮助等的重要增加 5 存储过程、触发器、游标、视图等等  基本命令行 连接\nmysql -u 用户名 -p口令 -h 主机名 -P 对口号\rmysql -u root -proot -h 127.0.0.1 -P 3306\r选择数据库\nUSE `数据库名`;\rUSE `crashcourse`;\r了解数据库和表\nSHOW DATABASES; -- 返回可用数据库的一个列表\rSHOW TABLES; -- 返回当前选择的数据库内可用表的列表\rSHOW COLUMNS FROM 表名; -- 返回字段描述信息\rDESCRIBE 表名; -- 上一行的快捷方式\rSHOW STATUS; -- 用于显示广泛的服务器状态信息\rSHOW CREATE DATABASE 数据库名; -- 显示创建特定数据库的MySQL语句\rSHOW CREATE TABLE 表名; -- 显示创建特定表的MySQL语句\rSHOW GRANTS FOR 用户名; -- 用来显示授予用户的安全权限\rSHOW ERRORS; -- 用来显示服务器错误\rSHOW WARNINGS; -- 用来显示服务器警告信息\r退出连接\nexit;\rSQL命令类型  DDL（Data Definition Language） 数据库定义语言  create|drop|alter|truncate|comment|rename\n DML（Data Manipulation Language）数据库操作语言  insert|update|delete\n DQL（Data query Language） 数据库查询语言  select\n DCL（Data Control Language） 数据库控制语言  grant|revoke\n TCL（Transaction Control Language） 事务控制语言  commit|rollback|savepoint|set transaction\n操作数据库 创建数据库\nCREATE DATABASE [IF NOT EXISTS] `数据库名`;\rCREATE DATABASE IF NOT EXISTS `crashcourse`;\r删除数据库\nDROP DATABASE [IF EXISTS] `数据库名`;\rDROP DATABASE IF NOT EXISTS `crashcourse`;\r 注意 ：操作或创建数据库的表时，要先选择数据库。\n 数据类型 串数据类型  char 字符数固定大小的 长度0～255 存储方式：数据 varchar 字符数可变字符串 长度0~65535 存储方式：长度前缀+数据 tinytext 微型变长文本 长度0～2^8-1 text 变长文本串 长度0～2^16-1  数值类型  tinyint 十分小的整数 大小1B smallint 较小的整数 大小2B mediumint 中等大小整数 大小3B int 标准整数 大小4B bigint 较大整数 大小8B float 单精度浮点 大小4B double 双精度浮点 大小8B decimal 精度可变的浮点数 金融计算使用decimal(p, d) p：有效数字的字数 d：小数点后位数。  时间日期类型  date YYYY-mm-dd time HH:MM:SS datetime YYYY-mm-dd HH:MM:SS timestamp 时间戳 Year 年  NULL 没有值，未知。\n不建议使用NULL进行==运算\n数据库字段属性  UNSIGNED 无符号整数 不可填充负数 ZEROFILL 0填充 不足位数用0填充 AUTO_INCREMENT 自增 在上条记录基础上加1 必须整数类型 可设置起始值和步长值 NOT NULL|NULL 允许非空或空 DEFAULT 默认值  数据库表固定的几个样板字段\n id 主键 version 乐观锁 is_delete 伪删除 gmt_create 创建时间 gmt_update 更新时间  建立表 例如建立学生表：\n   字段 类型     学号id int(4)   密码pwd varchar(20)   姓名name varchar(3)   性别gender varchar(2)   出生日期birth datetime   家庭住址address varchar(100)   电子邮箱email varchar(50)    CREATE TABLE IF NOT EXISTS `student` (\r`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\r`name` VARCHAR(3) NOT NULL DEFAULT '匿名' COMMENT '姓名',\r`pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码',\r`gender` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别',\r`birth` DATETIME DEFAULT NULL COMMENT '出生日期',\r`address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址',\r`email` VARCHAR(50) DEFAULT NULL COMMENT '电子邮箱',\rPRIMARY KEY(`id`)\r) ENGINE=INNODB DEFAULT CHARSET=UTF8;\r输出：\n OK, Time: 0.022000s\n 格式：\nCREATE TABLE [IF NOT EXISTS] 表名 (\r`字段名` 数据类型 [属性] [索引] [注释],\r`字段名` 数据类型 [属性] [索引] [注释],\r...\r`字段名` 数据类型 [属性] [索引] [注释]\r)[存储引擎][字符集设置][注释]\rINNODB与MYISAM 区别：\n    MYISAM INNODB     事务支持 不支持 支持   数据行锁定 不支持，但支持表锁 支持   外键约束 不支持 支持   全文搜索 支持 不支持   表空间大小 较小 较大，约为MYISAM的两倍    优点：\n MYISAM 节约空间，速度快 INNODB 安全性高，事务处理，多表多用户操作  数据库文件存放位置 在Linux操作系统，mysql数据目录在/var/lib/mysql下（docker的mysql默认的位置）。\nWindow可能在mysql家目录的data目录下（据实际情况而定）。\nMac在/usr/local/var/mysql中（brew安装的话）。\n一个文件夹对应数据库，如下：\nMySQL存储引擎在文件上的区别：\n INNODB在数据库tests文件夹中只有*.frm文件，上级目录的ibdata1数据文件 MYISAM在数据库tests文件夹中有：  *.frm 表结构定义文件 *.MYD 数据文件 *.MYI 索引文件    更新表 完全限定表名：`数据库`.`表`\n修改表名\n\u0008ALTER TABLE `旧表名` RENAME AS `新表名`;\rALTER TABLE `student` RENAME AS `stu`;\rRENAME TABLE `旧表名` TO `新表名`;\rRENAME TABLE `student` TO `stu`;\r新增字段\nALTER TABLE `表名` ADD `字段名` 数据类型 属性;\rALTER TABLE `student` ADD `gradeId` INT(11) NOT NULL COMMENT '班级';\r修改字段(重命名，约束)\nchange 字段名、数据类型、属性都能修改\nmodify 除了字段名不能更改和change一样\nALTER TABLE `表名` CHANGE `旧字段名` `新字段名` 数据类型;\rALTER TABLE `student` CHANGE `name` `stuName` VARCHAR(10) NOT NULL DEFAULT '匿名' COMMENT '学生姓名';\rALTER TABLE `表名` MODIFY `字段名` 新数据类型 属性;\rALTER TABLE `student` MODIFY `stuName` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '学生姓名';\r删除字段\nALTER TABLE `表名` DROP `字段名`;\r删除表 DROP TABLE [IF EXISTS] `表名`;\r数据管理 外键 CREATE TABLE IF NOT EXISTS `grade` (\r`gradeId` INT(11) NOT NULL AUTO_INCREMENT,\r`gradeName` VARCHAR(10) NOT NULL DEFAULT '未知',\rPRIMARY KEY(`gradeId`)\r)ENGINE=INNODB DEFAULT CHARSET=utf8\rALTER TABLE `表名` ADD CONSTRAINT `约束名` FOREIGN KEY(`外键名`) REFERENCES `引用表名`(`关联外键的字段名`);\rALTER TABLE `student` ADD CONSTRAINT `fk_student_grade` FOREIGN KEY(`gradeId`) REFERENCES `grade`(`gradeId`);\r已经不建议使用物理外键，以后可以使用程序实现逻辑外键，代码更易维护。\n新增 INSERT INTO `表名`[(字段1,字段2,字段N)] VALUES (值1,值2,值N) [,(值1,值2,值N)];\rINSERT INTO `grade`(`gradeName`) VALUES('一年级'),('二年级'),('三年级');\rINSERT INTO `student` VALUES(NULL,'张三','123456','男','1999-08-08','广东广州','zhangsan@163.com',1), (NULL,'李四','123456','男','1999-08-08','广东广州','lisi@163.com',2),\r(NULL,'王二','123456','男','1999-08-08','广东广州','wanger@163.com',3);\r 注意：若字段省略，VALUES之后的值和顺序必须与表一一对应\n 更新 UPDATE `表名` SET `字段1`=值1,`字段2`=值2,`字段N`=值N WHERE 条件；\rUPDATE `student` SET `stuName`='张三三',`stuEmail`='zhangsansan@163.com' WHERE `stuId`=1;\rWHERE子句在SELECT详细说明，用于过滤数据，这里表示选择stuId为1的行，进行更新stuName和stuEmail字段。\n删除 DELETE FROM `表名` WHERE 条件;\rDELETE FROM `student` WHERE `stuId`=3;\rTRUNCATE `表名`;\rTRUNCATE `grade`;\rTRUNCATE是删除表，再重新建立之前空行的表，理解为清理表。它和DELETE不同在于它会重置AUTO_INCREMENT计数。\n一般业务中不会物理删除，会使用伪删除。\n查询 SELECT\r[ALL | DISTINCT | DISTINCTROW ]\r[HIGH_PRIORITY]\r[STRAIGHT_JOIN]\r[SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]\r[SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]\rselect_expr [, select_expr] ...\r[into_option]\r[FROM table_references\r[PARTITION partition_list]]\r[WHERE where_condition]\r[GROUP BY {col_name | expr | position}\r[ASC | DESC], ... [WITH ROLLUP]]\r[HAVING where_condition]\r[ORDER BY {col_name | expr | position}\r[ASC | DESC], ...]\r[LIMIT {[offset,] row_count | row_count OFFSET offset}]\r[PROCEDURE procedure_name(argument_list)]\r[into_option]\r[FOR UPDATE | LOCK IN SHARE MODE]\rinto_option: {\rINTO OUTFILE 'file_name'\r[CHARACTER SET charset_name]\rexport_options\r| INTO DUMPFILE 'file_name'\r| INTO var_name [, var_name] ...\r}\r基本查询 SELECT `字段1`,`字段2`,`字段N` FROM `表名`;\rSELECT VERSION(); -- 版本号\rSELECT LAST_INSERT_ID(); -- 返回最后插入的AUTO_INCREMENT的值\rSELECT UUID(); -- 生成随机的UUID值\rSELECT @@AUTO_INCREMENT_INCREMENT; -- 自增步长\rSELECT NOW(); -- 当前日期时间\rSELECT CURRENT_DATE; -- 当前日期\rSELECT CURRENT_TIME; -- 当前时间\r去重数据 SELECT DISTINCT `字段1`,`字段2`,`字段N` FORM `表名`;\r分页查询 SELECT `字段1`,`字段2`,`字段N` FORM `表名` LIMIT 行数;\rSELECT `字段1`,`字段2`,`字段N` FORM `表名` LIMIT 起始偏移, 行数;\r排序数据 SELECT `字段1`,`字段2`,`字段N` FROM `表名` ORDER BY `字段a` [DESC|ASC] [ ,`字段b` [DESC|ASC],`字段z` [DESC|ASc] ];\r过滤数据 WHERE子句操作符 WHERE 字段 操作符 值\nWHERE 条件a 逻辑操作符(AND或OR) 条件b\nWHERE NOT 条件\nWHERE 字段 IS NULL\nWHERE 字段 IS NOT NULL\n   操作符 含义     = 等于   != 不等于   \u0026lt;\u0026gt; 不等于   \u0026lt; 小于   \u0026lt;= 小等于   \u0026gt; 大于   \u0026gt;= 大等于   BETWEEN a AND b 指定a，b值之间   IN (a,b,z) 在指定括号内值的范围   NOT 逻辑否   AND 逻辑与   OR 逻辑或     注意：逻辑运算执行顺序 NOT \u0026gt; AND \u0026gt; OR。使用圆括号()，优先执行。\n SELECT * FROM `student` WHERE `stuId`=1;\rSELECT * FROM `student` WHERE `stuName`='张三';\rSELECT * FROM `student` WHERE `stuId`!=1;\rSELECT * FROM `student` WHERE `stuId`\u0026lt;\u0026gt;=1;\rSELECT * FROM `student` WHERE `stuId`\u0026lt;3;\rSELECT * FROM `student` WHERE `stuId`\u0026lt;=3;\rSELECT * FROM `student` WHERE `stuId`\u0026gt;3;\rSELECT * FROM `student` WHERE `stuId`\u0026gt;=3;\rSELECT * FROM `student` WHERE `stuId` BETWEEN ;\r模糊查询 SELECT `字段1`,`字段2`,`字段N` FROM `表名` WHERE `字段` LIKE '%值%';\r计算字段 拼接字段 CONCAT(a,b)\r起别名 `原字段名` AS `字段别名`\rSELECT CONCAT(TRIM(`stuId`),TRIM(`stuName`)) AS `title` FROM `student`;\rTRIM函数去掉串两边空格\n表达式 SELECT 表达式;\rSELECT 100*3-1 AS `result`;\r常用函数 文本处理函数    函数 含义     Left(str,len) 返回串左边的字符   Right(str,len) 返回串右边的字符   Length(str) 返回串左边的字符   Locate(substr,str) 找出串中的子串   Lower(str) 将串转换为小写   Upper(str) 将串转换为大写   Ltrim(str) 去掉串左空格   Rtrim(str) 去掉串右空格   Rtrim(str) 去掉串左右空格   Soundex(str) 返回串的SOUNDEX值   SubString(str FROM pos) 返回子串的字符   MD5(str) 返回字符串MD5值    日期和时间处理函数 几个关键字：CURRENT_DATE、CURRENT_TIME分别表示当前的日期和时间\n   函数 含义     AddDate(date, INTERVAL expr unit) 增加一个日期（天、周等）   AddTime(time, expr) 增加一个时间（时、分等）   CurDate() 返回当前日期   CurTime() 返回当前时间   Date(expr) 返回日期时间的日期部分   Time(expr) 返回日期时间的时间部分   Now() 返回当前日期和时间   DateDiff(expr1,expr2) 返回当前日期之差（expr1-expr2）   Date_Add(date,INTERVAL expr unit) 高度灵活的日期运算函数（加减）   Date_Format(date,format) 返回格式化的日期或时间串   Day(date) 返回一个日期的天数部分   Month(date) 返回一个日期的月数部分   Year(date) 返回一个日期的年数部分   DayOfWeek(date) 对于一个日期，返回对应的星期几（1周日 2周一 \u0026hellip;）   Hour(time) 返回时间的小时部分   Minute(time) 返回时间的分钟部分   Second(time) 返回时间的秒部分    数值处理函数    函数 含义     Abs(x) 返回一个数的绝对值   Cos(x) 返回一个弧度的余弦   Exp(x) 返回一个自然对数的指数值   Mod(n,m) 返回除操作的余数   Pi() 返回圆周率   Rand() 返回一个随机数   Sin(x) 返回一个弧度的正弦   Sqrt(x) 返回一个数的平方   Tan(x) 返回一个弧度的正切    聚合函数 聚集函数 运行在行组上，计算和返回单个值的函数\n   函数 含义     AVG([DISTINCT] expr) 返回某列的平均值   COUNT(DISTINCT [expr][,expr]) 返回某列符合表达式条件的行数   MAX([DISTINCT] expr) 返回某列的最大值   MIN([DISTINCT] expr) 返回某列的最小值   SUM([DISTINCT]expr) 返回某列值之和     重点看COUNT函数。COUNT(*) 对所有表进行计数，不管是列中包含的是空值还是非空值。但COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。所以COUNT(NULL)为0。\n 分组过滤 SELECT `字段1`,`字段2`,`字段N` FROM `表名` GROUP BY `列中字段` HAVING 条件;\rSELECT `stuId`, `stuName`,`stuGender` FROM `student` GROUP BY `stuGender`,`stuId`, `stuName` HAVING `stuId` \u0026gt; 1;\r 注意：\n1.GROUP BY 子句可以包含任意数目的列；\n  2.GROUP BY 子句不能使用聚合函数；\n  3.SELECT中出现的所有列和表达式，也在GROUP BY 中出现，但不使用别名；\n  4.若分组列中具有NULL值，则NULL将作为一个分组返回。若是多行NULL，它们将分成一组；\n  5.GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前；\n  6.在建立分组时，指定的所有列都一起计算，所以不能从个别的列取回数据。\n  7.如果检索列和聚合函数在SELECT中一起使用，GROUP BY 必须使用。\n  HAVING支持所有WHERE子句中的条件，它们句法相同，一个用于分组前的过滤行，一个分组后的过滤分组\n 子查询 子查询 SELECT语句中嵌套了其他的SELECT查询。子查询由内向外处理。\n 子查询过滤（常用且灵活） 子查询计算字段  子查询过滤 查询学生id为3的年级名称。\nSELECT `gradeName`\rFROM `grade`\rWHERE `gradeId` IN (SELECT `gradeId` FROM `student`\rWHERE `stuId`=3);\rWHERE 子句的列和SELECT 语句中列必须匹配，即具有相同数目的列。\n子查询计算字段 查询各个年级的学生数量。\nSELECT `gradeName`, (SELECT COUNT(*)\rFROM `student` WHERE `student`.`gradeId` = `grade`.`gradeId` ) AS count FROM `grade`\rORDER BY `gradeName`;\r级联查询  内部联结 外部联结  内部联结 基于两个表之间相等测试的联结。故又称等值联结。排除相同的列多次出现，则成为自然联结。特殊地，当两张表为同一张表，就成为自联结。\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rINNER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`;\rSELECT `student`.*,`grade`.`gradeName`\rFROM `student`,`grade`\rWHERE `student`.`gradeId` = `grade`.`gradeId`;\r外部联结 外部联结包含那些在相关表中没有关联行的行。\n 左外联结 右外联结  左外联结 包含了交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rLEFT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`;\r不包含了交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rLEFT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`\rWHERE `grade`.`gradeId` IS NULL;\r右外联结 包含了交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rRIGHT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`;\r不包含了交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rRIGHT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`\rWHERE `student`.`gradeId` IS NULL;\r 注意：联结非常消耗性能，联结的表越多，性能下降越快，不要联结不必要的表\n 组合查询 多个SELECT结果合并\n全联结包含交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rLEFT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`\rUNION\rSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rRIGHT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`;\r全联结不包含交集部分\nSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rLEFT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`\rWHERE `grade`.`gradeId` IS NULL\rUNION\rSELECT `student`.*,`grade`.`gradeName`\rFROM `student`\rRIGHT OUTER JOIN `grade`\rON `student`.`gradeId` = `grade`.`gradeId`\rWHERE `student`.`gradeId` IS NULL;\r事务与SQL优化 见MySQL事务与SQL优化回顾。\n索引 MySQL官方定义：帮助MySQL高效获取数据的数据结构，就是索引。\n其底层的数据结构是B+树。\n分类：\n 主键索引 （PRIMARY KEY）  唯一标识，主键列值不可重复，主键只能有一个，不可多个   唯一索引 （UNIQUE KEY）  避免重复的列值出现，唯一索引可以有多个   常规索引 （KEY｜INDEX）  默认的   全文索引 （FULLTEXT INDEX）  MYISAM 特有，用于快速定位和搜索    建表时增加索引\nCREATE TABLE `表名` (\r`属性1` 数据类型,\r`属性2` 数据类型,\r`属性3` 数据类型,\rPRIMARY KEY(`属性1`)\rUNIQUE KEY `属性2` (`属性2`),\rKEY `属性3` (`属性3`)\r) ENGINE=INNODB;\rCREATE TABLE `表名` (\r`属性1` 数据类型,\r`属性2` 数据类型,\r`属性3` 数据类型,\rFULLTEXT(`属性1`)\r) ENGINE=MYISAM;\r建表后增加索引\nALTER TABLE `表名` ADD FULLTEXT INDEX `属性1` (`属性1`);\r索引搜索\nSELECT `属性` FROM `表名` WHERE MATCH(`属性1`) AGAINST('值');\r索引其他命令 # 显示所有索引信息\rSHOW INDEX FROM `表名`;\r# 分析SQL语句执行状况 比如查询所需记录的行数\rEXPLAIN SQL语句;\r建议：\n 索引不是越多越好 不对变动大数据加索引 数据量小的表不加索引 索引一般加在常用查询的字段上  用户权限管理 新建一个用户\nCREATE USER `用户名` IDENTIFIED BY '密码';\r更改用户密码\nALTER USER `用户名` IDENTIFIED BY '密码';\r重命名\nRENAME USER `原名` TO `新名`\r用户授权\nGRANT 权限 ON `库名`.`表名` TO `用户`;\r权限有SELECT、INSERT、UPDATE、DELETE等等，ALL PRIVILEGES 表示除了GRANT的所有权限。\n权限撤销\nREVOKE 权限 ON `库名`.`表名` FROM `用户`;\rMySQL备份 保证重要数据不丢失，方便数据转移\n# mysqldump -h 主机 -u 用户 -p 密码 库名 表名 \u0026gt; 文件名\rmysqldump -h localhost -uroot -p123456 crashcourse student \u0026gt; data.sql\r# mysqldump -h 主机 -u 用户 -p 密码 库名 表名1 表名2 表名N \u0026gt; 文件名\rmysqldump -h localhost -uroot -p123456 crashcourse student teacher \u0026gt; data.sql\r# mysqldump -h 主机 -u 用户 -p 密码 库名 \u0026gt; 文件名\rmysqldump -h localhost -uroot -p123456 crashcourse \u0026gt; data.sql\r导入\n先登录数据库后\nUSE `crashcourse`;\rSOURCE /path/to/data.sql\r如何设计数据库 软件开发中数据库设计\n 分析需求：分析业务和需求处理的数据库的需求 概要设计：设计关系E-R图  设计数据库的步骤\n 收集信息，分析需求  要创建哪些表，表里有哪些需求   标识实体  把需求落实到字段   标识实体的关系  有一对一，多对多，一对多    数据库的三大范式 防止信息重复，减少数据冗余，防止异常。\n 第一范式（1NF）要求数据库的每一列都是不可在分割的原子数据项 第二范式（2NF）前提满足第一范式，确保数据库的每一列依赖于主键列（每张表只描述一件事） 第三范式（3NF）前提满足第一第二范式，确保数据库每列数据都和主键直接相关，不能间接相关  规范性和性能的问题 根据阿里规范，关联查询建议不超过3张表\n 考虑商业化的需求和目标，数据库性能更加重要 在考虑完性能问题后，适当考虑规范性的问题 有时需要故意增加一些冗余的字段（方便将多表查询变为单表查询） 有时故意增加一些计算字段（将大数据降低为小数据量的查询：索引）  其他资源  MySQL 5.7 参考手册  ","description":"MySQL的SQL基础","id":12,"section":"posts","tags":["sql","mysql"],"title":"在MySQL学习SQL","uri":"https://qinry.github.io/posts/2021/08/mysql-sql-statement/"},{"content":"概述 CSS，即Cascading Style Sheets，中文意思层叠样式表。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。其实简单说就是美化HTML页面。\n美化的内容有：\n 字体 颜色 边距 背景图片 网页定位 网页浮动 等等   CSS版本\n  CSS1.0 基本的样式，如字体 CSS2.0 提出使用div和css来达到HTML与CSS结构分离的思想 CSS2.1 浮动 定位 \u0026hellip; CSS3.0 圆角 边框 动画 \u0026hellip;  导入方式  内联样式 内部样式 外部样式  内联样式 语法：\n在某个标签内设置style属性，key为某一样式名，value为对应样式的值。键值对要用分号结尾\nstyle=\u0026quot;key1:value1;key2:value2;keyN:valueN;\u0026quot;\r\u0026lt;!-- index.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2 style=\u0026quot;color:red;\u0026quot;\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r效果：\n内部样式 CSS语法：selector意为选择器，用于表示选择设置的HTML元素，然后大括号内部，以键值对逐行编写的格式设置元素的样式。\n内部样式表要写在style标签内。\n/* comment */\rselector {\rkey1:value1;\rkey2:value2;\rkeyN:valueN;\r}\r\u0026lt;!-- index.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\rh2 {\rcolor: green;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r效果：\n外部样式 外部样式表写css文件，通过link标签导入。\n/* css/style.css */\rh2 {\rcolor: blue;\r}\r\u0026lt;!-- index.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;css/style.css\u0026quot;\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r效果：\n优先级 一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：\n 千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。 百位： 选择器中包含ID选择器则该位得一分。 十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。 个位：选择器中包含元素、伪元素选择器则该位得一分。  css规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。\n 注: 通用选择器 (*)，组合符 (+, \u0026gt;, ~, )，和否定伪类 (:not) 不会影响优先级。\n  警告: 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。\n 例如：\n/* css/style.css */\rh2 {\rcolor: blue;\r}\r\u0026lt;head\u0026gt;\r...\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;css/style.css\u0026quot;\u0026gt;\r\u0026lt;style\u0026gt;\rh2 {\rcolor: green;\r}\r\u0026lt;/style\u0026gt;\r...\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;/body\u0026gt;\r这里内部样式表离目标元素近，也就是写在最后，所以优先渲染它。如果它们位置调转，则外部样式表优先。\n继承 一些设置在父元素上的css属性是可以被子元素继承的，有些则不能。\n举一个例子，如果你设置一个元素的 color 和 font-family ，每个在里面的元素也都会有相同的属性，除非你直接在元素上设置属性。\n一些属性是不能继承的 — 举个例子如果你在一个元素上设置 width 50% ，所有的后代不会是父元素的宽度的50% 。如果这个也可以继承的话，CSS就会很难使用了!\n像 widths (上面提到的), margins, padding, 和 borders 不会被继承。如果borders可以被继承，每个列表和列表项都会获得一个边框 — 可能就不是我们想要的结果!\n选择器 了解了CSS语法，接下来了解选择器有哪些。\n选择器的优先级 可先跳过，熟悉其他选择器，再回来。\n浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：\n 一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。 一个类选择器稍微具体点 — 它会选择该页面中有特定 class 属性值的元素 — 所以它的优先级就要高一点。  总之，越具体，优先级越高。\n基本选择器  元素选择器(type selector) id选择器(id selector) class选择器(class selector) 通配选择器(universal selector) 属性选择器(attribute selector)  元素选择器 也可以叫做，类型选择器\n按照给定的节点名称，选择所有匹配的元素。\n语法：elementname\nid选择器 按照 id 属性选择一个与之匹配的元素。需要注意的是，一个文档中，每个 ID 属性都应当是唯一的。\n语法：#idname\n例子：\nspan#identified {\rbackground-color: DodgerBlue;\r}\r\u0026lt;span id=\u0026quot;identified\u0026quot;\u0026gt;Here's a span with some text.\u0026lt;/span\u0026gt;\r\u0026lt;span\u0026gt;Here's another.\u0026lt;/span\u0026gt;\rclass选择器 按照给定的 class 属性的值，选择所有匹配的元素。class选择器能够跨标签设置样式，所以更好复用。\n语法：.classname\nspan.classy {\rbackground-color: DodgerBlue;\r}\r\u0026lt;span class=\u0026quot;classy\u0026quot;\u0026gt;Here's a span with some text.\u0026lt;/span\u0026gt;\r\u0026lt;span\u0026gt;Here's another.\u0026lt;/span\u0026gt;\r通配选择器 选择所有元素。\n语法：*\n例子：\n*[lang^=en]{color:green;}\r*.warning {color:red;}\r*#maincontent {border: 1px solid blue;}\r\u0026lt;p class=\u0026quot;warning\u0026quot;\u0026gt;\r\u0026lt;span lang=\u0026quot;en-us\u0026quot;\u0026gt;A green span\u0026lt;/span\u0026gt; in a red paragraph.\r\u0026lt;/p\u0026gt;\r\u0026lt;p id=\u0026quot;maincontent\u0026quot; lang=\u0026quot;en-gb\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;warning\u0026quot;\u0026gt;A red span\u0026lt;/span\u0026gt; in a green paragraph.\r\u0026lt;/p\u0026gt;\r效果：\n不推荐使用通配选择器,因为它是性能最低的一个CSS选择器。\n属性选择器 按照给定的属性，选择所有匹配的元素。\n语法：\n [attr] 表示带有以 attr 命名的属性的元素。 [attr=value] 表示带有以 attr 命名的属性，且属性值为 value 的元素。 [attr^=value] 表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。 [attr$=value] 表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。 [attr*=value] 表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。 [attr~=value] 表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。 [attr|=value] 表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（\u0026quot;-\u0026ldquo;为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。  例子：\n/* 存在title属性的\u0026lt;a\u0026gt; 元素 */\ra[title] {\rcolor: purple;\r}\r/* 存在href属性并且属性值匹配\u0026quot;https://example.org\u0026quot;的\u0026lt;a\u0026gt; 元素 */\ra[href=\u0026quot;https://example.org\u0026quot;] {\rcolor: green;\r}\r/* 存在href属性并且属性值包含\u0026quot;example\u0026quot;的\u0026lt;a\u0026gt; 元素 */\ra[href*=\u0026quot;example\u0026quot;] {\rfont-size: 2em;\r}\r/* 存在href属性并且属性值结尾是\u0026quot;.org\u0026quot;的\u0026lt;a\u0026gt; 元素 */\ra[href$=\u0026quot;.org\u0026quot;] {\rfont-style: italic;\r}\r/* 存在class属性并且属性值包含以空格分隔的\u0026quot;logo\u0026quot;的\u0026lt;a\u0026gt;元素 */\ra[class~=\u0026quot;logo\u0026quot;] {\rpadding: 2px;\r}\r分组选择器 选择器列表 CSS4草案更名为选择器列表，目前命名为分组选择器\n,是将不同的选择器组合在一起的方法，它选择所有能被列表中的任意一个选择器选中的节点。\n语法：selector1,selector2,selectorN\n层级选择器 也可以称作组合器\n 后代组合器(descendant combinator) 直接子代组合器(child combinator) 紧邻兄弟组合器(adjacent sibling combinator) 一般兄弟组合器(general sibling combinator)  后代组合器 （空格）组合器选择前一个元素的后代节点。\n语法：ancestor descendants\n直接子代组合器 \u0026gt; 组合器选择前一个元素的直接子代的节点。\n语法：parent \u0026gt; child\n紧邻兄弟组合器 + 组合器选择相邻元素，即后一个元素紧跟在前一个之后，并且共享同一个父节点。\n语法：previous + next\n一般兄弟组合器 ~ 组合器选择兄弟元素，也就是说，后一个节点在前一个节点后面的任意位置，并且共享同一个父节\n语法：previous ~ next\n伪类选择器 CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。\n语法：\nselector:pseudo-class {\rproperty: value;\r}\r例子：\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;树结构伪类选择器\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\rul li:first-child {\rbackground-color: red;\r}\rul li:last-child {\rbackground-color: green;\r}\rp:nth-child(2) {\rbackground-color: blue;\r}\rp:nth-of-type(3) {\rbackground-color: yellowgreen;\r}\ra:hover {\rbackground-color: black;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;a\u0026gt;123\u0026lt;/a\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;p\u0026gt;p1\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;p2\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;p3\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;p1\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;p2\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;p3\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;li1\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li2\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li3\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li4\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;li1\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li2\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li3\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;li4\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r效果：\n第一行的超链接，鼠标悬浮时，背景色变黑。\n常见树结构伪类选择器\n :first-child 某个元素的父元素的第一个子元素，只有当第一个子元素和其类型相同时，设置的样式才生效。等价于 :nth-child(1) :last-child 某个元素的父元素的最后一个子元素，只有当最后一个子元素和其类型相同时，设置的样式才生效 :nth-last-child(1) :nth-child(an+b|even|odd) an+b(n=0,1,2\u0026hellip;) a和b是系数。even代表偶数。odd代表奇数 :nth-of-type(an+b|even|odd) a和b是系数。even代表偶数。odd代表奇数  还有其他伪类选择器超过本章的内容范围，可参见 MDN Web Docs的Pseudo-classes一章\n美化网页元素 字体样式  字体族 font-family 字体大小 font-size 字体粗细 font-weight 字体颜色 color 字体风格 font-style  CSS\nbody {\rfont-family:'Times New Roman','楷体';\rcolor: #a17e32;\r}\rh2 {\rfont-size: 50px;\r}\r.p1 {\rfont-weight: bolder;\rfont-style: oblique;\r}\rHTML\n\u0026lt;h2\u0026gt;将进军\u0026lt;/h2\u0026gt;\r\u0026lt;p class=\u0026quot;p1\u0026quot;\u0026gt;君不见黄河之水天上来，奔流到海不复回。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;君不见高堂明镜悲白发，朝如青丝暮成雪。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;人生得意须尽欢，莫使金樽空对月。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;天生我材必有用，千金散尽还复来。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;烹羊宰牛且为乐，会须一饮三百杯。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;岑夫子，丹丘生，将进酒，杯莫停。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;与君歌一曲，请君为我倾耳听。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;钟鼓馔玉不足贵，但愿长醉不复醒。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;古来圣贤皆寂寞，惟有饮者留其名。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;陈王昔时宴平乐，斗酒十千恣欢谑。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;主人何为言少钱，径须沽取对君酌。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。\u0026lt;/p\u0026gt;\r效果：\n文本样式 用斜杠表示样式的多种值或多种表达\n 颜色 color:red/#FF0000/rgba(255,0,0,1); 对齐 text-align:left/right/center; 首行缩进 text-indent: 2em; 行高 line-height:300px; 单行文本垂直居中 height == line-height 装饰 text-decoration: underline/overline/line-through/none; 文本图片垂直对齐 vertical-align: middle/top/bottom;  CSS\nh2 {\rtext-align: center;\rcolor: rgba(255,0,0,0.5);\r}\rp {\rtext-align: left;\rcolor: brown;\r}\r.p1 {\rtext-indent: 2em; }\r.p3 {\rbackground-color: rgba(100, 219, 235, 0.5);\rheight:300px;\rline-height:300px;\rtext-decoration: underline;\r}\rimg,span {\rvertical-align: middle;\r}\rHTML\n\u0026lt;p\u0026gt;\r\u0026lt;img src=\u0026quot;resources/image/1.png\u0026quot; alt=\u0026quot;image\u0026quot; width=\u0026quot;144px\u0026quot; height=\u0026quot;90px\u0026quot;\u0026gt;\r\u0026lt;span\u0026gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026lt;/span\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;h2\u0026gt;将进军\u0026lt;/h2\u0026gt;\r\u0026lt;p class=\u0026quot;p1\u0026quot;\u0026gt;君不见黄河之水天上来，奔流到海不复回。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;君不见高堂明镜悲白发，朝如青丝暮成雪。\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;p3\u0026quot;\u0026gt;人生得意须尽欢，莫使金樽空对月。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;天生我材必有用，千金散尽还复来。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;烹羊宰牛且为乐，会须一饮三百杯。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;岑夫子，丹丘生，将进酒，杯莫停。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;与君歌一曲，请君为我倾耳听。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;钟鼓馔玉不足贵，但愿长醉不复醒。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;古来圣贤皆寂寞，惟有饮者留其名。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;陈王昔时宴平乐，斗酒十千恣欢谑。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;主人何为言少钱，径须沽取对君酌。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。\u0026lt;/p\u0026gt;\r效果：\n文本阴影和超链接伪类  文本阴影 text-shadow: brown 5px -5px 2px  CSS\n a {\rtext-decoration: none;\r}\r/* LVHA */\ra:link {\rcolor: yellow;\r}\ra:visited {\rcolor: brown;\r}\ra:hover {\rcolor: orange;\r}\ra:active {\rcolor:green;\r}\rp#price {\r/* 阴影颜色 水平偏移 垂直偏移 模糊半径 */\rtext-shadow: brown 5px -5px 2px;\r}\rHTML\n\u0026lt;p\u0026gt;\r\u0026lt;img src=\u0026quot;resources/image/3.png\u0026quot; alt=\u0026quot;image\u0026quot; width=\u0026quot;70px\u0026quot; height=\u0026quot;100px\u0026quot;\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;码出高效：Java开发手册\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;作者：孤尽老师\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p id=\u0026quot;price\u0026quot;\u0026gt;\r¥99\r\u0026lt;/p\u0026gt;\r效果\n列表样式  列表样式 list-style: none/circle/square/decimal/decimal/disc;  CSS\n#nav {\rwidth: 300px;\rbackground-color: #a0a0a0;\r}\rh2 {\rbackground-color: red; }\r/* ul li */\rul {\rbackground-color: #a0a0a0;\r}\rul li {\rlist-style:none;\r}\ra {\rtext-decoration: none;\rcolor: brown;\r}\ra:hover {\rcolor: orange;\r}\ra:active {\rcolor: green;\r}\rHTML\n\u0026lt;div id=\u0026quot;nav\u0026quot;\u0026gt;\r\u0026lt;h2 class=\u0026quot;title\u0026quot;\u0026gt;全部商品分类\u0026lt;/h2\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;图书\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;音像\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;数字商品\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家用电器\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;手机\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;数码\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;电脑\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;办公\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家居\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家装\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;厨具\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;个护化妆\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;服饰鞋帽\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;礼品箱包\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;钟表\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;珠宝\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;食品饮料\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;保健食品\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;彩票\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;旅行\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;充值\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;票务\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\r效果：\n背景图像及渐变  背景图像 background-image: url('path/to/image') 背景渐变 background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%)  背景图像\nCSS\ndiv {\rwidth: 700px;\rheight: 700px;\rborder: 1px solid red;\rbackground-image: url(\u0026quot;resources/image/6.jpeg\u0026quot;);\r}\r.div1 {\rbackground-repeat: repeat-x;\r}\r.div2 {\rbackground-repeat: repeat-y;\r}\r.div3 {\rbackground-repeat: no-repeat;\r}\rHTML\n\u0026lt;div class=\u0026quot;div1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;div2\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;div3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r效果：\nCSS\ndiv#nav {\rwidth: 300px;\rbackground-color: #a0a0a0;\r}\r.title {\rfont-size: 18px;\rfont-weight: bold;\rtext-indent: 1em;\rline-height: 35px;\rheight: 35px;\rbackground: red url('../resources/image/4.png') 270px 10px no-repeat;\r}\r/* ul li */\rul {\rbackground-color: #a0a0a0;\r}\rul li {\rlist-style:none;\rheight: 30px;\rbackground-image: url('../resources/image/5.png');\rbackground-repeat: no-repeat;\rbackground-position: 232px 5px;\r}\ra {\rfont-size: 14px; text-decoration: none;\rtext-indent: 1em;\rcolor: brown;\r}\ra:hover {\rcolor: orange;\rtext-decoration: underline;\r}\ra:active {\rcolor: green;\r}\rHTML\n\u0026lt;div id=\u0026quot;nav\u0026quot;\u0026gt;\r\u0026lt;h2 class=\u0026quot;title\u0026quot;\u0026gt;全部商品分类\u0026lt;/h2\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;图书\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;音像\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;数字商品\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家用电器\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;手机\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;数码\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;电脑\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;办公\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家居\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;家装\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;厨具\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;个护化妆\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;服饰鞋帽\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;礼品箱包\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;钟表\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;珠宝\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;食品饮料\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;保健食品\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;彩票\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;旅行\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;充值\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;票务\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\r效果：\n背景渐变\nCSS\nbody {\rbackground-color: #4158D0;\r/* 渐变轴 渐变的颜色列表 */\rbackground-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%)；\r}\r效果：\n盒子模型  margin 外边距 border 边框 padding 内边距 content 内容  边框  边框粗细 border-width: 1px; 边框样式 border-style: solid/dashed; 边框颜色 border-color: black;  CSS\nh2,ul,li,a,body {\rmargin: 0;\rpadding: 0;\rtext-decoration: none;\r}\rdiv#box {\rwidth: 300px;\rborder: 1px solid black; }\rh2 {\rfont-size: 16px;\rbackground-color: #3cbda6;\rline-height: 30px;\r}\rform {\rbackground-color: #3cbda6;\r}\rdiv:not(.box):nth-of-type(1) input {\rborder: 3px solid brown;\r}\rdiv:not(.box):nth-of-type(2) input {\rborder: 3px dashed orange;\r}\rdiv:not(.box):nth-of-type(3) input {\rborder: 3px dashed palegoldenrod;\r}\r\u0026lt;div id=\u0026quot;box\u0026quot;\u0026gt;\r\u0026lt;h2\u0026gt;会员登录\u0026lt;/h2\u0026gt;\r\u0026lt;form action=\u0026quot;#\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label for=\u0026quot;uname\u0026quot;\u0026gt;用户名：\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;uname\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label for=\u0026quot;pwd\u0026quot;\u0026gt;密码：\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;pwd\u0026quot; name=\u0026quot;pwd\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;label for=\u0026quot;email\u0026quot;\u0026gt;邮箱：\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;email\u0026quot; name=\u0026quot;email\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r内外边距及div居中 外边距 margin: top-right-bottom-left;\rmargin: top-botton left-right;\rmargin: top left-right bottom;\rmargin: top right bottom left;\r例子：\nmargin: 0;\rmargin: 0 auto;\rmargin: 0 auto 20px;\rmargin: 0 1px 2px 3px;\r内边距padding类似，不在举例\ndiv居中 div#box {\rwidth: 300px;\rmargin: 0 auto;\r}\r圆角边框及阴影  圆角边框 border-radius: 圆角半径; 边框阴影 box-shadow: 水平偏移 垂直偏移 阴影模糊半径 颜色; 与文本阴影text-shadow设置雷同  HTML\n\u0026lt;div id=\u0026quot;circle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;semicircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;quartercircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rCSS\n圆边边框\ndiv#circle {\rmargin: 0px auto;\rwidth:100px;\rheight: 100px;\rborder: 1px solid red;\rborder-radius: 50px ; /* 圆角半径 */\r}\r半圆边框\ndiv#semicircle {\rmargin: 0px auto;\rwidth: 100px;\rheight: 50px;\rborder: 1px solid red;\rborder-radius: 50px 50px 0 0;\r}\r四分一圆边框\ndiv#quartercircle {\rmargin: 0px auto;\rwidth:50px;\rheight: 50px;\rborder: 1px solid red;\rborder-radius: 50px 0 0 0;\r}\r效果：\n浮动 display和浮动 display: block/inline/inline-block/none\n block 表现块元素 inline 表现内联元素 不能设置宽高 inline-block* 让块级元素在一行显示的性质 可设置宽高 none 隐藏  float:left/right/none/inherit\n使用元素浮动，可向左向右。还可以继承父元素的浮动。\nclear:both/left/right/none\n指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。简单理解让其移动到左边或右边或两边不存在浮动元素的位置。\n浮动的例子：\nCSS\ndiv#father {\rborder: 1px solid black;\r}\rdiv#circle {\rmargin: 0px auto;\rwidth:100px;\rheight: 100px;\rborder: 1px solid red;\rborder-radius: 50px ;\rfloat: left;\r}\rdiv#semicircle {\rmargin: 0px auto;\rwidth: 100px;\rheight: 50px;\rborder: 1px solid red;\rborder-radius: 50px 50px 0 0;\rfloat: right;\r}\rdiv#quartercircle {\rmargin: 0px auto;\rwidth:50px;\rheight: 50px;\rborder: 1px solid red;\rborder-radius: 50px 0 0 0;\rfloat:right;\rclear: both;\r}\rHTML\n\u0026lt;div id=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;circle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;semicircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;quartercircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r效果：\n父级边框塌陷问题及overflow 上节的浮动与清除的例子，就展现了父级边框塌陷问题。就是浮动元素超出了父级元素的边框。\n解决方案\n 父级边框设置固定高度  div#father {\rborder: 1px solid black;\rheight: 500px;\r}\r不灵活，如果子元素宽高改变，父级元素也跟着可能改变，不建议使用。\n在所有浮动元素添加空div  例如：\n.clear {\rclear:both;\rmargin: 0;\rpadding: 0;\r}\r\u0026lt;div id=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;circle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;semicircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;quartercircle\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;clear\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r效果：\n简单，但不建议添加空div。\noverflow  div#father {\rborder: 1px solid black;\roverflow: hidden;\r}\r简单，但是不适合在下拉的场景中，导致被元素剪切，避免使用\noverflow: hidden/auto/scroll\n当子元素内容高度，大于父级的高度或宽度，即溢出时，可设置overflow属性。\nhidden会剪切掉子元素溢出部分。scroll在父级元素出现滚动条，通过滚动来浏览溢出内容。auto根据情况自动选择hidden或scroll。\n父边框添加伪类 :after （推荐）  div#father:after {\rcontent: '';\rdisplay: block;\rclear: both;\r}\r最佳的处理父级边框塌陷。\n定位 相对定位 body {\rpadding: 20px;\r}\rdiv {\rmargin: 10px;\rpadding: 5px;\rfont-size: 12px;\rline-height: 25px;\r}\r#father {\rborder: 1px solid black;\rpadding: 0;\r}\r#first {\rbackground-color: rgb(240, 179, 230);\rborder: 1px dashed rgb(240, 179, 65);\rposition: relative;\rtop: -10px;\rleft: 10px;\r}\r#second {\rbackground-color: rgb(156, 39, 230);\rborder: 1px dashed rgb(156, 39, 39);\r}\r#third {\rbackground-color: rgb(167, 161, 230);\rborder: 1px dashed rgb(167, 161, 103);\rposition: relative;\rbottom: -10px;\rright: 10px;\r}\r \u0026lt;div id=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;first\u0026quot;\u0026gt;第一个盒子\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;second\u0026quot;\u0026gt;第二个盒子\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;third\u0026quot;\u0026gt;第三个盒子\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r效果：\nposition: relative;\ntop: -10px; /* 距离原来顶部边界位置，偏移-10px */\rbottom: -10px; /* 距离原来底部边界位置，偏移-10px */\rleft: 10px; /* 距离原来左边部边界位置，偏移10px */\rright: 10px; /* 距离原来右边部边界位置，偏移10px */\r该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）\n方块定位 例子：\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;style\u0026gt;\ra, div,body {\rmargin: 0;\rpadding: 0;\r}\ra {\rtext-decoration: none;\rtext-align: center;\r}\rdiv#father {\rwidth: 300px;\rheight: 300px;\rmargin: 0 auto; padding: 10px;\rborder: 3px solid red;\r}\rdiv#father a {\rbackground-color: pink;\rdisplay: block;\rwidth: 100px;\rheight: 100px;\rline-height: 100px;\rcolor: white;\r}\rdiv#father a:hover {\rbackground-color: blue;\r}\rdiv#father a:nth-child(2), div#father a:nth-child(4) {\rposition: relative;\rtop: -100px;\rleft: 200px;\r}\rdiv#father a:nth-child(5) {\rposition: relative;\rtop: -300px;\rleft: 100px;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;链接1\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;链接2\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;链接3\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;链接4\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;链接5\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r效果：\n绝对定位和固定定位 position: absolute;\n元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。static表示默认定位。\n当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块，也就是body）。\n绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\nposition: fixed;\n元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。\nz-index及透明度 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;style\u0026gt;\rul, li, div,body {\rmargin: 0;\rpadding: 0;\r}\r#content {\rwidth: 300px;\rmargin: 0;\rpadding: 0;\rfont-size: 12px;\rline-height: 25px;\roverflow: hidden;\rborder: 1px solid black;\r}\rul li{\rlist-style: none;\r}\r#content ul {\rposition: relative;\r}\r.tipText, .tipBg {\rposition: absolute;\rtop: 175px;\rwidth: 300px;\rheight: 25px;\r}\r.tipText {\rz-index: 2;\rcolor: white;\r}\r.tipBg {\rbackground-color: black;\ropacity: 0.5;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;content\u0026quot;\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;img src=\u0026quot;resources/image/1.png\u0026quot; alt=\u0026quot;image\u0026quot; width=\u0026quot;300px\u0026quot; height=\u0026quot;200px\u0026quot;\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;tipText\u0026quot;\u0026gt;哇，是个美女！\u0026lt;/li\u0026gt;\r\u0026lt;li class=\u0026quot;tipBg\u0026quot;\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;她是凯瑟琳？\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;画的真不错！\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 图层 z-index: 0~infinity 默认是0，为最底层，数值越大，越靠外层 背景透明度 opacity: 0~1  效果：\n更多资源  MDN Web Docs - CSS  ","description":"学习 CSS 语法，重点使用选择器和了解盒子模型","id":13,"section":"posts","tags":["css"],"title":"CSS 语法","uri":"https://qinry.github.io/posts/2021/08/css-grammar/"},{"content":"概述 HTML，即Hyper Text Markup Language，中文是超文本标记语言\nW3C标准：\n 结构化标准(HTML,XML) 表现标准语言(CSS) 行为标准(DOM,ECMAScript)  HTML基本结构 例如某个web项目中的01-helloworld.html所示：\n\u0026lt;!-- 01-hellworld.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r head是网页的头部，body是网页主体部分。 head和body元素是开放标签和闭合标签成对出现，有头有尾 ，如：\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; meta元素是自闭合标签，有头无尾或有尾无头，如：\u0026lt;hr /\u0026gt;  注释 单行注释\n\u0026lt;!-- 单行注释 --\u0026gt;\r多行注释\n\u0026lt;!--\r多行注释1\r多行注释2\r..\r--\u0026gt;\r网页基本信息 在head元素里面设置网页信息，通过meta标签设置一些元信息和title标签设置网站标题，如下：\n\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;网站搜索的关键字\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;网站描述\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;填写网站标题\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r基本标签 网页主体的基本标签如下：\n 标题标签 段落标签 换行标签 水平线标签 字体样式标签 特殊符号   标题标签 h1~h6\n \u0026lt;!-- 02-basicTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt;\r\u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt;\r\u0026lt;h3\u0026gt;三级标题\u0026lt;/h3\u0026gt;\r\u0026lt;h4\u0026gt;四级标题\u0026lt;/h4\u0026gt;\r\u0026lt;h5\u0026gt;五级标题\u0026lt;/h5\u0026gt;\r\u0026lt;h6\u0026gt;六级标题\u0026lt;/h6\u0026gt;\r\u0026lt;/body\u0026gt;\r 段落标签 p\n \u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;君不见黄河之水天上来，奔流到海不复回。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;君不见高堂明镜悲白发，朝如青丝暮成雪。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;人生得意须尽欢，莫使金樽空对月。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;天生我材必有用，千金散尽还复来。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;烹羊宰牛且为乐，会须一饮三百杯。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;岑夫子，丹丘生，将进酒，杯莫停。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;与君歌一曲，请君为我倾耳听。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;钟鼓馔玉不足贵，但愿长醉不复醒。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;古来圣贤皆寂寞，惟有饮者留其名。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;陈王昔时宴平乐，斗酒十千恣欢谑。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;主人何为言少钱，径须沽取对君酌。\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r 换行标签 br\n \u0026lt;body\u0026gt;\r君不见黄河之水天上来，奔流到海不复回。\u0026lt;br/\u0026gt;\r君不见高堂明镜悲白发，朝如青丝暮成雪。\u0026lt;br/\u0026gt;\r人生得意须尽欢，莫使金樽空对月。\u0026lt;br/\u0026gt;\r天生我材必有用，千金散尽还复来。\u0026lt;br/\u0026gt;\r烹羊宰牛且为乐，会须一饮三百杯。\u0026lt;br/\u0026gt;\r岑夫子，丹丘生，将进酒，杯莫停。\u0026lt;br/\u0026gt;\r与君歌一曲，请君为我倾耳听。\u0026lt;br/\u0026gt;\r钟鼓馔玉不足贵，但愿长醉不复醒。\u0026lt;br/\u0026gt;\r古来圣贤皆寂寞，惟有饮者留其名。\u0026lt;br/\u0026gt;\r陈王昔时宴平乐，斗酒十千恣欢谑。\u0026lt;br/\u0026gt;\r主人何为言少钱，径须沽取对君酌。\u0026lt;br/\u0026gt;\r五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。\u0026lt;br/\u0026gt;\r\u0026lt;/body\u0026gt;\r 水平线标签\n \u0026lt;body\u0026gt;\r\u0026lt;hr/\u0026gt;\r\u0026lt;/body\u0026gt;\r 字体样式标签 strong,em,del\n \u0026lt;body\u0026gt;\r粗体：\u0026lt;strong\u0026gt;hahaha\u0026lt;/strong\u0026gt;\u0026lt;br/\u0026gt;\r斜体：\u0026lt;em\u0026gt;hahaha\u0026lt;/em\u0026gt;\u0026lt;br/\u0026gt;\r删除线：\u0026lt;del\u0026gt;hahaha\u0026lt;/del\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;/body\u0026gt;\r 特殊符号\n \u0026lt;body\u0026gt;\r空\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;格\u0026lt;br/\u0026gt;\r小于号\u0026amp;lt; 小于等于\u0026amp;le;\u0026lt;br/\u0026gt;\r大于号\u0026amp;gt; 大于等于\u0026amp;ge;\u0026lt;br/\u0026gt;\r等于\u0026amp;Equal; 不等于\u0026amp;NotEqual;\u0026lt;br/\u0026gt;\r版权符号\u0026amp;copy;\u0026lt;br/\u0026gt;\r\u0026lt;/body\u0026gt;\r图像标签 常见图片格式：\n JPG GIF PNG BMP  \u0026lt;img src=\u0026quot;path\u0026quot; alter=\u0026quot;text\u0026quot; title=\u0026quot;word\u0026quot; width=\u0026quot;x\u0026quot; height=\u0026quot;y\u0026quot;\u0026gt;\r src* 图片位置（绝对路径/相对路径） alter* 替换文本 title 悬停文字 width 图片宽度 height 图片高度  * 表示必填\n\u0026lt;!-- 03-imgTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- resouces/image存在1.png，没有2.png --\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/2.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\r\u0026lt;/body\u0026gt;\r超链接  文本链接 图片链接  \u0026lt;a href=\u0026quot;url\u0026quot; target=\u0026quot;window\u0026quot;\u0026gt;\r可以是文本，也可以是图片\r\u0026lt;/a\u0026gt;\r href* 超文本引用，超链接地址 target 目标窗口，如：新标签页跳转_blank/默认当前标签页跳转_self/_parent/_top/自定义(iframe的name)  \u0026lt;!-- 04-aTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 描链接 --\u0026gt;\r\u0026lt;a name=\u0026quot;top\u0026quot;\u0026gt;顶部\u0026lt;/a\u0026gt;\r\u0026lt;!-- 文本链接 --\u0026gt;\r\u0026lt;a href=\u0026quot;01-helloworld.html\u0026quot; \u0026gt;跳转到..\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; \u0026gt;去百度\u0026lt;/a\u0026gt;\r\u0026lt;!-- 邮件链接 --\u0026gt;\r\u0026lt;a href=\u0026quot;mailto:lixiaoqin28@outlook.com\u0026quot;\u0026gt;联系邮箱\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;!-- 图片链接 --\u0026gt;\r\u0026lt;a href=\u0026quot;01-helloworld.html\u0026quot; \u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;/a\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;img src=\u0026quot;../resouces/image/1.png\u0026quot; alt=\u0026quot;凯瑟琳\u0026quot; title=\u0026quot;凯瑟琳\u0026quot; width=\u0026quot;500px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;!-- 描链接 --\u0026gt;\r\u0026lt;a href=\u0026quot;#top\u0026quot;\u0026gt;回到顶部\u0026lt;/a\u0026gt;\r\u0026lt;/body\u0026gt;\r行内元素和块元素  快元素 独占一行 如：p、h1~h6、div \u0026hellip; 行内元素 内容撑开，左右皆是行内元素可以排在一行 如：a、strong、em、del、span、input \u0026hellip;  列表标签  有序列表 ol\u0026gt;li 无序列表 ul\u0026gt;li 自定义列表 dl\u0026gt;dt+dd  \u0026lt;!-- 05-listTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 有序列表 试卷、问答 ...\r--\u0026gt;\r\u0026lt;ol\u0026gt;\r\u0026lt;li\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Linux\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Web\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;C/C++\u0026lt;/li\u0026gt;\r\u0026lt;/ol\u0026gt;\r\u0026lt;!-- 无序列表\r导航栏，测表栏\r--\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li\u0026gt;Java\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Linux\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;Web\u0026lt;/li\u0026gt;\r\u0026lt;li\u0026gt;C/C++\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;!-- 自定义列表 dl 标签\rdt 列表名称\rdd 列表内容\r网站底部\r--\u0026gt;\r\u0026lt;dl\u0026gt;\r\u0026lt;dt\u0026gt;subject\u0026lt;/dt\u0026gt;\r\u0026lt;dd\u0026gt;Java\u0026lt;/dd\u0026gt;\r\u0026lt;dd\u0026gt;Linux\u0026lt;/dd\u0026gt;\r\u0026lt;dd\u0026gt;Web\u0026lt;/dd\u0026gt;\r\u0026lt;dd\u0026gt;C/C++\u0026lt;/dd\u0026gt;\r\u0026lt;/dl\u0026gt;\r\u0026lt;/body\u0026gt;\r表格标签 \u0026lt;!-- 06-tableTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 表格标签 --\u0026gt;\r\u0026lt;table border=\u0026quot;1px\u0026quot;\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;!-- colspan 跨列 --\u0026gt;\r\u0026lt;td colspan=\u0026quot;3\u0026quot; \u0026gt;学生成绩 \u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;!-- rowspan 跨行 --\u0026gt;\r\u0026lt;td rowspan=\u0026quot;2\u0026quot;\u0026gt;小红\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;语文\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;数学\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;!-- rowspan 跨行 --\u0026gt;\r\u0026lt;td rowspan=\u0026quot;2\u0026quot;\u0026gt;小明\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;语文\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;td\u0026gt;数学\u0026lt;/td\u0026gt;\r\u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/body\u0026gt;\r媒体元素  音频元素 视频元素  \u0026lt;!-- 07-mediaTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;!-- 视频标签 --\u0026gt;\r\u0026lt;video src=\u0026quot;../resouces/video/1.mp4\u0026quot; controls autoplay width=\u0026quot;1511px\u0026quot; height=\u0026quot;750px\u0026quot;\u0026gt;\u0026lt;/video\u0026gt;\r\u0026lt;!-- 音频标签 --\u0026gt;\r\u0026lt;audio src=\u0026quot;../resouces/audio/1.mp3\u0026quot; controls autoplay\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/body\u0026gt;\r页面结构  header* 标记头部区域内容 footer* 标记脚部区域内容 section 一块独立区域 article 独立的文章内容 aside 相关内容或应用，常见于侧边栏 nav* 导航辅助内容  * 重点\n\u0026lt;!-- 08-pageStructure.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;header\u0026gt;\r\u0026lt;h2\u0026gt;页面内容头部\u0026lt;/h2\u0026gt;\r\u0026lt;/header\u0026gt;\r\u0026lt;section\u0026gt;\r\u0026lt;h2\u0026gt;页面内容主体\u0026lt;/h2\u0026gt;\r\u0026lt;/section\u0026gt;\r\u0026lt;footer\u0026gt;\r\u0026lt;h2\u0026gt;页面内容脚部\u0026lt;/h2\u0026gt;\r\u0026lt;/footer\u0026gt;\r\u0026lt;/body\u0026gt;\r内联框架 \u0026lt;iframe src=\u0026quot;path\u0026quot; name=\u0026quot;mainFrame\u0026quot; width=\u0026quot;x\u0026quot; height=\u0026quot;y\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;\r src 嵌入的HTML地址 name 框架的名称 width 框架的宽度 height 框架的高度  可以和a标签搭配使用\n\u0026lt;!-- 09-iframeTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;iframe src=\u0026quot;#\u0026quot; name=\u0026quot;frame\u0026quot; scrolling=\u0026quot;no\u0026quot; border=\u0026quot;0\u0026quot; frameborder=\u0026quot;no\u0026quot; framespacing=\u0026quot;0\u0026quot; allowfullscreen=\u0026quot;true\u0026quot; width=\u0026quot;750px\u0026quot; height=\u0026quot;405px\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;\r\u0026lt;a href=\u0026quot;https://player.bilibili.com/player.html?aid=929767931\u0026amp;bvid=BV13K4y1S75r\u0026amp;cid=315710506\u0026amp;page=1\u0026quot; target=\u0026quot;frame\u0026quot;\u0026gt;点击\u0026lt;/a\u0026gt;\r\u0026lt;/body\u0026gt;\r表单 最简单的表单：\n\u0026lt;!-- 10-formTag.html --\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;form method=\u0026quot;post\u0026quot; action=\u0026quot;#\u0026quot; enctype=\u0026quot;application/x-www-form-urlencoded\u0026quot;\u0026gt;\r用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;pwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;reset\u0026quot; value=\u0026quot;重置\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/body\u0026gt;\r method 提交方式 post/get action 表单提交的位置，可以是网站，也可以是请求地址 enctype 表单内容类型 如：multipart/form-data（文件上传必选）、application/x-www-form-urlencoded（默认）   文本框\n \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; value=\u0026quot;admin\u0026quot; maxLength=\u0026quot;8\u0026quot; size=\u0026quot;30\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r type 文本框 text name 提交表单时，数据项的名称 value 数据项的默认初始值 maxLength 最大可输入字符数 size 文本框宽度   单选框\n \u0026lt;p\u0026gt;性别：\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;male\u0026quot; checked /\u0026gt; 男\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;female\u0026quot; /\u0026gt; 女\r\u0026lt;/p\u0026gt;\r type 单选框 radio value 选项的值，不能改变 checked 有则默认选中，无不选中   多选框\n \u0026lt;p\u0026gt;爱好：\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;movie\u0026quot; /\u0026gt; 电影\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;song\u0026quot; /\u0026gt; 歌曲\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;game\u0026quot; /\u0026gt; 游戏\r\u0026lt;/p\u0026gt;\r type 多选框 checkbox checked 有则默认选中，无不选中   列表框\n  \u0026lt;p\u0026gt;所在地\r\u0026lt;select name=\u0026quot;location\u0026quot;\u0026gt;\r\u0026lt;option value=\u0026quot;Guangdong\u0026quot; selected\u0026gt;广东\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;Shanghai\u0026quot;\u0026gt;上海\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;Beijing\u0026quot;\u0026gt;北京\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\r\u0026lt;/p\u0026gt;\r selected 有默认选中，无不选中   文本域\n \u0026lt;p\u0026gt;个人简介:\r\u0026lt;textarea name=\u0026quot;introduction\u0026quot; cols=\u0026quot;80\u0026quot; rows=\u0026quot;10\u0026quot;\u0026gt;我是...\u0026lt;/textarea\u0026gt;\r\u0026lt;/p\u0026gt;\r cols 文本域的初始列数 rows 文本域初始行数   按钮\n \u0026lt;p\u0026gt;\r\u0026lt;input type=\u0026quot;image\u0026quot; src=\u0026quot;../resources/image/2.png\u0026quot; width=\u0026quot;30px\u0026quot; height=\u0026quot;30px\u0026quot;/\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;input type=\u0026quot;button\u0026quot; name=\u0026quot;btn1\u0026quot; value=\u0026quot;按钮\u0026quot; /\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;reset\u0026quot; value=\u0026quot;重置\u0026quot;\u0026gt;\r\u0026lt;/p\u0026gt;\r 文件域\n 常用于文件上传\n\u0026lt;p\u0026gt;上传：\r\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;files\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r 其他\n \u0026lt;p\u0026gt;邮箱\r\u0026lt;input type=\u0026quot;email\u0026quot; name=\u0026quot;email\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;电话：\r\u0026lt;input type=\u0026quot;tel\u0026quot; name=\u0026quot;tel\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;url：\r\u0026lt;input type=\u0026quot;url\u0026quot; name=\u0026quot;url\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;搜索：\r\u0026lt;input type=\u0026quot;search\u0026quot; name=\u0026quot;search\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;数量：\r\u0026lt;input type=\u0026quot;number\u0026quot; name=\u0026quot;number\u0026quot; min=\u0026quot;0\u0026quot; max=\u0026quot;100\u0026quot; step=\u0026quot;10\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;范围：\r\u0026lt;input type=\u0026quot;range\u0026quot; name=\u0026quot;range\u0026quot; min=\u0026quot;0\u0026quot; max=\u0026quot;100\u0026quot; step=\u0026quot;2\u0026quot;/\u0026gt;\r\u0026lt;/p\u0026gt;\r min type为number/range 的最小值 max type为number/range 的最大值 step type为number/range 步长值  label与input \u0026lt;label for=\u0026quot;uname\u0026quot;\u0026gt;用户名\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; id=\u0026quot;uname\u0026quot; /\u0026gt;\r鼠标点击label，聚焦for对应指定的id值（这里是uname）的元素。\n常见输入框的属性 表单输入框的属性\n reaonly 表示只读不可修改 disabled 禁用输入框 hidden 隐藏输入框  \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;admin\u0026quot; readonly\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;性别：\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;male\u0026quot; checked disabled/\u0026gt; 男\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;female\u0026quot; /\u0026gt; 女\r\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;pwd\u0026quot; hidden\u0026gt;\u0026lt;/p\u0026gt;\r表单验证 表单输入框的属性用于简单的验证输入\n placeholder 输入框提示 required 输入框必须有输入，防止空输入 pattern 对输入框内容进行模式匹配验证  \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;admin\u0026quot; placeholder=\u0026quot;请输入用户名\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;pwd\u0026quot; required\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;邮箱\r\u0026lt;input type=\u0026quot;email\u0026quot; name=\u0026quot;email\u0026quot; pattern=\u0026quot;\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\u0026quot; /\u0026gt;\r\u0026lt;/p\u0026gt;\r其他资源  w3cschool 菜鸟教程  ","description":"学习 HTML 语法，重点使用表单","id":14,"section":"posts","tags":["html"],"title":"HTML 语法","uri":"https://qinry.github.io/posts/2021/08/html-grammar/"},{"content":"概述 Javascript 一种Web的编程语言，是互联网最流行的脚本语言。可以插入到HTML中，被所有的浏览器所执行。\nECMAScript 6，简称 ES6。ECMAScript 可以理解是 Javascript 的标准化规范。\n使用方式 引入外部文件，js代码可以写在后缀为js文件\n// main.js\r// javascript 代码写在这个文件\r// ...\r\u0026lt;!-- index.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;script src=\u0026quot;main.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r嵌入到HTML内部使用\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;script\u0026gt;\r// javascript代码写在这里\r// ...\r\u0026lt;/script\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rjs命名严格区分大小写\n简述数据类型 js的数据类型有数值、文本、图形、音频、视频等等\n变量定义格式\nvar 全局变量 = 值;\rlet 局部变量 = 值;\r变量名不能以数字开头，可以以字母、下划线_和美元符号$开头\n注意：\n null 表示空，是一种表示空的数据类型 undefined 表示未定义，说明变量未声明或声明但未初始化，依然为未定义  严格检查模式 'user strict'; // 严格检查模式，必须写在第一行\r数字 不区分小数和整数，例如：\n123 // 整数\r123.1 // 浮点数\r1.234e3 // 科学计数法\r-99 // 负数\rNaN // Not a Number\rInfinity // 无穷大\r字符串 用单引号或双引号表示，例如：\n\u0026quot;abc\u0026quot;\r'abc'\r布尔 有两个值true或false\n数组 使用中括号[]表示。这里数组，每个元素可以不相同，但建议保持使用一样的数据类型\n例如：\nvar ia = [ 1,2,3,4 ];\rvar sa = [ \u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot; ];\rvar ba = [ true, false ];\rvar matrix = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];\r对象 使用大括号{}表示，对象的属性以 属性名:值 格式表示，属性之间用逗号隔开，最后的属性不加逗号\nvar person = {\rname: \u0026quot;zhangsan\u0026quot;,\rage: 13\r}\rvar personName = person.name\rvar personAge = person.age\rnull 表示一个变量为空\nvar a = null;\r运算符 逻辑运算符 \u0026amp;\u0026amp; 短路与\r|| 短路或\r! 否\r比较运算符 != 不等于\r== 等于，表示值相等返回true\r=== 绝对等于，表示类型相等，值也相等，返回true\r\u0026gt; 大于\r\u0026gt;= 大于等于\r\u0026lt; 小于\r\u0026lt;= 小于等于\r建议使用 === ，而不是 ==\n注意：\n  NaN === NaN，NaN和任何数或NaN比较相等返回false\n  isNaN方法，判断变量是否为NaN\n  其他 进一步了解数据类型 字符串 1、转义字符\n\\\\ 反斜杠\r\\' 单引号\r\\\u0026quot; 双引号\r\\n 换行符\r\\t 制表符\r\\u4e2d unicode字符 \\u0000~\\uffff 十六进制\r\\x41 ascii字符 \\x00~\\x7f 十六进制\r2、多行字符串\nvar str = `hello\rworld`;\r3、模式字符串\nvar world = \u0026quot;world!\u0026quot;;\rvar str = `hello, ${world}`; // 结果：\u0026quot;hello, world!\u0026quot;\r4、字符串长度\nvar str = \u0026quot;hello, javascript\u0026quot;;\rvar len = str.length;\r5、字符串可变性与否\n字符串可通过下标取出包含的字符，如：str[0]。字符串不可变，即使 str[0] = 'b'; ，也不能改变 str里面的值。\n6、大小写转换\nvar str = \u0026quot;student\u0026quot;;\rstr.toUpperCase();\rstr.toLowerCase();\r7、子字符串\nvar str = \u0026quot;student\u0026quot;;\rvar sub = str.substring(0, 3);\r8、索引\nvar str = \u0026quot;student\u0026quot;;\rvar idx = str.indexOf('t');\r数组 1、长度\nvar arr = [ 1, 2, 3, 4, 5 ];\rvar len = arr.length;\r长度可变，数组大小也会改变。如果长度变小，数组元素会丢失；如果长度变大，数组后面填充empty，其实是undefined。\n2、索引\nvar arr = [ 1, 2, 3, 4, 5 ];\rvar idx = arr.indexOf(2);\r3、分片\nvar arr = [ 1, 2, 3, 4, 5 ];\rvar subarr = arr.slice(1, 4); // 取下标1到5（不包含）的子数组\r4、添加和移除尾部元素\nvar arr = [ 1, 2, 3, 4, 5 ];\rarr.push(6, 7); // 函数参数是可变参数，添加一或多个元素到尾部\rvar lastValue = arr.pop(); // 移除元素\r5、添加和移除首部元素\nvar arr = [ 1, 2, 3, 4, 5 ];\rarr.unshift(-2, 0); // 函数参数是可变参数，添加一或多个元素到首部\rvar firstValue = arr.shift(); // 移除元素\r6、排序\nvar arr = [ 3, 1, 5, 4, 2 ]\rarr.sort();\r7、元素反转\nvar arr = [ 1, 2, 3, 4, 5 ];\rarr.reverse();\r8、合并\n不改变原数组，返回合并后的数组\nvar arr = [ 1, 2, 3, 4, 5 ];\rarr.concat([ 6, 7, 8] );\r9、连接\n将数组元素连接成字符串，参数为连接符，默认为\u0026quot;,\u0026quot;\nvar arr = [ 1, 2, 3, 4, 5 ];\rvar str = arr.join(\u0026quot;-\u0026quot;); // 结果：1-2-3-4-5\r10、多维数组\n取值\nvar matrix = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];\rvar value = matrix[1][1];\r对象 以对象person为例：\nvar person = {\rname: \u0026quot;张三\u0026quot;,\rage: 18,\remail: \u0026quot;zhangsan@163.com\u0026quot;,\rscore: 0\r};\r1、设置属性\nperson.name = \u0026quot;李四\u0026quot;;\rperson.gender = \u0026quot;男\u0026quot;; // 设置不存在属性，对象增添该属性\r2、获得属性值\nvar personName = person.name;\rvar gender = person.gender; // 不存在属性，返回undefined，没有报错\r3、删除属性\nvar flag = delete person.gender; // 删除该属性，若属性存在，返回true，否则返回undefined\r4、判断对象包含的属性\n可以是\u0026quot;属性名\u0026quot; in 对象名 来判断，也可以是对象名.hasOwnProperty(属性名)。\nvar exists = \u0026quot;age\u0026quot; in person; // 存在返回true，否则返回false\rexists = person.hasOwnProperty(\u0026quot;name\u0026quot;); // 与上行类似\r他们区别，in还可以判断某个方法是否在这个对象，hasOwnProperty方法显然不行。\n例如：\n\u0026quot;toString\u0026quot; in person; // 结果：true\rperson.hasOwnProperty(\u0026quot;toString\u0026quot;); // 结果： false\r流程控制 if分支 var score = 88;\rif (score \u0026lt; 0 || score \u0026gt; 100) {\ralert(\u0026quot;分数在不合理范围\u0026quot;);\r}\rif (score \u0026gt;= 90) {\rconsole.log(\u0026quot;优秀\u0026quot;);\r} else if (score \u0026gt;= 80) {\rconsole.log(\u0026quot;良好\u0026quot;);\r} else if (score \u0026gt;= 70) {\rconsole.log(\u0026quot;中等\u0026quot;);\r} else if (score \u0026gt;= 60) {\rconsole.log(\u0026quot;及格\u0026quot;);\r} else {\rconsole.log(\u0026quot;不及格\u0026quot;);\r}\rconsole.log(\u0026hellip;) 在浏览器控制台输出消息。alert(\u0026hellip;) 浏览器弹窗显示消息\nwhile循环 var i = 0;\rwhile (i \u0026lt; 5) {\rconsole.log(i);\ri++;\r}\rdo {\ri--;\rconsole.log(i);\r} while(i \u0026gt; 0);\rfor循环 for (let i = 0; i \u0026lt; 5; i++) {\rconsole.log(i);\r}\rforeach循环 var arr = [ 1, 2, 3, 4, 5 ];\r// 不建议使用 for .. in 遍历数组，如果arr新增属性，也会被遍历出来，有漏洞\rfor (let idx in arr) {\rconsole.log(arr[idx]);\r}\rfor (let val of arr) {\rconsole.log(val);\r}\rvar person = {\rname: \u0026quot;张三\u0026quot;,\rage: 18,\remail: \u0026quot;zhangsan@163.com\u0026quot;,\rscore: 0\r};\rfor (let key in person) {\rconsole.log(person[key]);\r}\r集合 map  map增删改查\n var map = new Map([ [\u0026quot;jack\u0026quot;, 90],[\u0026quot;rocco\u0026quot;, 88] ]); // 新建Map 可传参：二维数组 表示键值对\rmap.set(\u0026quot;tom\u0026quot;, 100); // 增\rmap.delete(\u0026quot;tom\u0026quot;); // 删：成功返回true，否则返回false\rmap.set(\u0026quot;rocco\u0026quot;, 100); // 改\rmap.get(\u0026quot;jack\u0026quot;); // 查\r 遍历map\n for (let x of map) {\rconsole.log(x[0] + \u0026quot; =\u0026gt; \u0026quot; + x[1]);\r}\rset  set增删查\n var set = new Set([1,2,3,3]);\rset.add(4); // 增\rset.delete(3); // 删\rset.has(2); // 查\r 遍历set\n for (let x of set) {\rconsole.log(x);\r}\r函数 定义函数  方式1\n function methodName(paramName) {\r//...\rreturn returnVal;\r}\rfunction abs(x) {\rif (typeof x !== \u0026quot;number\u0026quot;) {\rthrow \u0026quot;arg x not a number\u0026quot;;\r}\rreturn x \u0026gt;= 0 ? x : -x;\r}\rvar val = abs(-2);\r 方式2\n var methodName = function(paramName) {\r//...\rreturn returnVal;\r}\rvar abs = function(x) {\rif (typeof x !== \u0026quot;Number\u0026quot;) {\rthrow \u0026quot;arg x not a number\u0026quot;;\r}\rreturn x \u0026gt;= 0 ? x : -x;\r}\rvar val = abs(-2);\r通过 typeof 得到变量的类型，进行类型判断。throw + 异常信息 就可以抛出异常\narguments关键字 arguments包含函数的所有参数，其实是数组\nfunction log(str) {\rif (typeof str !== \u0026quot;String\u0026quot;) {\rthrow \u0026quot;arg str not a String\u0026quot;;\r}\rif (arguments.length == 1) {\rconsole.log(str);\r} else if (arguments.length \u0026gt; 1) {\rconsole.log(str);\rfor (let i = 1; i \u0026lt; arguments.length; i++) {\rconsole.log(arguments[i]);\r}\r}\r}\rlog(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;, \u0026quot;!\u0026quot;);\r可变参数 function log(str, ...rest) {\rif (typeof str !== \u0026quot;String\u0026quot;) {\rthrow \u0026quot;arg str not a String\u0026quot;;\r}\rconsole.log(str);\rfor (let msg of rest) {\rconsole.log(msg);\r}\r}\rlog(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;, \u0026quot;!\u0026quot;);\r作用域 在函数内部声明的局部变量，只能在其函数内部使用。\nfunction f1() {\rvar x = 1;\rfunction f2() {\rx++;\rconsole.log(x);\r}\rreturn f2;\r}\rvar f = f1();\rf();\r这里函数f2是个闭包，f2内部能访问到f1中的变量x，并能自增1。f1返回值为f2。那么函数外部可以通过f1的返回值访问到f1内部的局部变量。\n在函数外声明的全局变量，能被所有函数访问。全部的全局变量会绑定为全局对象window的属性。\nvar global_x = 1;\rfunction f1() {\rconsole.log(global_x);\r}\rconsole.log(window.global_x);\r函数查找变量，从其内部往外查找，直到全局作用域，内部覆盖外部同名变量。\n注意：\n 建议函数内部所有声明的变量的位置都放在函数体的头部。不该在需要某一变量的地方声明。 建议所有的全局变量，放到同一个对象中，这个对象绑定为window属性，这个属性里面再放入许多的全局变量，来减少命名冲突。比如：jQuery 这个库的全局变量放到了名为\u0026quot;jQuery\u0026quot;的对象中，其还有一个别名：$。  let关键字 解决局部作用冲突问题。建议函数局部变量使用let声明\nfor (var i = 0; i \u0026lt; 5; i++) {\rconsole.log(i);\r}\rconsole.log(i+1);\rfor (let i = 0; i \u0026lt; 5; i++) {\rconsole.log(i+1);\r}\r// console.log(i+1);// ! let声明的i不会在for循环外生效，而var会\rconst关键字 定义常量，使用关键字const\nconst PI = \u0026quot;3.1415\u0026quot;;\r// PI = \u0026quot;123\u0026quot;; // ! 常量PI只读，不能修改\r方法 对象包含的变量为属性，对象包含的函数为方法\n 方式1\n var person = {\rname: \u0026quot;zhangsan\u0026quot;,\rbirth: 1999,\rage: function() {\rvar now = new Date().getFullYear();\rreturn now - this.birth;\r}\r}\rperson.age();\r方法使用对象的属性，要用 this.属性名 获取。\n 方式2\n function getAge() {\rvar now = new Date().getFullYear();\rreturn now - this.birth;\r}\rvar person = {\rname: \u0026quot;zhangsan\u0026quot;,\rbirth: 1999,\rage: getAge\r}\rperson.age();\rapply 控制函数中this的指向\nfunction getAge() {\rvar now = new Date().getFullYear();\rreturn now - this.birth;\r}\rvar person = {\rname: \u0026quot;zhangsan\u0026quot;,\rbirth: 1999,\rage: getAge\r}\rgetAge.apply(person, []);\r内部对象 标准对象 typeof 123;\r\u0026quot;number\u0026quot;\rtypeof \u0026quot;123\u0026quot;;\r\u0026quot;string\u0026quot;\rtypeof true;\r\u0026quot;boolean\u0026quot;\rtypeof NaN;\r\u0026quot;number\u0026quot;\rtypeof [];\r\u0026quot;object\u0026quot;\rtypeof {};\r\u0026quot;object\u0026quot;\rDate  常用方法\n var now = new Date();\rnow.getFullYear();\rnow.getMonth(); // 0-11\rnow.getDate(); now.getDay(); // 星期几\rnow.getHours();\rnow.getMinutes();\rnow.getSeconds();\rnow.getTime(); // 时间戳\rnow = new Date(1629555024108);\r 日期转文本\n var now = new Date(1629555024108);\rnow.toLocaleString();\rJSON 对象转JSON字符串\nvar person = {\rname: \u0026quot;张三\u0026quot;,\rage: 18,\remail: \u0026quot;zhangsan@163.com\u0026quot;,\rscore: 0\r};\rvar jsonPerson = JSON.stringify(person);\rconsole.log(jsonPerson);\rJSON字符串转对象\nvar person = JSON.parse('{\u0026quot;name\u0026quot;:\u0026quot;张三\u0026quot;,\u0026quot;age\u0026quot;:18,\u0026quot;email\u0026quot;:\u0026quot;zhangsan@163.com\u0026quot;,\u0026quot;score\u0026quot;:0}');\rconsole.log(person.name)\r面向对象  原型对象\n function Student(name) {\rthis.name = name;\r}\rStudent.prototype.hello = function(){\ralert('hello');\r};\r// 继承\rfunction Pupil(name, age) {\rStudent.call(this,name);\rthis.age = age; }\rPupil.prototype.showAge = function() {\ralert('age:'+this.age);\r}\rvar pu = new Pupil('lisi', 8);\rvar stu = new Student(\u0026quot;zhangsan\u0026quot;);\rpu.showAge();\rstu.hello();\r class对象\n class Student {\rconstructor(name) {\rthis.name = name;\r}\rhello() {\ralert('hello');\r}\r}\r// 继承\rclass Pupil extends Student {\rconstructor(name, age) {\rsuper(name);\rthis.age = age;\r}\rshowAge() {\ralert(\u0026quot;age:\u0026quot;+this.age);\r}\r}\rvar p = new Pupil('lisi', 8);\rvar s = new Student('zhangsan');\rp.showAge();\rs.hello();\r操作BOM对象 BOM，即 Browser Object Model，中文是浏览器对象模型\n几个常见浏览器内核：\n IE Chrome FireFox Safari   window\n 代表浏览器的窗口\nwindow.alert('..')\rwindow.innerHeight\rwindow.innerWidth\rwindow.outerHeight\rwindow.outerWidth\r navigator\n 封装浏览器信息\nnavigator.appName\rnavigator.appVersion\rnavigator.platform\rnavigator.userAgent\rnavigator信息会被人为修改，所以不建议使用这些属性，来编写代码\n screen\n 表示屏幕信息\nscreen.height\rscreen.width\r location\n 代表定位\nlocation.host\rlocation.protocol // https\rlocation.href\rlocation.hostname\rlocation.reload() // 刷新\rlocation.assign('..') // 重定向\r history\n表示历史记录\n history.back()\rhistory.forward()\r不建议使用，可以是ajax完成页面的局部刷新来替代。\n document\n 表示当前页面，就是HTML 文档树\ndocument.title\rdocument.getElementById('..'); // id选择文档树结点\rdocument.cookie // cookie不安全，服务端需要设置cookie httpOnly属性，那么document.cookie无法访问设置该属性的cookie\r操作DOM对象 DOM，即 Document Object Model，中文为文档对象模型。\n浏览器页面本质就是DOM树结构\n核心操作：\n 更新节点 遍历节点 删除节点 新增节点  假如有这么一个html文件：\n\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;操作DOM对象\u0026lt;/title\u0026gt;\r\u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt;\r.p2 {\rcolor: red;\rfont-size: 100px; }\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026quot;father\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt;\r\u0026lt;p id=\u0026quot;p1\u0026quot;\u0026gt;p1\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;p2\u0026quot;\u0026gt;p2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\r// ... 操作DOM节点\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r查找节点 // 根据选择器选择元素节点\rvar h1 = document.getElementsByTagName('h1').item(0);\rvar p1 = document.getElementById('p1');\rvar p2 = document.getElementsByClassName('p2').item(0);\rvar father = document.getElementById('father');\r// 获取所有子元素节点\rvar children = father.children;\r// 第一个子元素节点\rvar first = father.firstElementChild\r// 最后一个子元素节点\rvar last= father.lastElementChild;\r// 下一个相邻元素节点\rvar next = first.nextElementSibling;\r// 上一个相邻元素节点\rvar prev = last.previousElementSibling;\r更新节点 h1.innerText = 'h1'; // 修改文本内容\rh1.innerHTML = '\u0026lt;strong\u0026gt;h1\u0026lt;/strong\u0026gt;'; // 修改超文本内容，可以解析HTML\r// 修改元素的css\rh1.style.color = 'red';\rh1.style.fontSize = '20px';\rh1.style.padding = '2em';\r删除节点 步骤：首先查找删除节点的父节点，再通过父节点删除\nfather.removeChild(p1);\rvar father2 = p1.parentElement; // 获取父元素节点\rfather2.removechild(p2);\r新增节点 新增方法传入的是已有的元素节点，则是元素节点\n append\n在父节点内部追加一个子节点到尾部\n var p3 = document.createElement('p');\rp3.setAttribute('id', 'p3');\r// p3.id = 'p3'; // 与上行等效\rp3.innerText = 'p3';\rfather.append(p3);  insertBefore\n在父节点内部的目标子节点前插入一个节点\n var p3 = document.createElement('p');\rp3.setAttribute('id', 'p3');\rp3.innerText = 'p3';\rfather.insertBefore(p3, p2); // father内部的目标p2前插入p3\r prepend\n在父节点内部追加一个子节点到头部部\n var p3 = document.createElement('p');\rp3.setAttribute('id', 'p3');\rp3.innerText = 'p3';\rfather.prepend(p3);\r before\n在目标节点前面插入新节点\n var p3 = document.createElement('p');\rp3.setAttribute('id', 'p3');\rp3.innerText = 'p3';\rp2.before(p3);\r after\n 在目标节点后面插入新节点\nvar p3 = document.createElement('p');\rp3.setAttribute('id', 'p3');\rp3.innerText = 'p3';\rp2.after(p3);\r验证表单  登录或注册表单的验证\n假如有这样一个html文件\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;验证表单\u0026lt;/title\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.bootcdn.net/ajax/libs/blueimp-md5/2.18.0/js/md5.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;form action=\u0026quot;#\u0026quot; method=\u0026quot;post\u0026quot; onsubmit=\u0026quot;return checkForm()\u0026quot;\u0026gt;\r\u0026lt;label\u0026gt;用户名:\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;uname\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r\u0026lt;label\u0026gt;密码:\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;password\u0026quot; id=\u0026quot;input-pwd\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r\u0026lt;input type=\u0026quot;hidden\u0026quot; id=\u0026quot;md5-pwd\u0026quot; name=\u0026quot;pwd\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; \u0026gt;提交\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rfunction checkForm() {\rvar uname = document.getElementById('uname').value;\rvar pwd = document.getElementById('input-pwd').value;\rvar md5_pwd_elem = document.getElementById('md5-pwd');\rmd5_pwd_elem.value = md5(pwd);\rreturn true;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 引入bootcdn的md5.min.js文件，用它使用md5算法加密密码文本 form的属性 onsubmit 用来表单在提交时绑定的事件，这里是checkForm函数，目的是用来验证表单 id为input-pwd的密码输入框用于接受密码的输入，id为md5-pwd的隐藏域用来真正提交的加密过的密码 提交表单上传的数据，对应的文本必须有name属性，用来标示对应的数据项 选择的input元素elem可以使用value属性获取表单输入的值，或设置他们的value的值来改变输入的值。但是输入是固定选项的话，则使用checked或selected属性的真与否来判断所选择的值是哪一个。   获取单选框、多选框、下拉框所选定的值\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;验证表单\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;form action=\u0026quot;#\u0026quot; method=\u0026quot;post\u0026quot; onsubmit=\u0026quot;return checkForm()\u0026quot;\u0026gt;\r\u0026lt;label\u0026gt;性别\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;male\u0026quot;\u0026gt; 男\r\u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;female\u0026quot;\u0026gt; 女 \u0026lt;br\u0026gt;\r\u0026lt;label\u0026gt;爱好\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;movie\u0026quot;\u0026gt; 电影\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;song\u0026quot;\u0026gt; 听歌\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;hobby\u0026quot; value=\u0026quot;game\u0026quot;\u0026gt; 游戏 \u0026lt;br\u0026gt;\r\u0026lt;label\u0026gt;选择编程语言\u0026lt;/label\u0026gt;\r\u0026lt;select name=\u0026quot;language\u0026quot; id=\u0026quot;language\u0026quot;\u0026gt;\r\u0026lt;option value=\u0026quot;C\u0026quot;\u0026gt;C\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;Java\u0026quot;\u0026gt;Java\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;JavaScript\u0026quot;\u0026gt;JavaScript\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\u0026lt;br\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;提交\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\r// .. javascript代码位置\rfunction checkForm() {\r// ..\rreturn true;\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r判断选项框是否选中\ndocument.getElementById('boy').checked; // 结果： true/false\rdocument.getElementById('girl').checked;\rvar hobby = document.getElementsByName('hobby');\rhobby[0].checked; // 结果：true / false\rhobby[1].checked;\rhobby[2].checked;\rvar lang = document.getElementById('language');\rvar idx = lang.selectedIndex; // 结果： 0 ~ lang.length - 1\rlang[idx].selected; // 结果： true / false\rjQuery jQuery 是 javascript 的封装库，旨在减少书写javascript的代码量，能够做更多的事情。更多详情在官网在那里\n导入jQuery的方式 方式1：CDN导入\nCDN选择很多，这里是使用BootCDN的jQuery。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\r// .. javascript代码位置\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r方式2：本地导入\n需要到官网下载未压缩的开发用的jQuery，再本地导入到web项目中。\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;script src=\u0026quot;./jquery-3.6.0.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\r// .. javascript代码位置\r\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rjQuery公式 使用jQuery通常来查找DOM节点，它有一个通用的公式：\n$(selector).action(function(){\r});\rselector指的是选择器，利用CSS选择器的语法来查找DOM节点，action指节点绑定或监听的事件。事件大致分为鼠标事件、键盘事件和其他事件。\njQuery选择器 基本选择器\n #id：根据给定的ID匹配一个元素。 element：根据给定的元素标签名匹配所有元素。 .class：根据给定的css类名匹配元素。 *：匹配所有元素。 selector1,selector2,selectorN：将每一个选择器匹配到的元素合并后一起返回。可以指定任意多个选择器，并将匹配到的元素合并到一个结果内。  层级选择器\n ancestor descendant：在给定的祖先元素下匹配所有的后代元素 parent \u0026gt; child：在给定的父元素下匹配所有的子元素 prev + next：匹配所有紧接在 prev 元素后的 next 元素 prev ~ sliblings：匹配 prev 元素之后的所有 siblings 元素  基本筛选器\n\u0026ldquo;selector:filter\u0026rdquo; 代表在selector基础上使用filter筛选元素\nfilter有如下：\n :first ：获取第一个元素 :last：获取最后个元素 :not(selector)：去除所有与给定选择器匹配的元素 :even：匹配所有索引值为偶数的元素，从 0 开始计数 :odd：匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index)：匹配一个给定索引值的元素 :gt(index)：匹配所有大于给定索引值的元素 :lt(index)：匹配所有小于给定索引值的元素 :header：匹配如 h1, h2, h3之类的标题元素  内容筛选\n :contains(text)：匹配包含给定文本的元素 :empty：匹配所有不包含子元素或者文本的空元素 :has(selector)：匹配含有选择器所匹配的元素的元素 :parent：匹配含有子元素或者文本的元素  可见性筛选\n :hidden：匹配所有不可见元素，或者type为hidden的元素 :visible：匹配所有的可见元素  子元素筛选\n :first-child：匹配所给选择器( :之前的选择器)的第一个子元素 :last-child：匹配最后一个子元素 :nth-child(n|even|odd)：匹配其父元素下的第N个子或奇偶元素 :nth-last-child(n|even|odd|formula)：选择所有他们父元素的第n个子元素。计数从最后一个元素开始到第一个。 :first-of-type：结构化伪类，匹配E的父元素的第一个E类型的孩子。 :last-of-type：结构化伪类，匹配E的父元素的最后一个E类型的孩子 :nth-of-type(n|even|odd|formula)：选择同属于一个父元素之下，并且标签名相同的子元素中的第n个。 :nth-last-of-type(n|even|odd|formula)：选择同属于一个父元素之下，并且标签名相同的子元素中的第n个，计数从最后一个元素到第一个。  属性筛选\n [attribute]：匹配包含给定属性的元素。 [attribute=value]：匹配给定的属性是某个特定值的元素 [attribute!=value]：匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^=value]：匹配给定的属性是以某些值开头的元素 [attribute$=value]：匹配给定的属性是以某些值结尾的元素 [attribute*=value]：匹配给定的属性是以包含某些值的元素  表单\n :input：匹配所有 input, textarea, select 和 button 元素 :text：匹配所有的单行文本框 :password：匹配所有密码框 :radio：匹配所有单选按钮 :checkbox：匹配所有复选框 :submit：匹配所有提交按钮，理论上只匹配 type=\u0026ldquo;submit\u0026rdquo; 的input或者button，但是现在的很多浏览器，button元素默认的type即为submit，所以很多情况下，不设置type的button也会成为筛选结果 :image：匹配所有图像域 :reset：匹配所有重置按钮 :button：匹配所有按钮 :file：匹配所有文件域  表单对象属性\n :enabled：匹配所有可用元素 :disabled：匹配所有不可用元素 :checked：匹配所有选中的radio或checkbox等元素 :selected：匹配所有选中的option元素  绑定事件 鼠标事件\n mousedown([[data],fn])：当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mouseup([[data],fn])：当在元素上放松鼠标按钮时，会发生 mouseup 事件。 mouseenter([[data],fn])：当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave([[data],fn])：当鼠标指针离开元素时，会发生 mouseleave 事件。 mousemove([[data],fn])：当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件。 mouseover([[data],fn])：与 mouseenter 事件不同，不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。 mouseout([[data],fn])：与 mouseleave 事件不同，不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。 scroll([[data],fn])：当用户滚动指定的元素时，会发生 scroll 事件。  键盘事件\n keydown([[data],fn])：当键盘或按钮被按下时，发生 keydown 事件。 keypress([[data],fn])：与 keydown 事件不同，每插入一个字符，就会发生 keypress 事件。 keyup([[data],fn])：当按钮被松开时，发生 keyup 事件。它发生在当前获得焦点的元素上。  其它事件\n blur([[data],fn])：当元素失去焦点时触发 blur 事件。 change([[data],fn])：当元素的值发生改变时，会发生 change 事件。仅适用于文本域（text field），以及 textarea 和 select 元素。 click([[data],fn])：点击元素，触发click事件。 dbclick([[data],fn])：双击元素，触发click事件。 focus([[data],fn])：当元素获得焦点时，触发 focus 事件。 focusin([[data],fn])：当元素获得焦点时，触发 focusin 事件。focusin事件跟focus事件区别在于，他可以在父元素上检测子元素获取焦点的情况。 focusout([[data],fn])：当元素失去焦点时触发 focusout 事件。focusout事件跟blur事件区别在于，他可以在父元素上检测子元素失去焦点的情况。 resize([[data],fn])：当调整浏览器窗口的大小时，发生 resize 事件。 submit([[data],fn])：当提交表单时，会发生 submit 事件。 select([[data],fn])：当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。 ready(fn)：当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。  样例：\n\u0026lt;script\u0026gt;\r$(function(){ // 文档就绪时触发的事件\r$(':input').blur();\r});\r\u0026lt;/script\u0026gt;\rjQuery操作DOM 更新DOM\n$(selector).html(); // 获取超文本内容\r$(selector).html('..'); // 设置超文本内容\r$(selector).text(); // 获取文本内容\r$(selector).text('..'); // 设置文本内容\rCSS操作\n$(selector).css({key:value});\r元素的显示与隐藏\n$(selector).hide(); // 隐藏元素\r$(selector).show(); // 显示元素\rwindow的宽高\n$(window).height();\r$(window).width();\rajax异步请求 $.ajax({\rtype: 'GET', /* GET/POST 请求方式 */\rurl: 'url', /* 请求地址 */\rdata: {key:value}, /* 传入的数据 */\rdataType: \u0026quot;JSON\u0026quot;, /* 接受的数据格式 */\rasync: true, /* true/false 是否异步 */\rsuccess: function(data) { // 请求成功后的响应事件\r},\rerror: function() { // 请求失败后的响应事件\r}\r});\r其他资源  jQuery API 中文文档  ","description":"学习JavaScript 语法和 jQuery","id":15,"section":"posts","tags":["javascript"],"title":"Javascript 语法","uri":"https://qinry.github.io/posts/2021/08/javascript-grammar/"},{"content":"什么是Maven Apache Maven 是一个软件项目管理工具。基于项目对象模型的概念，它可以通过配置信息来管理项目的构建、报告和文档这些行为。\n其目标旨在：\n 使项目的构建过程简单 提供一种统一的构建系统 提供优质项目信息 鼓励更好的开发实践  它的重要功能在于项目构建和依赖管理\nMaven项目构建过程 项目构建的过程大致为以下：\n  清理：删除之前的构建结果（targe目录），重新构建\n  编译：编译Java源代码为字节码（src和test目录下的Java文件）\n  测试：对项目的所有测试单元进行测试\n  报告：每项测试后以标准格式记录和展示测试结果\n  打包：将项目压缩为一个用于安装或部署的文件（格式jar或war）\n  部署：将打包结果部署到远程仓库或服务器运行\n  Maven生命周期 Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤。生命周期可以理解为构建工程的流程。\nMaven有三套独立的生命周期，分别为 clean、default和site\n  clean lifecycle：进行项目构建前的清理工作\n  default lifecycle：项目构建过程的核心部分，如：编译、测试、打包、部署等等\n  site lifecycle：生成项目报告和文档，还有发布站点\n  每套生命周期都有一系列的阶段（phase）组成，maven命令可以生命周期中一个阶段对应\nclean生命周期 clean生命周期有相应插件绑定\n它有三个阶段 pre-clean、clean和post-clean。绑定插件就是 maven-clean-plugin\n   周期 描述     pre-clean 在实际项目清理之前执行所需的流程   clean 删除先前构建生成的所有文件   post-clean 执行完成项目清理所需的流程    default生命周期 default生命周期有很多阶段，核心且重要的阶段：generate-resources、proccess-resources、compile、test-compile、package、install和depoly\n   周期 描述     generate-resources 生成包含在包中的资源   proccess-resources 将资源复制并处理到目标目录中，准备打包   compile 编译项目的源代码   test-compile 将测试源代码编译到测试目标目录中   test 使用合适的单元测试框架（通常junit）运行测试。 这些测试不应该要求打包或部署代码   package 获取编译后的代码并将其打包为可分发的格式，例如 JAR   install 将包安装到本地存储库中，用作本地其他项目的依赖项   depoly 在集成或发布环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享    site生命周期 目的:建立和发布项目站点\n   周期 描述     pre-site 执行一些在生成项目站点之前需要完成的工作   site 生成项目站点文档   post-site 执行一些在生成项目站点之后需要完成的工作   site-deploy 将生成的项目站点发布到服务器上    项目构建常用命令 清理 清理项目，会直接删除target目录，成功的话，打印 BUILD SUCCESS\nmvn clean\r编译 生成target目录，在里面存放编译后的字节码\nmvn compile\r测试 完成单测。target目录生成surefire、surefire-reports（测试报告）和test-classes（存放测试用字节码）目录\nmvn test\r打包 执行打包工作，文件可能是jar或war\nmvn package\r安装 把打包好的文件安装到本地仓库（～/.m2/repository）\nmvn install\r复合操作 mvn clean compile\rmvn clean test\rmvn clean package\rmvn clean install\r配置文件pom.xml 了解一下 maven项目 的约定统一的目录，以 Java Web 项目为例：\n.\r├── pom.xml\r├── src\r│ ├── main\r│ │ ├── java\r│ │ ├── resources\r│ │ └── webapp\r│ │ ├── WEB-INF\r│ │ │ └── web.xml\r│ └── test\r│ ├── java\r│ └── resources\r└── target\r pom.xml：maven项目的核心配置文件用来掌控项目，分别描述4种配置信息：基本配置、构建设置、额外项目信息以及环境配置 src/main/java：存放Java源代码的目录 src/main/resources：存放项目所使用的资源，比如：jdbc.properties、log4j.properties src/main/webapp：存放web项目相关的文件，比如静态页面文件（*.html等），里面WEB-INF文件夹存放web.xml配置Servlet。 src/test：存放测试相关的源代码和资源 targe：maven构建生成的目标文件夹  pom.xml所用标签的概况：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;!-- 基本配置 --\u0026gt;\r\u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;...\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;...\u0026lt;/version\u0026gt;\r\u0026lt;packaging\u0026gt;...\u0026lt;/packaging\u0026gt;\r\u0026lt;dependencies\u0026gt;...\u0026lt;/dependencies\u0026gt;\r\u0026lt;parent\u0026gt;...\u0026lt;/parent\u0026gt;\r\u0026lt;dependencyManagement\u0026gt;...\u0026lt;/dependencyManagement\u0026gt;\r\u0026lt;modules\u0026gt;...\u0026lt;/modules\u0026gt;\r\u0026lt;properties\u0026gt;...\u0026lt;/properties\u0026gt;\r\u0026lt;!-- 构建设置 --\u0026gt;\r\u0026lt;build\u0026gt;...\u0026lt;/build\u0026gt;\r\u0026lt;reporting\u0026gt;...\u0026lt;/reporting\u0026gt;\r\u0026lt;!-- 额外配置信息 --\u0026gt;\r\u0026lt;name\u0026gt;...\u0026lt;/name\u0026gt;\r\u0026lt;description\u0026gt;...\u0026lt;/description\u0026gt;\r\u0026lt;url\u0026gt;...\u0026lt;/url\u0026gt;\r\u0026lt;inceptionYear\u0026gt;...\u0026lt;/inceptionYear\u0026gt;\r\u0026lt;licenses\u0026gt;...\u0026lt;/licenses\u0026gt;\r\u0026lt;organization\u0026gt;...\u0026lt;/organization\u0026gt;\r\u0026lt;developers\u0026gt;...\u0026lt;/developers\u0026gt;\r\u0026lt;contributors\u0026gt;...\u0026lt;/contributors\u0026gt;\r\u0026lt;!-- 环境设置 --\u0026gt;\r\u0026lt;issueManagement\u0026gt;...\u0026lt;/issueManagement\u0026gt;\r\u0026lt;ciManagement\u0026gt;...\u0026lt;/ciManagement\u0026gt;\r\u0026lt;mailingLists\u0026gt;...\u0026lt;/mailingLists\u0026gt;\r\u0026lt;scm\u0026gt;...\u0026lt;/scm\u0026gt;\r\u0026lt;prerequisites\u0026gt;...\u0026lt;/prerequisites\u0026gt;\r\u0026lt;repositories\u0026gt;...\u0026lt;/repositories\u0026gt;\r\u0026lt;pluginRepositories\u0026gt;...\u0026lt;/pluginRepositories\u0026gt;\r\u0026lt;distributionManagement\u0026gt;...\u0026lt;/distributionManagement\u0026gt;\r\u0026lt;profiles\u0026gt;...\u0026lt;/profiles\u0026gt;\r\u0026lt;/project\u0026gt;\r坐标 在Maven中坐标就是为了定位一个唯一确定的 jar 包。\n构成坐标的三个要素：\n groupId：项目的组织名 artifactId：项目实际名称，非目录名称 version：当前项目或依赖jar包的版本号  如下描述：\n\u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.12.0\u0026lt;/version\u0026gt;\r打包格式 单个模块打包格式为war（用于java web 项目），还有一种格式为jar（用于java项目）。多模块项目时，根项目应设置为pom。\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r...\r\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r属性 配置maven会使用的属性，使用属性的格式：${prperties下的属性名}，直接使用占位符的值。设置属性，如下：\n\u0026lt;project\u0026gt;\r...\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;!-- Following project.-properties are reserved for Maven in will become elements in a future POM definition. --\u0026gt;\r\u0026lt;!-- Don't start your own properties properties with project. --\u0026gt;\r\u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt;\r\u0026lt;/properties\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r可以配置4种不同风格的属性：\n 环境变量 env.X，例如：${env.PATH} 项目变量 project.x，例如：${project.version} settings.xml文件中定义的变量 settings.x,例如：${settings.offline} Java系统属性，例如:${java.home} pom.xml中properteis里面  依赖 引入项目所需的依赖包。如何引入？导入依赖的坐标即可，如下描述：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r...\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt;\r\u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt;\r\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\r\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;\r\u0026lt;/dependency\u0026gt;\r...\r\u0026lt;/dependencies\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r type：引入依赖包的打包格式，一般忽略不写 scope：项目依赖包的作用域，有那么几个：compile、test、provided和runtime等。 optional: 表示可选依赖。决定是否向下传递，如果是true则不传递，如果是false就传递，默认 为false。     作用域 描述     compile 这是默认范围，如果没有指定则使用。 编译依赖项在所有类路径中都可用。 此外，这些依赖关系会传播到依赖项目。   test 这个作用域表示应用程序的正常使用不需要依赖，只在测试编译和执行阶段可用。 它不是传递性的。   provided 这很像 compile，但表明希望 JDK 或容器在运行时提供它。 它仅在编译和测试类路径上可用，并且不可传递。   runtime 此范围表示该依赖项不是编译所必需的，而是执行所必需的。 它在运行时和测试类路径中，但不在编译类路径中。    假如A依赖B，B依赖C，那么A间接依赖C\n依赖冲突时，发生：\n 如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以直接依赖的版本为准(就近原则) 如果直接依赖中包含有同一个坐标不同版本的资源依赖，以配置顺序下方的版本为准(就近原则)  排除依赖 假如项目X依赖项目 maven-embedder，maven-embedder 依赖项目 maven-core,但X不依赖项目 maven-core。所以在引入 maven-embedder时，要排除 maven-core。\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r...\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-embedder\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt;\r\u0026lt;exclusions\u0026gt;\r\u0026lt;exclusion\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;/exclusion\u0026gt;\r\u0026lt;/exclusions\u0026gt;\r\u0026lt;/dependency\u0026gt;\r...\r\u0026lt;/dependencies\u0026gt;\r...\r\u0026lt;/project\u0026gt;\r插件 插件配置概况如下：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;build\u0026gt;\r...\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt;\r\u0026lt;extensions\u0026gt;false\u0026lt;/extensions\u0026gt;\r\u0026lt;inherited\u0026gt;true\u0026lt;/inherited\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;classifier\u0026gt;test\u0026lt;/classifier\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;dependencies\u0026gt;...\u0026lt;/dependencies\u0026gt;\r\u0026lt;executions\u0026gt;...\u0026lt;/executions\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\r生命周期需要绑定插件而工作。例如：clean生命周期直接绑定maven-clean-plugin，site生命周期直接绑定maven-site-plugin。不同的是default生命周期，因指定打包格式不同而不同阶段绑定不同的插件。\npom:\n\u0026lt;phases\u0026gt;\r\u0026lt;install\u0026gt;\rorg.apache.maven.plugins:maven-install-plugin:2.4:install\r\u0026lt;/install\u0026gt;\r\u0026lt;deploy\u0026gt;\rorg.apache.maven.plugins:maven-deploy-plugin:2.7:deploy\r\u0026lt;/deploy\u0026gt;\r\u0026lt;/phases\u0026gt;\rjar:\n\u0026lt;phases\u0026gt;\r\u0026lt;process-resources\u0026gt;\rorg.apache.maven.plugins:maven-resources-plugin:2.6:resources\r\u0026lt;/process-resources\u0026gt;\r\u0026lt;compile\u0026gt;\rorg.apache.maven.plugins:maven-compiler-plugin:3.1:compile\r\u0026lt;/compile\u0026gt;\r\u0026lt;process-test-resources\u0026gt;\rorg.apache.maven.plugins:maven-resources-plugin:2.6:testResources\r\u0026lt;/process-test-resources\u0026gt;\r\u0026lt;test-compile\u0026gt;\rorg.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile\r\u0026lt;/test-compile\u0026gt;\r\u0026lt;test\u0026gt;\rorg.apache.maven.plugins:maven-surefire-plugin:2.12.4:test\r\u0026lt;/test\u0026gt;\r\u0026lt;package\u0026gt;\rorg.apache.maven.plugins:maven-jar-plugin:2.4:jar\r\u0026lt;/package\u0026gt;\r\u0026lt;install\u0026gt;\rorg.apache.maven.plugins:maven-install-plugin:2.4:install\r\u0026lt;/install\u0026gt;\r\u0026lt;deploy\u0026gt;\rorg.apache.maven.plugins:maven-deploy-plugin:2.7:deploy\r\u0026lt;/deploy\u0026gt;\r\u0026lt;/phases\u0026gt;\rwar:\n\u0026lt;phases\u0026gt;\r\u0026lt;process-resources\u0026gt;\rorg.apache.maven.plugins:maven-resources-plugin:2.6:resources\r\u0026lt;/process-resources\u0026gt;\r\u0026lt;compile\u0026gt;\rorg.apache.maven.plugins:maven-compiler-plugin:3.1:compile\r\u0026lt;/compile\u0026gt;\r\u0026lt;process-test-resources\u0026gt;\rorg.apache.maven.plugins:maven-resources-plugin:2.6:testResources\r\u0026lt;/process-test-resources\u0026gt;\r\u0026lt;test-compile\u0026gt;\rorg.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile\r\u0026lt;/test-compile\u0026gt;\r\u0026lt;test\u0026gt;\rorg.apache.maven.plugins:maven-surefire-plugin:2.12.4:test\r\u0026lt;/test\u0026gt;\r\u0026lt;package\u0026gt;\rorg.apache.maven.plugins:maven-war-plugin:2.2:war\r\u0026lt;/package\u0026gt;\r\u0026lt;install\u0026gt;\rorg.apache.maven.plugins:maven-install-plugin:2.4:install\r\u0026lt;/install\u0026gt;\r\u0026lt;deploy\u0026gt;\rorg.apache.maven.plugins:maven-deploy-plugin:2.7:deploy\r\u0026lt;/deploy\u0026gt;\r\u0026lt;/phases\u0026gt;\r配置额外的tomcat 插件：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;build\u0026gt;\r...\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.maven.tomcat\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt;\r\u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt;\r\u0026lt;uriEncoding\u0026gt;UTF-8\u0026lt;/uriEncoding\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\rtomcat插件的配置服务器端口为8080，web应用的路径为/，表示根应用。地址栏中URI使用UTF-8编码\n资源 指定资源位置，可用于使用代码生成的项目中，比如：mybatis-generator\n概况如下：\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;build\u0026gt;\r...\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;targetPath\u0026gt;META-INF/plexus\u0026lt;/targetPath\u0026gt;\r\u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;\r\u0026lt;directory\u0026gt;${basedir}/src/main/plexus\u0026lt;/directory\u0026gt;\r\u0026lt;includes\u0026gt;\r\u0026lt;include\u0026gt;configuration.xml\u0026lt;/include\u0026gt;\r\u0026lt;/includes\u0026gt;\r\u0026lt;excludes\u0026gt;\r\u0026lt;exclude\u0026gt;**/*.properties\u0026lt;/exclude\u0026gt;\r\u0026lt;/excludes\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;testResources\u0026gt;\r...\r\u0026lt;/testResources\u0026gt;\r...\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt;\r resources：是一个资源元素列表，每个元素都描述了包含与该项目相关联的文件的内容和位置。 targetPath：指定用于放置构建中的资源集的目录结构。 目标路径默认为基本目录。 将被打包到 JAR 中的资源通常指定的目标路径是 META-INF。 filtering：决定是否过滤此资源。过滤*.properties文件，除了使用filter，还可以可以通过propeties标签制定，或者命令行参数 \u0026ldquo;-Dname=value\u0026rdquo; directory：该元素的值定义了资源的位置。 构建的默认目录是 ${basedir}/src/main/resources。 includes：一组文件模式，使用 * 作为通配符，指定要作为资源包含在该指定目录下的文件。 excludes：与 includes 的结构相同，但指定要忽略的文件。 在包含和排除之间的冲突中，排除优先。 testResources：与resources及其子标签配置一样，针对是测试。  其他资源  Install Maven Introduction to the Build Lifecycle Settings Reference POM Reference  ","description":"简述Maven的生命周期和坐标，常用命令，依赖和插件配置","id":16,"section":"posts","tags":["maven"],"title":"Maven 入门","uri":"https://qinry.github.io/posts/2021/08/maven-basic/"},{"content":"创建分支 git branch \u0026lt;分支名\u0026gt;\ngit branch dev\r查看分支 git branch # 等价于git branch -a，显示所有分支\r效果：\n* 表示当前活跃的分支\n切换分支 git checkout \u0026lt;分支名\u0026gt;\ngit checkout dev\r效果：\n创建并切换到新分支\ngit checkout -b feature\r效果：\n合并分支 合并前的准备 假如在master分支，新建了sample.txt并提交，提交信息维 \u0026ldquo;init commit\u0026rdquo;\nsample.txt内容如下：\n1  创建sample.txt   用git log查看提交信息\n模拟两个分支的并行操作 切换到feature分支，在 sample.txt 追加新内容，并提交\n切换到dev分支，也在 sample.txt 也追加新内容\nmerge合并分支 切换回master分支，合并dev的提交到master。\ngit checkout master\rgit merge dev\r效果：\n此分支间若没有冲突，会自动处理合并，由于dev包含了master的记录，通过把master分支的位置移动到dev的最新分支，则会快进合并（fast-forward）\n解决合并时的冲突 git merge feature\r效果：\n提示master和feature冲突发生在sample.txt\n查看 sample.txt\n\u0026quot;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026quot;和\u0026quot;===========\u0026quot;之间表示当前分支的提交\n\u0026quot;=============\u0026quot;和\u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026quot;之间表示合并分支引入的提交\n处理冲突后，效果：\nrebase合并分支 git reset --hard HEAD~\rgit checkout feature\rgit rebase master\r效果：\n与使用merge合并分支时一样，处理冲突后\ngit add sample.txt\rgit rebase --continue\rgit checkout master\rgit merge feature\r效果：\n删除分支 git branch -d \u0026lt;要删除分支名\u0026gt;\ngit branch issue\rgit branch -d issue\r","description":"Git分支相关操作：创建、切换、合并、删除等等","id":17,"section":"posts","tags":null,"title":"Git 分支","uri":"https://qinry.github.io/posts/2021/08/git-branch/"},{"content":"一、集群架构 (1)所有的 Redis 节点彼此互联（PING-PONG 机制），内部使用二进制协议优化传输速度和带宽.\n(2)节点的 fail 是通过集群中超过半数的节点检测有效时整个集群才生效.\n(3)客户端与 Redis 节点直连,不需要中间 proxy 层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可\n(4)redis-cluster把所有的物理节点映射到 [0-16383]slot 上，cluster 负责维护 node\u0026lt;-\u0026gt;slot\u0026lt;-\u0026gt;value\nRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，Redis 先对 key 使用 CRC16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽， Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点\n二、心跳机制 (1)集群中所有 master 参与投票,如果半数以上 master 节点与其中一个 master 节点通信超过 (cluster-node-timeout)，认为该 master 节点挂掉。\n(2)什么时候整个集群不可用(cluster_state:fail)？\nØ 如果集群任意 master 挂掉,且当前 master 没有 slave ，则集群进入 fail 状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。\nØ 如果集群超过半数以上 master 挂掉，无论是否有 slave ，集群进入 fail 状态。\n三、搭建集群 前提有多个虚拟机，并装好了 Redis。搭建集群最少要 3 台主机，一台主机再配置从机的话，最少需要 6 台机器或虚拟机。不过可以一台机子有 6 个 Redis 实例。使用端口 7001~7006。\n首先，编写配置文件 redis.conf：cluster-enabled yes。还有按情况配置 port \u0026lt;端口号\u0026gt; 和 bind 0.0.0.0。\n接着，删除数据存放目录下持久化文件，重要持久化文件自行备份。启动 7001～7002 这六个 Redis 实例。如果防火墙未放行 Redis 服务的流量话，配置放行或者关闭防火墙。\n然后，创建集群\nredis-cli --cluster create \u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt; [\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt; ...] --cluster-replicas 1\r最后，连接集群\nredis-cli -h \u0026lt;ip\u0026gt; -p \u0026lt;port\u0026gt; -c\r查看集群信息，在运行的客户端内部执行命令 cluster info。\n查看集群节点信息，cluster nodes。\n四、jedis连接集群 maven引入相关依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.1\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r示例代码：\npublic static void main(String[] args) throws IOException { // 创建一连接，JedisCluster对象,在系统中是单例存在 Set\u0026lt;HostAndPort\u0026gt; nodes = new HashSet\u0026lt;HostAndPort\u0026gt;(); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7001)); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7002)); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7003)); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7004)); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7005)); nodes.add(new HostAndPort(\u0026quot;192.168.123.181\u0026quot;, 7006)); JedisCluster cluster = new JedisCluster(nodes);\r// 执行JedisCluster对象中的方法，方法和redis指令一一对应。\rcluster.set(\u0026quot;test1\u0026quot;, \u0026quot;test111\u0026quot;);\rString result = cluster.get(\u0026quot;test1\u0026quot;); System.out.println(result);\r//存储List数据到列表中\rcluster.lpush(\u0026quot;site-list\u0026quot;, \u0026quot;java\u0026quot;); cluster.lpush(\u0026quot;site-list\u0026quot;, \u0026quot;c\u0026quot;); cluster.lpush(\u0026quot;site-list\u0026quot;, \u0026quot;mysql\u0026quot;);\r// 获取存储的数据并输出\rList\u0026lt;String\u0026gt; list = cluster.lrange(\u0026quot;site-list\u0026quot;, 0 ,2); for(int i=0; i\u0026lt;list.size(); i++) {\rSystem.out.println(\u0026quot;列表项为: \u0026quot;+list.get(i)); }\r// 程序结束时需要关闭JedisCluster对象 cluster.close();\rSystem.out.println(\u0026quot;集群测试成功!\u0026quot;); }\r","description":"搭建Redis集群，jedis访问Redis集群","id":18,"section":"posts","tags":["redis"],"title":"Redis集群","uri":"https://qinry.github.io/posts/2021/07/redis-cluster/"},{"content":"一、Redis 持久化存储方式 由于 Redis 的值放在内存中，为防止突然断电等特殊情况的发生，需要对数据进行持久化备份。即将内存数据保存 到硬盘。\n1.1.RDB 持久化 RDB 是以二进制文件，是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。\nRedis 默认启用 RDB 存储，redis.conf 中的具体配置参数如下：\n#dbfilename:持久化数据存储在本地的文件\rdbfilename \u0026quot;dump.rdb\u0026quot;\r#dir:持久化数据存储在本地的路径，如果是在/usr/local/redis/redis-5.0.5/src下启动的redis-cli，则数据会存储在当前src目录下\rdir \u0026quot;/var/lib/redis/6379\u0026quot;\r##snapshot触发的时机，save\r##如下为900秒后，至少有一个变更操作，才会snapshot\r##对于此值的设置，需要谨慎，评估系统的变更操作密集程度\r##可以通过“save”来关闭snapshot功能 #save时间，以下分别表示更改了1个key时间隔900s进行持久化存储;更改了10个key300s进行存储;更改10000个 key60s进行存储。\rsave 900 1\rsave 300 10\rsave 60 10000 ##当snapshot时出现错误无法继续时，是否阻塞客户端「变更操作」，「错误」可能因为磁盘已满/磁盘故障/OS级别异常等 stop-writes-on-bgsave-error yes ##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着「额外的cpu消耗」，同时也意味这较小的文件尺寸以及较短的网 络传输时间\rrdbcompression yes\r1.2.AOF 持久化 Append-Only File，将「操作 + 数据」以格式化指令的方式追加到操作日志文件的尾部，在 append 操作返回后(已经写入到文件或者将要写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程;\n当 server 需要数据恢复时，可以直接 replay 此日志文件，即可还原所有的操作过程。AOF 相对可靠，AOF 文件内容是字符串，非常容易阅读和解析。\nAOF 的特性决定了它相对比较安全，如果你期望数据更少的丢失，那么可以采用 AOF 模式。\n如果 AOF 文件正在被写入时突然 server 失效，有可能导致文件的最后一次记录是不完整，你可以通过手工或者程序的方式去检测并修正不完整的记录。\n如果你的 redis 持久化手段中有 aof，那么在 server 故障失效后再次启动前，需要检测 aof 文件的完整性。\nAOF 默认关闭，开启需要修改配置文件 redis.conf : appendonly yes\n##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能 ##只有在“yes”下，aof重写/文件同步等特性才会生效\rappendonly yes\r##指定aof文件名称 appendfilename \u0026quot;appendonly.aof\u0026quot;\r##指定aof操作中文件同步策略，有三个合法值:always everysec no,默认为everysec\rappendfsync everysec ##在aof-rewrite期间，appendfsync是否暂缓文件同步，\u0026quot;no\u0026quot;表示「不暂缓」，“yes”表示「暂缓」，默认为“no” no-appendfsync-on-rewrite no\r##aof文件rewrite触发的最小文件尺寸(mb,gb),只有aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”\rauto-aof-rewrite-min-size 64mb\r##相对于「上一次」rewrite，本次rewrite触发时aof文件应该增长的百分比。 ##每一次rewrite之后，Redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后 ##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。\rauto-aof-rewrite-percentage 100\r1.3.AOF 与 RDB 区别 RDB 的优缺点\n优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能\n缺点：RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候\nAOF 的优缺点\n优点：可以保持更高的数据完整性，如果设置追加 file 的时间是 1s，如果 Redis 发生故障，最多会丢失1s的数据;且如果日志写入不完整支持 redis-check-aof 来进行日志修复;AOF文件没被 rewrite 之前(文件过大时会对命令进行 合并重写)，可以删除其中的某些命令(比如误操作的 flushall)。\n缺点：AOF 文件比 RDB 文件大，且恢复速度慢。\n二、主从复制 2.1.特点   持久化保证了即使Redis服务重启也不会丢失数据，但是当 Redis 服务器的硬盘损坏了可能会导致数据丢失，通过Redis的主从复制机制就可以避免这种单点故障(单台服务器的故障)。\n  主Redis中的数据和从上的数据保持实时同步,当主 Redis 写入数据时通过主从复制机制复制到两个从服务上。\n  主从复制不会阻塞 master，在同步数据时，master 可以继续处理 client 请求.\n  主机 master 配置:无需配置\n  2.2.搭建主从复制 搭建主从复制，主机是不用配置，只配置从机即可。\n前提有多台虚拟机，或者在一台搭建多个 Redis 虚拟主机，这个要多个 Redis 副本\n首先，从机修改配置文件 redis.conf: replicaof \u0026lt;主机ip\u0026gt; \u0026lt;主机端口号\u0026gt;\n如有需要，则修改 bind 和 port 等信息。\n接着，清除从机的持久化文件\n最后启动从机\n查看主从关系信息，客户单内部运行命令 info replication。\n注意：\n 主机一旦发生增删改操作，那么从机会自动将数据同步到从机中 从机不能执行写操作,只能读  2.3.复制过程原理  当从库和主库建立 MS (master slaver)关系后，会向主数据库发送SYNC命令; 主库接收到 SYNC 命令后会开始在后台保存快照(RDB 持久化过程)，并将期间接收到的写命令缓存起来; 快照完成后,主 Redis 会将快照文件和所有缓存的写命令发送给从 Redis; 从 Redis 接收到后，会载入快照文件并且执行收到的缓存命令; 主 Redis 每当接收到写命令时就会将命令发送从 Redis，保证数据的一致;  2.4.问题解决 主从复制过程中出现宕机的解决办法：\n  从机宕机：直接重启\n  主机宕机：从机执行 slaveof no one 命令，断开主从关系并提升为主库；当原先主机修好后，重启后，执行 slaveof 命令，原先主机设置为从机。\n  三、哨兵模式 3.1.特点 哨兵的作用就是对 Redis 系统的运行情况监控，它是一个独立进程,它的功能:\n 监控主数据库和从数据库是否运行正常; 主数据出现故障后自动将从数据库转化为主数据库;  3.2.搭建 前提有多台主机，最开始只需在配置从机，在从机启动哨兵进程监控主机。\n首先，配置哨兵配置文件，可以从源码复制sentinel.conf或自行创建sentinel.conf到/etc/redis/sentinel.conf。配置 sentienl.conf : sentinel monitor \u0026lt;监控名\u0026gt; \u0026lt;主机ip\u0026gt; \u0026lt;主机端口\u0026gt; \u0026lt;最低通过票数\u0026gt;。\n可以按需配置 daemonize yes 和 logfile \u0026quot;/var/log/redis_sentinel.log\u0026quot;。\n接着，启动哨兵前，确保主从服务正常，启动主机服务，再启动从机服务。\n最后，执行 redis-sentinel /etc/redis/sentinel.conf\n注意，每次修改 sentinel.conf，都要重新启动 redis-sentinel\n当主机宕机，哨兵进程会把从库自动提升为主库，并自动修改主从库的 redis.conf。下次原先主机重启服务，会自动变成从机服务。\n","description":"Redis 两种持久化方式，主从复制和哨兵模式","id":19,"section":"posts","tags":["redis"],"title":"Redis 持久化","uri":"https://qinry.github.io/posts/2021/07/redis-persistence/"},{"content":"简单介绍Redis。它是一款键值数据库。它还是非关系型数据库（Nosql）。常常用作内存缓存，应用于频繁的读写场景中。\n一、基本数据结构 Redi常用的五种数据类型。分别为字符串（strings）、列表（lists）、无序集合（sets）、有序集合（zsets）、哈希（hashs）。\n二、常用命令 2.1.字符串的命令 # 一般的字符串\r# 设置字符串类型key为value\rset key value\r# 获取key/value\rget key\r# 设置多个key\rmset key value [key value ...]\r# 获取多个key/value\rmget key [key ...]\r# 删除key\rdel key\r# 字符串数字\r# 初始是0，每运行就加1，注意第一次运行后的结果为1\rincr key\r# 初始是0，每运行减1，注意第一次运行后的结果为-1\rdecr key\r# 定长增减，每次增减number\rincrby key number\rdecrby key number\r2.2.哈希的命令 # 设置哈希类型key的field为value\rhset key field value # 获取key的field\rhget key field\r# 设置key的多个field\rhmset key field value [field value ...]\r# 获取key多个field\rhmget key field [field ...]\r# 获取key所有的field\rhgetall key\r# 删除key的某个或多个field\rhdel key field [field ...]\r2.3.列表的命令 # 向列表key左端加元素value\rlpush key value [value ...]\r# 从列表key左端弹出元素\rlpop key\r# 向列表key右端加元素value\rrpush key value [value ...]\r# 从列表key右端弹出元素\rrpop key\r# 获取列表key元素的个数\rllen key\r# 查看列表key下标start到stop（不包括）的元素，下标从0开始，特殊地，下标-1表示最后一个元素\rlrange key start stop\r2.4无序集合的命令 # 向集合key添加元素member\rsadd key member [member ...]\r# 从集合key指定删除元素member\rsrem key member [member ...]\r# 获取所有元素\rsmembers key\r# 判断元素是否在集合中\rsismember key member\r2.5.有序集合的命令 # 设置有序集合key的元素及其分数score\rzadd key score member [score member ...]\r# 查询集合中start到stop范围内的元素[可带分数]，元素按降序返回\rzrevrange key start stop [withscores]\r# 获取key中元素的分数\rzscore key member\r# 删除元素\rzrem key member [member ...]\r# 给key元素的分数加减分数score\rzincrby key score member\r2.6.HyperLogLog的命令 # 往HyperLogLog类型的key添加元素element\rpfadd key element [element ...]\r# 获取key中唯一元素的估计个数\rpfcount key [key ...]\rpfmerget destkey sourcekey [sourcekey ...]\r2.7.其他常用命令 # 查询符合pattern的所有key\rkeys pattern\r# 判断key是否存在\rexists key\r# 删除key\rdel key\r# 重命名\rrename oldkey newkey\r# 判断key的数据类型\rtype key\r# 设置key的有效时间\rexpire key seconds\r# 查看key有效时间\rttl key\r# 清除key的生存时间\rpersist key\r# 获取服务器信息和统计\rinfo\r# 删除当前选择的数据库中所有key，谨慎使用\rflushdb\r# 删除所有数据库的所有key\rflushall\r# Redis默认有16个数据库，从0到15，选择下标为index数据库\rselect index\r# key从当前数据库移到下标为index的数据库\rmove key index\r2.8.事务管理 # 开启事务\rmulti\r# 将多个命令入队到事务中\r...\r# 触发事务\rexec\r2.9.发布/订阅 # 在某一个客户端上订阅频道channel，等待接受发布者发送的消息\rsubscribe channel\r# 在某一个客户端在channel发布消息message给所有此频道的订阅者\rpublish channel message\r三、jedis连接Redis 首先，在项目中使用maven引入jedis依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.1\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r其次，确保Redis所在的服务器与本地连通，防火墙允许本地流量发送给服务器，服务器可以发送流量给本地，可以选择关闭它。\n最后编写代码，核心代码如下：\nJedis jedis = null;\rtry {\rjedis = new Jedis(\u0026quot;192.168.123.181\u0026quot;,6379);\r// jedis.auth(\u0026quot;password\u0026quot;);\rjedis.set(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;);\rString bar = jedis.get(\u0026quot;foo\u0026quot;);\rSystem.out.println(\u0026quot;foo:\u0026quot;+bar);\r} catch (Exception e) {\re.printStackTrace();\r} finally {\rif (jedis != null) {\rjedis.close();\r}\r}\r运行代码，如果有JedisConnectionException，请检查Redis的配置文件，检查bind是否绑定服务器的ip，或者设置成0.0.0.0\n使用jedis连接池，核心代码如下：\nJedisPoolConfig config = new JedisPoolConfig();\rconfig.setMaxIdle(10);\rconfig.setMaxTotal(20);\rJedisPool pool = null;\rJedis jedis = null;\rtry {\rpool = new JedisPool(config, \u0026quot;192.168.123.181\u0026quot;,6379);\rjedis = pool.getResource();\r// jedis.auth(\u0026quot;password\u0026quot;);\rjedis.set(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;);\rString foo = jedis.get(\u0026quot;foo\u0026quot;);\rSystem.out.println(\u0026quot;foo=\u0026quot;+foo);\r} catch (Exception e) {\re.printStackTrace();\r} finally {\rif (jedis != null) {\rjedis.close();\r}\rif (pool != null) {\rpool.close();\r}\r}\r四、缓存雪崩、缓存击穿、缓存穿透问题 什么是缓存?\n广义的缓存就是在第一次加载某些可能会复用数据的时候，在加载数据的同时，将数据放到一个指定的地点做保 存。再下次加载的时候，从这个指定地点去取数据。这里加缓存是有一个前提的，就是从这个地方取数据，比从数 据源取数据要快的多。\njava狭义一些的缓存，主要是指三大类\n 虚拟机缓存(ehcache，JBoss Cache) 分布式缓存(redis，memcache) 数据库缓存\n正常来说，速度由上到下依次减慢  4.1.缓存雪崩 缓存雪崩通俗简单的理解就是:由于原有缓存失效(或者数据未加载到缓存中)，新缓存未到期间(缓存正常从 Redis 中获取)所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力， 严重的会造成数据库宕机，造成系统的崩溃。\n解决方案：\n 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据\n和写缓存，其他线程等待。虽然能够在一定的程度上缓解了数据库的压力但是与此同时又降低了系统的吞吐量。  代码示例说明：\npublic Users getByUsers(Long id) {\r// 1.先查询redis\rString key = this.getClass().getName() + \u0026quot;-\u0026quot; + Thread.currentThread().getStackTrace() [1].getMethodName()\r+ \u0026quot;-id:\u0026quot; + id;\rString userJson = redisService.getString(key);\rif (!StringUtils.isEmpty(userJson)) {\rUsers users = JSONObject.parseObject(userJson, Users.class);\rreturn users;\r}\rUsers user = null;\rtry {\rlock.lock();\r// 查询db\ruser = userMapper.getUser(id);\rredisService.setSet(key, JSONObject.toJSONString(user));\r} catch (Exception e) {\r} finally { lock.unlock(); // 释放锁 }\rreturn user;\r}\r分析用户的行为，不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。  4.2.缓存击穿 对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。 这个时候，需要考虑一个问题:缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是 很多key。\n热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。\n解决办法:\n 使用锁，单机用synchronized,lock等，分布式用分布式锁。 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。  4.3.缓存穿透 缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中 率问题。\n解决方案:\n  如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。\n  把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，既可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。\n  代码示例说明：\npublic String getByUsers2(Long id) {\r// 1.先查询redis\rString key = this.getClass().getName() + \u0026quot;-\u0026quot; + Thread.currentThread().getStackTrace()[1].getMethodName()+ \u0026quot;-id:\u0026quot; + id;\rString userName = redisService.getString(key);\rif (!StringUtils.isEmpty(userName)) {\rreturn userName;\r} System.out.println(\u0026quot;######开始发送数据库DB请求########\u0026quot;); Users user = userMapper.getUser(id);\rString value = null;\rif (user == null) {\r// 标识为null\rvalue = \u0026quot;\u0026quot;; // 设置默认值\r} else {\rvalue = user.getName();\r} redisService.setString(key, value);\rreturn value;\r}\r五、分布式锁 5.1.使用分布式锁的条件   系统是一个分布式系统(关键是分布式，单机的可以使用ReentrantLock或者synchronized代码块来实现)\n  共享资源(各个系统访问同一个资源，资源的载体可能是传统关系型数据库或者NoSQL)\n  同步访问(即有很多个进程同时访问同一个共享资源。)\n  5.2.应用场景 分布式锁应该用来解决分布式情况下的多进程并发问题才是最合适的。\n有这样一个情境，线程A和线程B都共享某个变量X。\n如果是单机情况下(单JVM)，线程之间共享内存，只要使用线程锁就可以解决并发问题。\n如果是分布式情况下(多JVM)，线程A和线程B很可能不是在同一JVM中，这样线程锁就无法起到作用了，这时候 就要用到分布式锁来解决。\n分布式锁可以基于很多种方式实现，比如zookeeper、redis\u0026hellip;。不管哪种方式，他的基本原理是不变的:用一个状态值表示锁，对锁的占用和释放通过状态值来标识。\n5.3.使用Redis的分布式锁 setnx和getset命令来获取锁，锁的信息设置成锁有效的截止时间。expire设置有效时间。del来释放锁。\n注意：\n  锁只能有一个进程占有\n  锁只能有锁的持有者释放\n  锁必须设置过期时间\n  5.3.1.setnx命令 Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争 关系。Redis的setnx命令可以方便的实现分布式锁。\n# 当key不存在时，设置为value，否则不做任何动作\rsetnx key value\r# 成功返回Integer 1.\r# 失败返回Integer 0.\r如果setnx返回1，说明客户端已经获得了锁，setnx将键的值设置为锁的超时时间(当前时间 + 锁的有效时间)。 之后客户端可以通过del来释放锁。\n如果setnx返回0，说明key已经被其他客户端上锁了。如果锁是非阻塞(non blocking lock)的，我们可以选择返回调用，或者进入一个重试循环，直到成功获得锁或重试超时(timeout)。\n5.3.2.getset命令 # 将给定key设置为value，返回旧值，旧值不存在返回的是nil\r# 如果key存在但不是字符串，则返回错误\rgetset key value\r代码示例说明：\npublic static boolean lock(String lockName) {\rJedis jedis = RedisPool.getJedis(); //lockName可以为共享变量名，也可以为方法名，主要是用于模拟锁信息 System.out.println(Thread.currentThread() + \u0026quot;开始尝试加锁!\u0026quot;);\rLong result = jedis.setnx(lockName, String.valueOf(System.currentTimeMillis() + 5000)); if (result != null \u0026amp;\u0026amp; result.intValue() == 1){\rSystem.out.println(Thread.currentThread() + \u0026quot;加锁成功!\u0026quot;); jedis.expire(lockName, 5);\rSystem.out.println(Thread.currentThread() + \u0026quot;执行业务逻辑!\u0026quot;);\rjedis.del(lockName);\rreturn true;\r} else {\r//判断是否死锁\rString lockValueA = jedis.get(lockName); //得到锁的过期时间，判断小于当前时间，说明已超时但是没释放锁，通过下面的操作来尝试获得锁。下面逻辑防止死锁 [已经过期但是没有释放锁的情况]\rif (lockValueA != null \u0026amp;\u0026amp; Long.parseLong(lockValueA) \u0026lt; System.currentTimeMillis()){ String lockValueB = jedis.getSet(lockName,\rString.valueOf(System.currentTimeMillis() + 5000)); //这里返回的值是旧值，如果有的话。之前没有值就返回null,设置的是新超时。\rif (lockValueB == null || lockValueB.equals(lockValueA)){ System.out.println(Thread.currentThread() + \u0026quot;加锁成功!\u0026quot;); jedis.expire(lockName, 5); System.out.println(Thread.currentThread() + \u0026quot;执行业务逻辑!\u0026quot;); jedis.del(lockName);\rreturn true;\r} else {\rreturn false;\r}\r} else {\rreturn false;\r} }\r}\r","description":"Redis 常用命令；jedis 连接 Redis；缓存雪崩、缓存击穿、缓存穿透问题；分布式锁","id":20,"section":"posts","tags":["redis"],"title":"Redis 入门","uri":"https://qinry.github.io/posts/2021/07/redis/"},{"content":"什么是JDBC JDBC是执行SQL的java API，为关系型数据库提供访问。JDBC可以在更大平台使用像Windows、Mac、Unix等等\nJDBC体系由JDBC驱动和JDBC API构成。通过驱动管理器可以连接不同结构的数据库管理系统。\nJDBC可以做什么  创建数据库连接 创建SQL语句 执行SQL查询 查看或修改记录  JDBC的核心组件  DriverManager:通过适合的通讯子协议，Java应用程序和相应数据库驱动程序匹配连接 Driver:处理与数据库服务器的连接，客户端程序很少使用 Connection:通讯的上下文，可以获取连接信息，可以设置MySQL非自动提交开启事务 Statement:将SQL语句提交到数据库 ResultSet:执行查询语句得到的结果集，通过它可以检索数据 SQLException:处理数据相关的异常  JDBC基本使用 使用前需要，导包\n 注册JDBC驱动  1  Class.forName(\u0026#34;com.mysql.jdbc.cj.Driver\u0026#34;);   数据库配置  1 2 3  String url = \u0026#34;jdbc:mysql://localhost:3306/demodb?ServerTimezone=UTC\u0026#34;; String username = \u0026#34;mysql\u0026#34;; String password = \u0026#34;password\u0026#34;;   假定mysql服务器监听3306端口，数据库为demodb，服务器时区为UTC。用户名为username，密码为password。\n打开连接  1  Connection conn = DriverManager.getConnection(url, username, password);   打开连接用到上面的三个配置信息\n创建状态通道  1  Statement stmt = conn.createStatement();    执行语句\nquery\rupdate\r\r1 2  String sql = \u0026#34;select id,name from user\u0026#34;; ResultSet rs = stmt.executeQuery(sql);   \r\r1 2 3  String name = \u0026#34;xiaoming\u0026#34;; String sql2 = \u0026#34;insert into user(name) values(\u0026#34; + name + \u0026#34;)\u0026#34;; int count = stmt.executeUpdate(sql2);   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"636243d05accdb7d\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r\nselect语句使用executeQuery，update、insert、delete语句使用executeUpdate\n  得到结果\nquery\rupdate\r\r1 2 3 4 5  while (rs.next()) { int id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); System.out.println(id + \u0026#34; - \u0026#34; + name); }   \r\r1  System.out.println(\u0026#34;改变的行数：\u0026#34;+count);   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"2103206c9ea532c3\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r\n  select语句得到使ResultSet的结果，其他语句得到是int类型表示，影响数据库的行数\n关闭连接  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  Connection conn = null; Statement stmt = null; ResultSet rs = null; try { //... } catch(SQLException e) { //... } finally { try { if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); } } catch(IOException e1) { } }   使用预状态通道避免SQL注入 PreparedStatement是Statement的子类，支持参数化查询，来防止SQL注入攻击。PreparedStatement还可以预编译SQL语句，使执行SQL的效率更高点\n1 2 3 4 5  int id = 2; String sql = \u0026#34;select id, name from user where id=?\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setInt(1, id); rs = pstmt.executeQuery();   JDBC的事务 事务常常见于转账\n 开启事务  1  conn.setAutoCommit(false);   关闭自动提交\n回滚  遇到异常需要回滚\n1 2 3 4 5 6  conn.rollback(); // 或 设置安全点 // Savepoint s1 = conn.setSavepoint(\u0026#34;s1\u0026#34;); // ... // 归滚到安全点 // conn.rollback(s1);   提交  1  conn.commit();   JDBC批处理 一次请求，执行多条语句，使用批处理效率更高\n Statement的批处理  1 2 3 4 5 6 7 8 9 10  Statement stmt = conn.createStatement(sql); conn.setAutoCommit(false); stmt.addBatch(INSERT_SQL); stmt.addBatch(INSERT_SQL_2); int[] count = stmt.executeBatch(); conn.commit();   PreparedStatement的批处理  1 2 3 4 5 6 7 8 9 10 11 12 13  conn.setAutoCommit(false); String sql = \u0026#34;insert into user(name) values(?)\u0026#34;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, \u0026#34;xiaohong\u0026#34;); pstmt.addBatch(); pstmt.setString(1,\u0026#34;xiaolei\u0026#34;); pstmt.addBatch(); pstmt.executeBatch(); conn.commit();   数据库连接池 连接池：系统初始化，将连接作为对象存储在内存中，当有用户需要连接数据库时，第一时间不是创建连接，而是查看连接池是否由空闲的连接，如果有直接使用。使用连接完毕，不是马上关闭资源，而是暂时放回连接池，以便下一次请求使用。\n连接池几个重要的参数：\n 初始连接数:连接池启动时的连接数 最小连接数:不管释放空闲连接，数据库至少保持的连接数 最大连接数:大于它的连接排队等待 最大等待时间:池中没有可用连接时，连接池等待连接回归的最大时间  有三个常用的连接池\n c3p0 druid HikariCP  c3p0 首先，导入数据库驱动相关的jar包和c3p0的jar包.\n例如：\nmysql-connector-java-5.0.8.jar\nc3p0-0.9.1.2.jar\nc3p0要使用一个默认的配置文件c3p0-config.xml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;c3p0-config\u0026gt; \u0026lt;!-- 默认配置，如果没有指定则使用这个配置 --\u0026gt; \u0026lt;default-config\u0026gt; \u0026lt;!-- 基本配置 --\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34;\u0026gt;com.mysql.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34;\u0026gt;jdbc:mysql://localhost:3306/lxq?serverTimezone=UTC\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34;\u0026gt;root\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;password\u0026lt;/property\u0026gt; \u0026lt;!--扩展配置--\u0026gt; \u0026lt;!-- 连接超过30秒报错--\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34;\u0026gt;30000\u0026lt;/property\u0026gt; \u0026lt;!--30秒检查空闲连接 --\u0026gt; \u0026lt;property name=\u0026#34;idleConnectionTestPeriod\u0026#34;\u0026gt;30\u0026lt;/property\u0026gt; \u0026lt;!-- 30秒不使用丢弃--\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34;\u0026gt;10\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxIdleTime\u0026#34;\u0026gt;30\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34;\u0026gt;100\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34;\u0026gt;10\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxStatements\u0026#34;\u0026gt;200\u0026lt;/property\u0026gt; \u0026lt;/default-config\u0026gt; \u0026lt;!-- 命名的配置 --\u0026gt; \u0026lt;named-config name=\u0026#34;abc\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34;\u0026gt;com.mysql.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34;\u0026gt;jdbc:mysql://localhost:3306/lxq?serverTimezone=UTC\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34;\u0026gt;root\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34;\u0026gt;111\u0026lt;/property\u0026gt; \u0026lt;!-- 如果池中数据连接不够时一次增长多少个 --\u0026gt; \u0026lt;property name=\u0026#34;acquireIncrement\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;initialPoolSize\u0026#34;\u0026gt;20\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34;\u0026gt;10\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34;\u0026gt;40\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxStatements\u0026#34;\u0026gt;20\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maxStatementsPerConnection\u0026#34;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;/named-config\u0026gt; \u0026lt;/c3p0-config\u0026gt;   加载配置文件\n1 2 3 4 5  // 加载c3p0-config.xml中的default-config ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 加载c3p0-config.xml中的named-config // ComboPooledDataSource dataSource = new ComboPooledDataSource(\u0026#34;abc\u0026#34;);    从数据源中获取连接\n1  Connection conn = dataSource.getConnection();   其他与JDBC操作无差别\ndruid 首先，同样导入数据库驱动相关的jar包和druid的jar包.\n例如：\nmysql-connector-java-5.0.8.jar\ndruid-1.0.9.jar\n需要数据库配置相关的properties后缀的文件，比如db.properties\n# 驱动类名\rdriverClassName = com.mysql.cj.jdbc.Driver\r# 数据库URL\rurl = jdbc:mysql://localhost:3306/lxq?serverTimezone=UTC\r# 数据库用户名\rusername = root\r# 数据用户密码\rpassword = password\r# 初始连接数\rinitialSize=5\r# 最大活跃连接数\rmaxActive = 10\r# 最小空闲连接数\rminIdle = 5\r# 最大等待连接时间，单位毫秒\rmaxWait = 3000\r# 是否测试空闲连接\rtestWhileIdle = false\r1 2 3 4  InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(\u0026#34;db.properties\u0026#34;); Properties properties = new Properties(); properties.load(in); DruidDataSource dataSource = DruidDataSourceFactory.createDataSource(properties);   ","description":"使用JDBC连接MySQL数据库，创建SQL以及执行，批处理还有开启事务，入门c3p0和druid连接池","id":21,"section":"posts","tags":["第三方类库","mysql"],"title":"JDBC的使用","uri":"https://qinry.github.io/posts/2021/04/java-jdbc/"},{"content":"一、事务的语法 非常简单\nset autocommit = 0; -- 关闭自动提交\rstart tansaction; -- 事务开始，也可以换成begin;\r... -- 一系列SQL语句完成一个操作\r-- 当执行commit或rollback，事务就结束了\rcommit; -- 提交当前的修改\rrollback;\r...\rset autocommit = 1; -- 恢复自动提交\r-- 可以在事务过程，设置保留点，方便回滚到灵活的位置\rsavepoint p1;\rrollback to p1;\r二、事务四大特性 事务重要的特性（ACID），原子性，一致性，隔离性，持久性。\n 原子性(Atomicity)\n事务的进行不可分割，是一个原子性的操作序列单元。事务中的操作要么全部执行成功，要么全部执行失败。如果事务中间环节出错，回滚事务开始的状态。 一致性(Consistency)\n事务的执行前后不能破坏数据库数据的完整性和一致性。\n一个事务执行前后，数据库必须处于一致性的状态，也就是数据在操作无误、逻辑无误的情况下，期望结果却与实际结果不一致，也就是数据错乱了。比如：把一个数据原为1000，减掉500，提交后查询数据不是500，说明事务受到了干涉，使事务不一致性。事务应该保持一致性。 隔离性(Isolation)\n在并发环境下，并发的事务互相隔离。不同事务处理相同的数据都有自己完整的数据空间。 持久性(Duration)\n事务一旦提交，就数据库的数据就永久保存下来。即使发生服务器宕机或崩溃等故障。数据库重启，就能恢复事务结束后的状态。  三、事务的三大并发问题 事务面临的三大并发问题，脏读，不可重复读，幻读。\n 脏读  事务A读到了事务B未提交的数据。比如事务A和事务B，A读取B更新的数据，B回滚撤销更新，A读到了脏数据。\n 不可重复读  同一个事务中读取某表某行的数据，多次查询得到的结果不一样。比如事务A和事务B，A多次读取数据，B在A读取过程中，更新数据并提交，导致A多次读取同一处数据，结果不一致。（不一定是错误，只是场合不对）\n 幻读（虚读）  事务A查询过程中，读取到了事务B插入后的数据或删除后的数据，导致前后读取不一致。（影响的是行，多了一行，少了一行）\n四、事务隔离级别 数据库的事务存在一些隔离级别来解决一些并发问题，不同问题应该选择合适的隔离级别。\n   隔离级别 脏读 不可重复度 幻读     读未提交(READ_UNCOMMITTED) ✓ ✓ ✓   读已提交(READ_COMMITTED) ✗ ✓ ✓   可重复读(REPEATABLE_READ) ✗ ✗ ?   顺序读(SERIALIZABLE) ✗ ✗ ✗    从上往下，隔离级别越高，并发安全越高，但并发性越差。一般数据默认级别为读已提交或可重复读。\n查询当前会话的事务隔离级别\nselect @@tx_isolation;\rselect @@transaction_isolation; -- mysql8的命令\r设置当前会话的事务隔离级别\nset session transaction isolation level read uncommited;\rset session transaction isolation level read commited;\rset session transaction isolation level repeatable read;\rset session transaction isolation level serializable;\r一一介绍隔离级别\n 读未提交  事务A正处理某一数据，对其更新但未提交，事务未完成；事务B能够访问到未提交新的数据，也就是会出现脏读。这个隔离级别适合只读的事务。\n 读已提交  不同事务只能读到已提交的数据。不会出现脏读，事务重复读取数据的过程中，其他事务提交了数据修改，那么重复读会出现结果前后不一致。无法解决不可重复读的问题。\n 可重复读  保证事务处理，多次读取同一处数据，同一数据的值与事务开始一致。解决脏读和不可重复读，但可能出现幻读。\n 顺序读  事务排队处理，不能并发，就不会出现并发问题，安全但效率低。\n五、不同隔离级别锁 行级锁：把一个表的行上锁，只能有一个事务处理这个行。\n间隙锁：一个在索引记录之间的间隙上的锁。保证某个间隙内的数据在锁定情况下不会发生任何变化。\n 读未提交  有行级锁，无间隙锁，可读未提交数据\n 读提交  有行级锁，无间隙锁，读不到未提交的数据\n 可重复读  有行级锁，有间隙锁，每次读取的数据一致，可能有幻读\n 序列化  有行级锁，也有间隙锁，读表的时候上锁。\n六、隐式提交 DDL、DML、DCL、DQL都是隐式提交，在执行这些语句就相当于已经执行了commit，其实可以理解为数据库自动提交了。\n七、数据库SQL优化 1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引\n2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫\n描，如：\nselect 属性2 from 表名 where 属性1 is null;\r最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.\n备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。\n3.应尽量避免在 where 子句中使用 != 或 \u0026lt;=\u0026gt; 操作符，否则引擎将放弃使用索引而进行全表扫描。\n4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：\n可以这样查询：\nselect id from t where num = 10 union all select id from t where Name = 'admin';\r5.in 和 not in 也要慎用，否则会导致全表扫描，如：\nselect id from t where num in(1,2,3);\r对于连续的数值，能用 between 就不要用 in 了：\nselect id from t where num between 1 and 3;\r很多时候用 exists 代替 in 是一个好的选择。\n6.select语句避免使用星号(*)。\n","description":"主要内容MySQL事务的语法、特性、并发问题、隔离级别、锁与SQL优化，","id":22,"section":"posts","tags":["事务","mysql"],"title":"MySQL事务与SQL优化","uri":"https://qinry.github.io/posts/2021/03/transaction/"},{"content":"一、JSON概述 JSON(JavaScriptObject Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。已经替代了过去使用的XML，作为流行的数据传输格式。\n二、语法 实例：\n1 2 3 4 5  { \u0026#34;name\u0026#34;: \u0026#34;约翰克里斯托夫\u0026#34;, \u0026#34;info\u0026#34;: \u0026#34;德国批判主义音乐家的一生\u0026#34;, \u0026#34;price\u0026#34;: 102 }   一对{}表示一个对象，对象里面可以有很多属性，用键值对表示。键必须是用\u0026quot;\u0026quot;包围的字符串，值可以是字符串、对象、数字、布尔值（true/false）、null和数组。\n一对[]表示一个数组，里面可以包含任何类型，比如字符串、数字、对象、布尔值、null，还可以内嵌一个数组，它们之间用,分开就可以了，例如：\n1  [\u0026#34;a\u0026#34;, 1, { \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;:18 }, [3, true, null, 3.14]]   特殊地，单独的数组、数字、字符串都是合法的。例如：\n1 2 3 4 5  [\u0026#34;佳得乐\u0026#34;, \u0026#34;可乐\u0026#34;, \u0026#34;尖叫\u0026#34;] 3.14 3 true \u0026#34;hello json\u0026#34;   三、解析 Java由于官方没有提供解析JSON的类库，但有两个知名的第三方库，Gson和Fastjson。Gson 是 Google 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库。Fastjson 是一个性能很好的 Java 语言实现的 JSON 解析器和生成器，来自阿里巴巴的工程师开发。\nGson的使用  根据Gson的github地址https://github.com/google/gson/，下载jar包并导入到自己的项目中。  点击Gson jar downloads进入下一个页面\n点击Downloads\u0026gt;jar下载。\n 导入IDEA  在项目的根目录添加新文件夹lib，把包添加到这里。如下一系列图所示：\n如果模块有你导入的模块，可以忽略这一步，没有如下进行：\n 使用Gson  gson有两个常用的方法，解析json的fromJson方法，生成json的toJson方法。\n用法示例：\n定义JSON解析和生成会用到的类型：\nimport java.util.Objects;\r/**\r* @Author: lixiaoqin\r* @Description:\r* @Date Created in 2021-02 23:56\r* @Modified By:\r*/\rpublic class Book {\rprivate String id;\rprivate String name;\rprivate String info;\r@Override\rpublic String toString() {\rreturn \u0026quot;Book{\u0026quot; +\r\u0026quot;id='\u0026quot; + id + '\\'' +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r\u0026quot;, info='\u0026quot; + info + '\\'' +\r'}';\r}\rpublic Book(String id, String name, String info) {\rthis.id = id;\rthis.name = name;\rthis.info = info;\r}\rpublic Book() {\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getInfo() {\rreturn info;\r}\rpublic void setInfo(String info) {\rthis.info = info;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (o == null || getClass() != o.getClass()) return false;\rBook book = (Book) o;\rreturn id.equals(book.id) \u0026amp;\u0026amp;\rname.equals(book.name) \u0026amp;\u0026amp;\rinfo.equals(book.info);\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(id, name, info);\r}\r}\r解析json，生成对象\nimport com.google.gson.Gson;\rimport java.util.HashMap;\r/**\r* @Author: lixiaoqin\r* @Description:\r* @Date Created in 2021-02 23:54\r* @Modified By:\r*/\rpublic class ResolveJSONByGson {\rpublic static void main(String[] args) {\rGson g = new Gson();\r// {\u0026quot;id\u0026quot;:\u0026quot;1001\u0026quot;,\u0026quot;info\u0026quot;:\u0026quot;德国批判主义音乐家的一生\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;约翰克里斯托弗\u0026quot;}\r// {\u0026quot;drink\u0026quot;: [\u0026quot;佳得乐\u0026quot;, \u0026quot;可乐\u0026quot;, \u0026quot;尖叫\u0026quot;]}\rBook book = g.fromJson(\u0026quot;{\\\u0026quot;id\\\u0026quot;:\\\u0026quot;1001\\\u0026quot;,\\\u0026quot;info\\\u0026quot;:\\\u0026quot;德国批判主义音乐家的一生\\\u0026quot;,\\\u0026quot;name\\\u0026quot;:\\\u0026quot;约翰克里斯托弗\\\u0026quot;}\u0026quot;, Book.class);\rSystem.out.println(book.getId());\rHashMap hashMap = g.fromJson(\u0026quot;{\\\u0026quot;drink\\\u0026quot;: [\\\u0026quot;佳得乐\\\u0026quot;, \\\u0026quot;可乐\\\u0026quot;, \\\u0026quot;尖叫\\\u0026quot;]}\u0026quot;, HashMap.class);\rSystem.out.println(hashMap.get(\u0026quot;drink\u0026quot;).getClass());\r}\r}\r输出：\n1001\rclass java.util.ArrayList\r生成json\nimport com.google.gson.Gson;\r/**\r* @Author: lixiaoqin\r* @Description:\r* @Date Created in 2021-02 23:52\r* @Modified By:\r*/\rpublic class CreateSJONByGson {\rpublic static void main(String[] args) {\rBook book = new Book(\u0026quot;1001\u0026quot;, \u0026quot;约翰克里斯托弗\u0026quot;, \u0026quot;德国批判主义音乐家的一生\u0026quot;);\rGson g = new Gson();\rString json = g.toJson(book);\rSystem.out.println(json);\r}\r}\r输出：\n{\u0026quot;id\u0026quot;:\u0026quot;1001\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;约翰克里斯托弗\u0026quot;,\u0026quot;info\u0026quot;:\u0026quot;德国批判主义音乐家的一生\u0026quot;}\rFastjson的使用 Fastjson的用法与Gson类似，下载和导包如上所述，这里就不过多赘述。\n解析json\nimport com.alibaba.fastjson.JSON;\rimport java.util.List;\r/**\r* @Author: lixiaoqin\r* @Description:\r* @Date Created in 2021-02 23:54\r* @Modified By:\r*/\rpublic class ResolveJSONByFastJson {\rpublic static void main(String[] args) {\r// {\u0026quot;id\u0026quot;:\u0026quot;1001\u0026quot;,\u0026quot;info\u0026quot;:\u0026quot;德国批判主义音乐家的一生\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;约翰克里斯托弗\u0026quot;}\r// {\u0026quot;drink\u0026quot;: [\u0026quot;佳得乐\u0026quot;, \u0026quot;可乐\u0026quot;, \u0026quot;尖叫\u0026quot;]}\rBook book = JSON.parseObject(\u0026quot;{\\\u0026quot;id\\\u0026quot;:\\\u0026quot;1001\\\u0026quot;,\\\u0026quot;info\\\u0026quot;:\\\u0026quot;德国批判主义音乐家的一生\\\u0026quot;,\\\u0026quot;name\\\u0026quot;:\\\u0026quot;约翰克里斯托弗\\\u0026quot;}\u0026quot;, Book.class);\rSystem.out.println(book.getId());\rList\u0026lt;String\u0026gt; strings = JSON.parseArray(\u0026quot;[\\\u0026quot;佳得乐\\\u0026quot;, \\\u0026quot;可乐\\\u0026quot;, \\\u0026quot;尖叫\\\u0026quot;]\u0026quot;, String.class);\rSystem.out.println(strings);\r}\r}\r输出：\n1001\r[佳得乐, 可乐, 尖叫]\rGson和Fastjson一样解析json数组生成的是java的ArrayList对象。\n生成json\nimport com.alibaba.fastjson.JSON;\r/**\r* @Author: lixiaoqin\r* @Description:\r* @Date Created in 2021-02 23:53\r* @Modified By:\r*/\rpublic class CreateJSONByFastJson {\rpublic static void main(String[] args) {\rBook book = new Book(\u0026quot;1001\u0026quot;, \u0026quot;约翰克里斯托弗\u0026quot;, \u0026quot;德国批判主义音乐家的一生\u0026quot;);\rString json = JSON.toJSONString(book);\rSystem.out.println(json);\r}\r}\r输出：\n{\u0026quot;id\u0026quot;:\u0026quot;1001\u0026quot;,\u0026quot;info\u0026quot;:\u0026quot;德国批判主义音乐家的一生\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;约翰克里斯托弗\u0026quot;}\r","description":"JSON在Java中的使用，将Java对象转换为JSON用于语言无关的数据交换在网络传输中帮助非常大","id":23,"section":"posts","tags":["第三方类库","json"],"title":"JSON解析","uri":"https://qinry.github.io/posts/2021/02/java-json-parse/"},{"content":"一、概述 进程：是一个内存中运行的应用程序，每个进程都有一个独立空间\n线程：是进程中的一个执行路径，共享一个内存空间，线程之间可以自由切换，并发执行，一个进程最少有一个线程；线程实际上是进程基础上的进一步划分，一个进程启动后，里面的若干执行路径又可以划分若干个线程\n同步：排队执行，效率低但数据安全\n异步：同时执行，效率高但数据不安全\n并发：由两个或多个事件，在一个时间段内发生\n并行：由两个或多个时间，在一个时间点上发生\n线程调度：\n  分时调度：所有线程轮流执行CPU的使用权，平均分配每个线程占用CPU的时间\n  抢占式调度：优先级高的线程优先使用CPU，如果线程的优先级相同，那么随机选择一个（线程随机性），Java使用的抢占式调度。\nCPU使用抢占式调度模式在多个线程间进行高速切换。对于CPU的一个核心而言，某一个时刻，只能执行一个线程，而CPU的多个线程切换速度相对我们的感觉要快，看上去就是同一个时刻运行。其实，多线程程序并能提高程序的速度，但能够提高程序运行效率，让CPU的使用率更高。\n  二、线程创建 每一个线程都拥有自己的栈空间，共用一份堆空间\n继承Thread类\npublic class MyThread extends Thread {\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;:\u0026quot;+(i+i+i));\r}\r}\r}\r实现Runnable接口\npublic class RunnableImpl implements Runnable {\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;:\u0026quot;+(i*i));\r}\r}\r}\r实现Runnable与继承Thread相比的优势:\n 通过创建任务，然后给线程分配的方式实现多线程，更适合多线程同时执行相同的任务的情况； 可以避免单继承带来的局限性 线程与任务是分离的，提高了程序的健壮性  线程池技术，接受Runnable类型和Callable类型的任务（Thread是实现Runnable接口的类）\nThread启动使用的start方法而不是run方法，run方法是描述线程执行的任务\nThread.currentThread方法获取当前线程。可以通过setName和getName分别设置和访问线程的名称。setPriority和getPriority分别设置和访问线程优先级，有MIN_PRIORITY、MAX_PRIORIY和NORM_PRIORITY定义好的字段设置优先级。\nstop方法已过时，stop方法会导致线程停止但资源未释放的问题，不安全，不建议使用。可以在线程定义某一个变量run方法取检测变量，当变量符合自己设好的停止条件，使用return语句通知线程停止。\nThread.sleep方法使线程休眠，传入long变量设置休眠的毫秒数（还可以再后加int变量设置纳秒数）。\nsetDaemon方法设置线程是否为守护线程，传入boolean变量来设定，true设置为守护线程，false设置为用户线程，必须在start方法前使用。守护线程依赖用户线程，当用户线程都结束时，守护线程即使没完成，也会被杀死结束。例如：\npublic class Threading {\rpublic static void main(String[] args){\r// 所有用户线程完成，那么程序完成结束\rRunner runner = new Runner();\rThread t = new Thread(runner);\r// 线程t为守护线程，当最后一个用户线程完成时，自动结束（可能还未完成）\rt.setDaemon(true);\rt.start();\rfor (int i = 0; i \u0026lt; 5; i++) {\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(i);\r}\r}\r}\rclass Runner implements Runnable {\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;提前结束\u0026quot;);\rreturn;\r}\rSystem.out.println(i);\r}\r}\r}\r三、线程休眠 java.util提供的TimeUnit类可以使线程休眠：\nimport java.util.concurrent.TimeUnit;\rpublic class Threading {\rpublic static void main(String[] args) {\rfor (int i = 0; i \u0026lt; 10; i++) {\rtry {\rTimeUnit.SECONDS.sleep(1);\r// Thread.sleep(1000);\r} catch(InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(i);\r}\r}\r}\r休眠可能引发InterruptedException，要做异常的捕获。\n四、线程阻塞 线程阻塞不只有线程休眠，还有可能是线程进行IO操作时，比如读取一个文件，线程等待输入完才会进入下一步。可以把线程阻塞，简单理解为线程中所有比较耗时的步骤。\n五、线程终止 线程是否停止，应该由线程本身决定，而不应该外部杀死线程，如果线程涉及资源占用，外部强行杀死程序，导致资源占用却是未被回收的垃圾。\n外部调用interrupt方法，给线程做好中断标记，线程内部捕获InterruptedException后处理，可以是线程自杀处理来完成线程终止，或者忽视掉继续执行。例如：\npublic class Threading {\rpublic static void main(String[] args) {\rRunner runner = new Runner();\rThread t = new Thread(runner);\rt.start();\rfor (int i = 0; i \u0026lt; 5; i++) {\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\re.printStackTrace();\r}\rSystem.out.println(i);\r}\r// 给线程t打中断标记\rt.interrupt();\r}\r}\rclass Runner implements Runnable {\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;提前结束\u0026quot;);\rreturn;\r}\rSystem.out.println(i);\r}\r}\r}\r六、线程安全 多线程同时访问共享的变量并修改，会导致数据错乱，面临数据不安全。\n以下代码线程不安全：\npublic class Threading {\rpublic static void main(String[] args) {\rRunnable sellingTicket = new Runnable(){\rint count = 10;\r@Override\rpublic void run() {\rfor (;;) {\rif (count \u0026gt; 0) {\rSystem.out.println(\u0026quot;开始买票\u0026quot;);\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\re.printStackTrace();\r}\rcount = count - 1;\rSystem.out.println(Thread.currentThread().getName() + \u0026quot;出票完成，余票：\u0026quot; + count);\r} else {\rbreak;\r}\r}\r}\r};\rThread t1 = new Thread(sellingTicket);\rThread t2 = new Thread(sellingTicket);\rThread t3 = new Thread(sellingTicket);\rt1.start();\rt2.start();\rt3.start();\r}\r}\r给线程加锁，使线程排队执行。\n同步代码块：\npublic class Threading {\rpublic static void main(String[] args) {\rRunnable sellingTicket = new Runnable(){\rprivate int count = 10;\r@Override\rpublic void run() {\rfor (;;) {\rsynchronized (this) {\rif (count \u0026gt; 0) {\rSystem.out.println(\u0026quot;开始卖票\u0026quot;);\rtry {\rThread.sleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rcount--;\rSystem.out.println(Thread.currentThread().getName() + \u0026quot;出票完成，余票：\u0026quot; + count);\r} else {\rbreak;\r}\r}\r}\r}\r};\rThread t1 = new Thread(sellingTicket);\rThread t2 = new Thread(sellingTicket);\rThread t3 = new Thread(sellingTicket);\rt1.start();\rt2.start();\rt3.start();\r}\r}\r同步方法：\npublic class Threading {\rpublic static void main(String[] args) {\rRunnable sellingTicket = new Runnable(){\rprivate int count = 10;\r@Override\rpublic void run() {\rfor (;; ) {\rboolean flag = sale();\rif (!flag) {\rbreak;\r}\r}\r}\rpublic synchronized boolean sale() {\rif (count \u0026gt; 0) {\rSystem.out.println(\u0026quot;开始买票\u0026quot;);\rtry {\rThread.sleep(1000);\r} catch(InterruptedException e) {\re.printStackTrace();\r}\rcount = count - 1;\rSystem.out.println(Thread.currentThread().getName() + \u0026quot;出票完成，余票：\u0026quot; + count);\rreturn true;\r}\rreturn false;\r}\r};\rThread t1 = new Thread(sellingTicket);\rThread t2 = new Thread(sellingTicket);\rThread t3 = new Thread(sellingTicket);\rt1.start();\rt2.start();\rt3.start();\r}\r}\r显示锁：\nimport java.util.concurrent.locks.Lock;\rimport java.util.concurrent.locks.ReentrantLock;\rpublic class Threading {\rpublic static void main(String[] args) {\rRunnable sellingTicket = new Runnable(){\rprivate int count = 10;\r//显示锁默认非公平锁，传入true则为公平锁\r//private Lock lock = new ReentrantLock(true);\rprivate Lock lock = new ReentrantLock();\r@Override\rpublic void run() {\rfor (;;) {\rlock.lock();\rtry {\rif (count \u0026gt; 0) {\rSystem.out.println(\u0026quot;开始卖票\u0026quot;);\rtry {\rThread.sleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rcount--;\rSystem.out.println(Thread.currentThread().getName() + \u0026quot;出票完成，余票：\u0026quot; + count);\r} else {\rbreak;\r}\r} finally {\rlock.unlock();\r}\r}\r}\r};\rThread t1 = new Thread(sellingTicket);\rThread t2 = new Thread(sellingTicket);\rThread t3 = new Thread(sellingTicket);\rt1.start();\rt2.start();\rt3.start();\r}\r}\r公平锁：锁释放后，先来的线程先得到锁\n非公平锁：锁释放后，所有线程竞争锁，谁抢到谁获得锁。\n隐式锁（synchronized锁）与显式锁（Lock）的区别？\n（1）底层实现不同。\n synchronized锁是由JVM维护的，是JVM层的锁。通过 monitorenter 进行加锁（底层是通过 monitor 对象来完成的，其中的wait/notify等方法也是依赖于 monitor 对象的。只有在同步代码块或者同步方法中才可以调用wait/notify等方法。因为只有在同步代码块或者是同步方法中，JVM才会调用 monitor对象）；通过 monitorexit 来退出锁。 Lock是JDK5推出的具体类。使用它是通过调用对应的API方法来获取锁和释放锁，是API层面的锁  （2）用法不同\n synchronized关键字，能够自动获取和释放锁。执行完这个关键字相关的代码后，系统自动释放程序占用锁，它是系统维护的，没有程序的问题，是不会死锁的。可以在方法前加上此关键字修饰为同步方法，或者此关键则后跟圆括号里面放入锁对象，然后带有花括号的代码块，里面代码就是要同步的。锁对象可以是任意类型的实例对象，不过多线程应该使用同一个对象当作锁对象，这样才有线程同步的效果 Lock显示锁，需要手动调用lock方法和unlock方法，来获取和释放锁。如果没有释放锁可能会导致死锁。要配合try-finally语句。  （3）中断与否\n 隐式锁不可中断，只能正常运行或抛出异常 显示锁可以中断，Lock对象调用lockInterruptibly方法放到代码块中，然后调用interrupt()方法可以中断  （4）公平与否\n 隐式锁一定非公平，线程都是会互相竞争锁，不是排队获取 显示锁，通过传入构造器的参数决定公平与否，默认是非公平的，传入true则为公平锁。  （5）绑定多个Condition对象与否\n 隐式锁:没有。要么随机唤醒一个线程；要么是唤醒所有等待的线程。 显示锁:用来实现分组唤醒需要唤醒的线程，可以精确的唤醒，而不是像显示锁不能精确唤醒线程。  七、死锁 两个线程先是各自持有一部分锁，互相之间等待某一个线程释放锁，所有线程都陷入等待，无法继续执行下去。\n比如：线程A的执行要先获取锁1，后获取锁2。线程B的执行要先获取锁2，后获取锁1。如果线程A和线程B都同时获取了自己的第一个锁，那么获取第二个锁时，导致了死锁。\n以下示例，有可能死锁。\nclass Culprit {\rpublic synchronized void say(Police p) {\rSystem.out.println(\u0026quot;罪犯：你放了我，我放了人质\u0026quot;);\rp.fun();\r}\rpublic synchronized void fun() {\rSystem.out.println(\u0026quot;罪犯放了人质，自己跑了\u0026quot;);\r}\r}\rclass Police {\rpublic synchronized void say(Culprit c) {\rSystem.out.println(\u0026quot;警察：你放了人质，我放过你\u0026quot;);\rc.fun();\r}\rpublic synchronized void fun() {\rSystem.out.println(\u0026quot;警察救了人质，罪犯跑了\u0026quot;);\r}\r}\rpublic class Threading {\rpublic static void main(String[] args) {\r// 死锁\rCulprit c = new Culprit();\rPolice p = new Police();\rThread t = new Thread(new Runnable(){\rprivate Police police;\rprivate Culprit culprit;\r{\rpolice = p;\rculprit = c;\r}\r@Override\rpublic void run() {\rpolice.say(culprit);\r}\r});\rt.start();\rc.say(p);\r}\r}\r输出：\n罪犯：你放了我，我放了人质\r警察：你放了人质，我放过你\r防止线程同时获取多个锁，比如嵌套的同步代码块等，可以避免死锁。\n八、多线程通信 生产者与消费者，线程间的协作。生产者线程执行一次循环后等待，消费者线程执行一次循环后先唤醒生产者，自己等待被唤醒。\n生产者被唤醒，再执行一次循环后唤醒消费者，自己等待，消费者又像上次执行。如此生产者与消费者交替反复执行，直到循环结束。\nObject中的wait方法让当前线程等待，notifyAll方法唤醒所有等待此对象监视器的线程，notify方法只唤醒一个线程比较少用。以上三种方法，必须在同步方法或者同步代码块内执行。wait方法和notifyAll方法会释放锁，不同于过时的stop方法、suspend方法、resume方法，还有sleep方法都不会在释放锁。\n示例：\nimport java.util.concurrent.TimeUnit;\rpublic class Communiticate {\rpublic static void main(String[] args) {\rFood food = new Food();\rThread thread1 = new Thread(new Cook(food));\rThread thread2 = new Thread(new Waiter(food));\rthread1.start();\rthread2.start();\r}\rstatic class Food {\rprivate String name;\rprivate String taste;\r// true：厨师做饭，false：服务员端菜\rprivate boolean flag = true;\rpublic synchronized void produce(String name, String taste) {\rif (flag) {\rthis.name = name;\rtry {\rTimeUnit.MILLISECONDS.sleep(300);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rthis.taste = taste;\rflag = false;\rtry {\rwait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rnotifyAll();\r}\r}\rpublic synchronized void cost() {\rif (!flag) {\rSystem.out.println(\u0026quot;服务员端菜，菜品是\u0026quot;+name+\u0026quot;，味道是\u0026quot;+taste);\rflag = true;\rnotifyAll();\rtry {\rwait();\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}\rstatic class Cook implements Runnable {\rprivate Food food;\rpublic Cook(Food f) {\rthis.food = f;\r}\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rif ((i \u0026amp; 1) == 0) {\rfood.produce(\u0026quot;扬州炒饭\u0026quot;, \u0026quot;咸的\u0026quot;);\r} else {\rfood.produce(\u0026quot;水煮鱼\u0026quot;, \u0026quot;麻辣的\u0026quot;);\r}\r}\r}\r}\rstatic class Waiter implements Runnable {\rprivate Food food;\rpublic Waiter(Food f) {\rthis.food = f;\r}\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 10; i++) {\rtry {\rTimeUnit.MILLISECONDS.sleep(300);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rfood.cost();\r}\r}\r}\r}\r输出：\n服务员端菜，菜品是扬州炒饭，味道是咸的\r服务员端菜，菜品是水煮鱼，味道是麻辣的\r服务员端菜，菜品是扬州炒饭，味道是咸的\r服务员端菜，菜品是水煮鱼，味道是麻辣的\r服务员端菜，菜品是扬州炒饭，味道是咸的\r服务员端菜，菜品是水煮鱼，味道是麻辣的\r服务员端菜，菜品是扬州炒饭，味道是咸的\r服务员端菜，菜品是水煮鱼，味道是麻辣的\r服务员端菜，菜品是扬州炒饭，味道是咸的\r服务员端菜，菜品是水煮鱼，味道是麻辣的\r九、线程的状态  NEW\n尚未启动的线程处于此状态。 RUNNABLE\n在Java虚拟机中执行的线程处于此状态。 BLOCKED\n被阻塞等待监视器锁定的线程处于此状态。 WAITING\n无限期等待另一个线程执行特定操作的线程处于此状态。 TIMED_WAITING\n正在等待另一个线程执行最多指定等待时间的操作的线程处于此状态。 TERMINATED\n已退出的线程处于此状态  十、Callable\u0026lt;V\u0026gt;和FutureTask\u0026lt;V\u0026gt; public class Caller\u0026lt;V\u0026gt; implements Callable\u0026lt;V\u0026gt; {\rprivate V val;\rpublic Caller(V val) {\rthis.val = val;\r}\r@Override\rpublic V call() throws Exception {\rTimeUnit.SECONDS.sleep(3);\rreturn val;\r}\rpublic static void main(String[] args) throws ExecutionException, InterruptedException {\rFutureTask\u0026lt;Integer\u0026gt; future = new FutureTask\u0026lt;\u0026gt;(new Caller\u0026lt;Integer\u0026gt;(47));\rThread thread = new Thread(future);\rthread.start();\rTimeUnit.SECONDS.sleep(4);\rif (future.isDone()) {\rSystem.out.println(future.get());\r} else {\rSystem.out.println(\u0026quot;中断\u0026quot;);\rfuture.cancel(true);\r}\r}\r}\r输出：\n47\r十一、线程池 线程池的好处：\n 降低资源消耗 提高响应速度 提高线程的管理性  shutdown方法启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。 shutdownNow方法尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。execute方法可以执行Runnable类型任务，submit可以执行Runnable类型和Callable类型任务。\n缓存线程池\nimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Executors;\rimport java.util.concurrent.TimeUnit;\rpublic class UseCachedThreadPool {\rpublic static void main(String[] args) {\rExecutorService exec = Executors.newCachedThreadPool();\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rtry {\rTimeUnit.SECONDS.sleep(1);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.shutdown();\r}\r}\r输出：\npool-1-thread-3 Hello World\rpool-1-thread-2 Hello World\rpool-1-thread-1 Hello World\rpool-1-thread-1 Hello World\r定长线程池\nimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Executors;\rimport java.util.concurrent.TimeUnit;\rpublic class UseFixedThreadPool {\rpublic static void main(String[] args) {\rExecutorService exec = Executors.newFixedThreadPool(2);\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\rtry {\rTimeUnit.SECONDS.sleep(3);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\rtry {\rTimeUnit.SECONDS.sleep(3);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.shutdown();\r}\r}\r输出：\npool-1-thread-1 Hello World\rpool-1-thread-2 Hello World\rpool-1-thread-2 Hello World\r单线程池\nimport java.util.concurrent.ExecutorService;\rimport java.util.concurrent.Executors;\rpublic class UseSingleThreadPool {\rpublic static void main(String[] args) {\rExecutorService exec = Executors.newSingleThreadExecutor();\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.execute(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; Hello World\u0026quot;);\r}\r});\rexec.shutdown();\r}\r}\r输出：\npool-1-thread-1 Hello World\rpool-1-thread-1 Hello World\rpool-1-thread-1 Hello World\rpool-1-thread-1 Hello World\r周期性定长线程池\nimport java.util.concurrent.Executors;\rimport java.util.concurrent.ScheduledExecutorService;\rimport java.util.concurrent.TimeUnit;\rpublic class UseScheduledThreadPool {\rpublic static void main(String[] args) {\rScheduledExecutorService exec = Executors.newScheduledThreadPool(2);\r// 任务 延迟时长 单位\rexec.schedule(new Runnable(){\r@Override\rpublic void run() {\rSystem.out.println(\u0026quot;Hello World\u0026quot;);\r}\r}, 5, TimeUnit.SECONDS);\r// 任务 延迟时长 周期时长 单位\rexec.scheduleAtFixedRate(new Runnable() {\r@Override\rpublic void run() {\rSystem.out.println(\u0026quot;Write once, Run Anywhere\u0026quot;);\r}\r}, 5, 1, TimeUnit.SECONDS);\rexec.shutdown();\r}\r}\r输出：\nWrite once, Run Anywhere\rHello World\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\rWrite once, Run Anywhere\r","description":"java多线程编程基础，内容线程的创建启动与终止，休眠，死锁，线程间协作，线程池等","id":24,"section":"posts","tags":["并发编程"],"title":"多线程","uri":"https://qinry.github.io/posts/2021/02/java-concurrent/"},{"content":"一、数组与链表 链表 [Linked List]：链表是由一组不必相连（不必相连：可以连续也可以不连续）的内\n存结构（节点），按特定的顺序链接在一起的抽象数据类型。\n数组和链表的区别和优缺点：\n数组是一种连续存储线性结构，元素类型相同，大小相等\n\r\r\r优点\r缺点\r\r\r\r\r存取速度快\r事先必须知道数组的长度\r\r\r\r插入删除元素很慢\r\r\r\r空间通常是有限制的\r\r\r\r需要大块连续的内存块\r\r\r\r插入删除元素的效率很低\r\r\r\r链表是离散存储线性结构\nn 个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一\n个后续节点，首节点没有前驱节点，尾节点没有后续节点。\n\r\r\r链表优点\r缺点\r\r\r\r\r空间没有限制\r\r\r\r插入删除元素很快\r存取速度很慢\r\r\r\r二、链表分类 2.1 单链表 单链表 [Linked List]：由各个内存结构通过一个 Next 指针链接在一起组成，每一个内存结构都存在后继内存结构(链尾除外），内存结构由数据域和 Next 指针域组成。如图：\nJava表达单链表结点的结构：\nclass LinkedList\u0026lt;E\u0026gt; {\rNode first;\rclass Node {\rE elem;\rNode next;\r}\r}\r2.1.1 插入 插入的位置为i，插入的元素为elem。从头结点开始遍历链表，找到第i-1个结点，创建包含elem的新结点插入第i-1个结点后面。\nJava表达：\nvoid insert(int i, E elem) {\rNode temp = new Node();\rtemp.elem = elem;\rNode curr = first;\rfor (int j = 1; j \u0026lt; i; j++) {\rcurr = curr.next;\r}\rtemp.next = curr.next;\rcurr.next = temp;\r}\r链表的插入、删除与查找之前是要边界检查的，在这些操作过程中可以使用成员变量size，统计结点数，也就是链表长度，为了突出重要的步骤，不过这里省略了。后面的代码也是如此。\n2.1.2 删除 删除第i个元素。从头结点开始遍历链表，找到第i-1个结点，删除其后面的结点。\nJava表达：\nE delete(int i) {\rNode curr = first;\rfor (int i = j; i \u0026lt; i-1; j++) {\rcurr = curr.next;\r}\rNode old = curr;\rcurr = curr.next;\rold.next = curr.next;\rcurr.next = null;\rreturn curr.elem;\r}\r2.1.3 查询 查询第i个元素。从头结点开始遍历链表，找到第i个结点，取出元素。\njava表达：\nE find(int i) {\rNode curr = first;\rfor (int j = 0; j \u0026lt; i; j++) {\rcurr = curr.next;\r}\rreturn curr.elem;\r}\r2.2 双链表 双向链表 [Double Linked List]：由各个内存结构通过指针 Next 和指针 Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构(链头没有前驱，链尾没有后继），内存结构由数据域、Prev 指针域和 Next 指针域组成。\n它的结构类似单链表，我在链表的首尾加了两个哨兵结点（pre和post），加不加哨兵结点只是出于策略的考虑和自己的喜好使用即可，不过我喜欢在双向链表使用哨兵结点，方便插入与删除的操作，且代码写起来更加简单。\nclass DoublyLinkedList\u0026lt;E\u0026gt; {\rNode pre;\rNode post;\rclass Node {\rE elem;\rNode prev;\rNode next;\r}\r{\rpre = new Node();\rpost = new Node()\rpre.next = post;\rpost.prev = pre;\r}\r}\r2.2.1 插入 与单链表插入类似。先创建新结点，顺序查找到第i-1个结点x，再得到其后驱结点y，将新结点插入它们之间。\njava表达：\nvoid insert(int i, E elem) {\rNode temp = new Node();\rtemp.elem = elem;\rNode x = pre;\rfor (int j = 0; j \u0026lt; i; j++) {\rx = x.next;\r}\rNode y = x.next;\rx.next = temp;\rtemp.prev = x;\rtemp.next = y;\ry.prev = temp;\r}\r2.2.2 删除 顺序查找到第i个结点y，得到它的前驱结点x和后驱结点z，将y删除。\njava表达：\nE delete(int i) {\rNode y = pre.next;\rfor (int j = 0; j \u0026lt; i; j++) {\ry = y.next;\r}\rNode x = y.prev;\rNode z = y.next;\rx.next = z;\rz.prev = x;\ry.next = null;\ry.prev = null;\r}\r2.2.3 查询 与单链表一样。\n2.3 循环链表 单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 Next 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。\n双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 Next 和指针Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。\n把单向链表的尾结点的Next指针指向头结点就成了单向循环链表。双向循环链表也是一样。一般地，循环链表都是保存尾结点的指针，通过尾结点的到第一个结点，来遍历链表，方便所有位置的插入、删除。插入、删除还有查找的操作与单链表和双链表没什么区别，这里就不多余展示了。\n","description":"数组与链表是最基础的数据结构，其他很多数据结构，都是通过它们变形来实现的。这里说明了它们的优缺点，还有链表的分类，以及相关的算法","id":25,"section":"posts","tags":["链表"],"title":"链表","uri":"https://qinry.github.io/posts/2021/01/algorithm-list/"},{"content":"理解泛型 泛型是将类型参数化，类定义时一些成员变量和一些方法形式参数的类型成为变量，在使用时再传入一个具体类型，进一步抽象了变量的类型。好像是给方法或类写了一个模板，根据模板赋予不同的类型参数，就会生成不同的类。将那些类似方法或类都集中在一起编写，也就是将相同的部分都封装起来，不同的部分参数化。某种程度，减少编写只因类型不同，逻辑大部分相同的多个类的代码量，使这部分代码耦合度降低，提高了代码的复用率。在Java中的泛型使用时指定类型但不需要强制类型转换，不必担心，类型是安全的，编译器会检查。\n使用泛型 泛型类 定义泛型类：\npublic class Stack\u0026lt;E\u0026gt; implements Iterable {\rprivate Node first;\rprivate class Node {\rprivate E element;\rprivate Node next;\rpublic Node(E e) {\rthis.element = e;\rnext = null;\r}\rpublic Node(Node x) {\relement = x.element;\rif (x.next != null) {\rnext = new Node(x.next);\r}\r}\r}\r// 其他方法省略\r}\r创建泛型类的对象：\nStack stack = new Stack\u0026lt;String\u0026gt;();\r成员内部类是可以使用外部类的类型参数，静态内部类却不能。\n泛型接口 定义泛型接口：\ninterface Callable\u0026lt;V\u0026gt; {\rV call() throws Exception;\r}\r实现泛型接口，指定类型：\nclass StringCaller implements Callable\u0026lt;String\u0026gt; {\r@Override\rpublic String call() {\rreturn \u0026quot;String\u0026quot;;\r}\r}\r实现泛型接口，不指定类型：\nclass Caller\u0026lt;V\u0026gt; implements Callable\u0026lt;V\u0026gt; {\rprivate V val;\rpublic V call() {\rreturn val;\r}\rpublic void setVal(V val) {\rthis.val = val;\r}\r}\r泛型方法 一个普通类的方法可以使用泛型。形式大致：\n权限修饰符 \u0026lt;T\u0026gt; T 方法名(T a, T b) {}\r非静态方法：\nclass GenericMethod {\rpublic \u0026lt;T\u0026gt; void f(T t) {\rSystem.out.println(t.getClass().getName());\r}\r}\r静态方法：\n例如：\nimport java.lang.reflect.*;\rimport java.util.regex.*;\rclass StaticGenericMethod\u0026lt;T\u0026gt; {\rpublic static \u0026lt;T\u0026gt; void f(T t) {\rPattern p = Pattern.compile(\u0026quot;\\\\w+\\\\.\u0026quot;);\rfor(Method m : t.getClass().getMethods())\rSystem.out.println(\rp.matcher(\rm.toString()).replaceAll(\u0026quot;\u0026quot;));\r}\r}\r由于static方法无法访问泛型类的类型参数，static的泛型方法必须在返回值类型前加上\u0026amp;lt;类型参数\u0026amp;gt;这个类型参数的声明。非静态方法如果是在泛型类内部，其实已经隐含了声明，所以不用特别写出来，但如果是普通类中，一定要写。\n泛型限制类型 在使用泛型时， 可以指定泛型的限定区域 ，\n 例如： 必须是某某类的子类或 某某接口的实现类，格式：  \u0026lt;T extends 类或接口1 \u0026amp; 接口2\u0026gt; 泛型的通配符 public class Demo {\rpublic static void main(String[] args) {\rArrayList\u0026lt;Fruit\u0026gt; fruits = new ArrayList\u0026lt;Apple\u0026gt;();\r}\r}\rclass Fruit {}\rclass Apple extends Fruit {}\r上面的main方法，编译器是无法通过运行的。不同于方法的多态，是可以传入变量参数时，实际参数时可以为形参的子类。但泛型的使用不允许这么做，这里可以理解，类型ArrayList\u0026lt;Fruit\u0026gt;和ArrayList\u0026lt;Apple\u0026gt;是完全不同的类型，之间更没父子关系。Java为了更好的使用泛型，提出了泛型的通配符。\n类型通配符是使用？代替方法具体的类型实参。\n无界通配符\u0026lt;?\u0026gt;表示某种特定类型，创建对象时传入的类型参数可以是任意类型，对象一旦传入创建好了，类型就确定，它方法使用类型参数也就跟着确定了。与\u0026lt;Object\u0026gt;是不同的意思，类型参数确定为Object，只不过使用这个类型参数的方法是可以传入任何类型的变量（因为Object是所有类共同的基类，Java是走单继承体系的）;\n超类通配符\u0026lt;? super T\u0026gt;或\u0026lt;? super 具体类\u0026gt;,由T或具体类的基类来界定类型参数，它规定类型的下界;\n子类通配符\u0026lt;? extends T\u0026gt;或\u0026lt;? extends 具体类\u0026gt;，由T或具体类的子类来界定类型参数，规定了类型的上界。通配符用在方法的泛型类参数或泛型类变量声明上。\n就如:\nList\u0026lt;?\u0026gt; fruits = new ArrayList\u0026lt;Fruit\u0026gt;();\r// 假设定义好类Fruit及其子类Apple,下面的代码在某个类内部\rvoid write(List\u0026lt;? super Fruit\u0026gt; fruit, Fruit newFruit) {\rfruit.add(newFruit);\r}\rFruit read(List\u0026lt;? extends Fruit\u0026gt; fruit, int i) {\rreturn fruit.get(i);\r}\r泛型擦除 在编译之后程序会采取去泛型化的措施。\n也就是说Java中的泛型，只在编译阶段有效。\n在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加 类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段\n","description":"泛型类，泛型接口，泛型方法，泛型通配符以及类型擦除","id":26,"section":"posts","tags":["泛型"],"title":"泛型","uri":"https://qinry.github.io/posts/2021/01/java-generics/"},{"content":"一些常用类库的使用，没有列出完整代码，只有只有代码的主要部分\n一、java.util.Objects java.lang.Objects是JDK 7之后提供的工具类，里面包含丰富的static方法，用于操作对象或操作前的检查某些条件。比如检查两个对象是否相等，计算对象的哈希值，检查对象是否为空，以及检查索引或子范围是否超出等等。\n1.1 检查对象相等 1.1.1 使用equals 例如：\nString s1 = null;\rString s2 = \u0026quot;123\u0026quot;;\rString s3 = \u0026quot;456\u0026quot;;\r// 由于s1为空，调用equals方法会引发NullPointerException\rSystem.out.println(s1.equals(s2));\rSystem.out.println(Objects.equals(s1, s2));\rSystem.out.println(Objects.equals(s2, s3));\r输出：\nfalse\rfalse\r比较两个对象是否相等，最好使用Objects的equals方法，防止NullPointerException异常。\n1.1.2 equals源码 public static boolean equals(Object a, Object b) {\rreturn (a == b) || (a == null \u0026amp;\u0026amp; a.equals(b));\r}\ra和b如果内存位置相同直接返回true，a和b相等检测前，对a进行了空的检查。\n1.2 检查空对象 1.2.1 使用isNull和nonNull 例如：\nString s1 = null;\rString s2 = \u0026quot;123\u0026quot;;\rString s3 = \u0026quot;456\u0026quot;;\rSystem.out.println(Objects.isNull(s1));\rSystem.out.println(Objects.nonNull(s1));\r输出：\ntrue\rfalse\r方法名可以知道意思,isNull判断对象是否为空，nonNull判断对象是否为非空。对空对象来说,isNull返回true，nonNull返回false；非空对象，反之。\n1.2.2 isNull和nonNull源码 public static boolean isNull(Object obj) {\rreturn obj == null;\r}\rpublic static boolean nonNull(Object obj) {\rreturn obj != null;\r}\risNull是对象与null的==比较，而nonNull是用!=比较\n1.2.3 使用requirenonNull 例如：\nString s1 = null;\rSystem.out.println(Objects.requireNonNull(s1));\r输出：\nException in thread \u0026quot;main\u0026quot; java.lang.NullPointerException\rat java.base/java.util.Objects.requireNonNull(Objects.java:221)\rat com.github.qinry.utils.UseObjects.main(UseObjects.java:18)\r与isNull和nonNull都是检测空对象，但是如果对象是空的，requireNonNull会实例化NullPointerException对象抛出异常。常常用在某些方法的流程中，要求传入的参数须具备有值，可以在调用该方法前，使用requireNonNull判断是否为空，来保证数据有效，若为空中断方法的调用，须做异常的处理。\n1.2.4 requireNonNull源码 public static \u0026lt;T\u0026gt; T requireNonNull(T obj) {\rif (obj == null)\rthrow new NullPointerException();\rreturn obj;\r}\r如果对象为空，抛出异常NullPointerException；否则直接返回原对象。\n二、java.lang.Math java.lang.Math是java提供的基本数学库，用于一些基本的数字运算，例如：幂运算，求对数，平方根和三角函数等等。下面展示简单的应用。\n2.1 求绝对值 例如：\nSystem.out.println(Math.abs(-47));\rSystem.out.println(Math.abs(47));\r输出：\n47\r47\rabs除了求int类型的绝对值，还有三个重载的版本（long、float、double）\n2.2 求两数的最大值和最小值 例如：\nSystem.out.println(Math.max(38, 47));\rSystem.out.println(Math.min(-2, 3));\r输出：\n47\r-2\rmin和max除了可以比较int的最大值和最小值，还有三个重载的版本（long、float、double）\n2.3 浮点数的四舍五入 有float和double两个版本\n例如：\nSystem.out.println(Math.round(3.5));\r输出：\n4\r2.4 向下取整 只有double版本\n例如：\n// 返回小于参数的最大整数\rSystem.out.println(Math.floor(3.5));\rSystem.out.println(Math.floor(-3.5));\r输出：\n3.0\r-4.0\r2.5 向上取整 只有double版本\n例如：\n// 返回大于参数的最小整数\rSystem.out.println(Math.ceil(3.5));\rSystem.out.println(Math.ceil(-3.5));\r输出：\n4.0\r-3.0\r2.6 随机数\nMath.random()得到0~1（不包含）的双精度浮点数\n得到0到n（包含）的随机整数，用法：\n(int)(Math.random() * (n+1));\r得到i到n（不包含）的随机整数（i \u0026lt; n），用法：\ni + (int)(Math.random()*(n-i));\r举个例子，取1000~9999得随机数：\nint num = 1000 + (int)(Math.random()*(10000-1000));\r三、java.utils.Arrays java.utils.Arrays是Java提供操作数组得工具类，如排序，查找，两数组比较，拷贝数组，数组内容字符串表示等等。\n3.1 数组内容的字符串表示 toString返回指定数组内容的字符串表示，有基本数据类型数组的版本和Object[]版本\n例如：\nint[] a = { 3, 8, 7, 2, 6, 4 };\rSystem.out.println(a);\rSystem.out.println(Arrays.toString(a));\r输出：\n[I@7c30a502\r[3, 8, 7, 2, 6, 4]\r直接打印数组引用a，输出的不是a的内容，而是数组类型和地址，[I表示整型数组类型，@后面的16进制整数是数组对象的起始地址。toString才是打印数组的内容。\ntoString源码：\npublic static String toString(int[] a) {\rif (a == null)\rreturn \u0026quot;null\u0026quot;;\rint iMax = a.length - 1;\rif (iMax == -1)\rreturn \u0026quot;[]\u0026quot;;\rStringBuilder b = new StringBuilder();\rb.append('[');\rfor (int i = 0; ; i++) {\rb.append(a[i]);\rif (i == iMax)\rreturn b.append(']').toString();\rb.append(\u0026quot;, \u0026quot;);\r}\r}\r使用了StringBuilder类，遍历数组每一个元素，把元素拼接为一个字符串，最后返回。\n3.2 排序 sort对数组排序，有基本数据类型数组（除了boolean[]），Object[]类型和泛型数组类型版本。泛型数组的排序要额外传入Comparator参数，Comparator是Java定义好的一个接口，功能是用于指定对象类型比较大小的比较器。\n例如：\nint[] a = { 3, 8, 7, 2, 6, 4 };\rSystem.out.println(Arrays.toString(a));\rArrays.sort(a);\rSystem.out.println(Arrays.toString(a));\r输出：\n[3, 8, 7, 2, 6, 4]\r[2, 3, 4, 6, 7, 8]\r排序的效率高于冒泡排序，sort根据数组的情况选择一些更加高效的排序，例如：插入排序、快速排序、归并排序。\n3.3 查找 binarySearch，顾名思义，就是折半查找，亦或称二分查找。需要传入数组a和要查找的目标关键字key。有基本数据类型数组（除了boolean[]），Object[]类型和泛型数组类型版本。泛型数组的查找要额外传入Comparator参数。使用binarySearch先要把排序好数组。\n例如：\nint[] a = { 3, 8, 7, 2, 6, 4};\rArrays.sort(a);\rSystem.out.println(Arrays.binarySearch(a, 4));\r输出：\n2\r3.4 拷贝数组 copyOf是从源数组的下标0开始拷贝数组，需传入源数组引用和返回拷贝数组的长度两个参数，返回值是拷贝数组。有基本数组类型数组和泛型数组类型版本。若拷贝数组长度大于源数组，会用默认值填充；若小于，则截断源数组后面的内容。copyOf的返回值赋值给原来的数组引用，常常起到数组尺寸的动态调整的作用。\n例如扩容：\nint[] a = { 3, 8, 7, 2, 6, 4};\rSystem.out.println(a.length);\rSystem.out.println(Arrays.toString(a));\ra = Arrays.copyOf(a, a.length*2);\rSystem.out.println(a.length);\rSystem.out.println(Arrays.toString(a));\r输出：\n6\r[3, 8, 7, 2, 6, 4]\r12\r[3, 8, 7, 2, 6, 4, 0, 0, 0, 0, 0, 0]\r拷贝数组长度大于源数组，拷贝数组后面全部填充了默认值\n例如减容：\nint[] a = { 3, 8, 7, 2, 6, 4};\rSystem.out.println(a.length);\rSystem.out.println(Arrays.toString(a));\ra = Arrays.copyOf(a, a.length/2);\rSystem.out.println(a.length);\rSystem.out.println(Arrays.toString(a));\r输出：\n6\r[3, 8, 7, 2, 6, 4]\r3\r[3, 8, 7]\r拷贝数组长度小于源数组，拷贝数组截断后面内容，全部丢弃\n3.5 数组的比较 compare用于比较数组，传入需要比较的两个数组引用参数。有基本数据类型数组和泛型数组版本。泛型数组版本有2个，一个是实现Comparable接口的泛型数组版本，另一个没有实现Comparable接口的泛型数组版本。实现了Comparable接口的导出类，允具备比较大小的能力。Comparator接口则是用来弥补没有实现Comparable接口的导出类不能比较大小的能力。\ncompare返回值，若为-1，表示左数组小于右数组；若为0，数组相等；若为1，左数组大于右数组；\nint[] a = { 3, 8, 7, 2, 6, 4};\rint[] b = new int[a.length*2];\rSystem.arraycopy(a, 0, b, 0, a.length);\rArrays.sort(a);\rSystem.out.println(Arrays.compare(a, b));\r输出：\n-1\rSystem.arraycopy见下节的6.3 System.arraycopy\ncompare源码：\npublic static int compare(int[] a, int[] b) {\rif (a == b)\rreturn 0;\rif (a == null || b == null)\rreturn a == null ? -1 : 1;\rint i = ArraysSupport.mismatch(a, b,\rMath.min(a.length, b.length));\rif (i \u0026gt;= 0) {\rreturn Integer.compare(a[i], b[i]);\r}\rreturn a.length - b.length;\r}\r  如果数组a和b，内存位置相同或者都为空，返回0；\n  a和b其中一个是空，若a为空，返回-1，若b为空，返回1；\n  获取数组之间第一个相等不匹配的相对索引。\n 索引大于0，说明存在这个索引， 返回比较第一个不匹配的元素的比较结果     索引小于0，说明不存在此索引，返回数组长度的比较结果  四、java.math.BigDecimal double和float的算数运算是不精确的，为了解决精确计算，java.math包提供了BigDecimal则用来精确的浮点数运算。\n常用方法有加(add)、减(substract)、乘(mutiply)、除(divide)，和转换为int(intValue)、long(longValue)、float(floatValue)、double(doubleValue)和BigInteger(toBigInteger)的方法。\n还有获取绝对值的方法abs，与同类型的val求两数最大值的max，与同类型的val求两数最小值的min。\n创建BigDecimal，可以使用构造方法和传入long或double参数的静态valueOf。常用的构造方法是传入字符串参数的构造方法,即BigDecimal(String val)。创建的BigDecimal对象是不可变的，可以认为是常量，所以像b1.add(b2)，不会改变b1和b2，而是会返回BigDecimal的结果。\n例如：\nBigDecimal b1 = new BigDecimal(\u0026quot;0.1\u0026quot;);\rBigDecimal b2 = new BigDecimal(\u0026quot;0.2\u0026quot;);\rBigDecimal b3 = null;\rSystem.out.println(b1);\rSystem.out.println(b2);\rb3 = b1.add(b2);\rSystem.out.println(b3);\rb3 = b1.subtract(b2);\rSystem.out.println(b3);\rb3 = b1.multiply(b2);\rSystem.out.println(b3);\rb3 = b1.divide(b2);\rSystem.out.println(b3);\rdouble d = b3.doubleValue();\rfloat f = b3.floatValue();\rint i = b3.intValue();\rlong l = b3.longValue();\rSystem.out.println(d+\u0026quot;\\n\u0026quot;+i);\rSystem.out.println(f+\u0026quot;\\n\u0026quot;+l);\r输出：\n0.1\r0.2\r0.3\r-0.1\r0.02\r0.5\r0.5\r0.5\r0\r0\r五、日期和时间 5.1 java.util.Date 5.1.1 创建日期 创建当前的日期：\nDate date = new Date();\rSystem.out.println(date);\r输出：\nMon Jan 25 21:27:14 CST 2021\r创建指定的日期：\nDate date = new Date(1611581144493L);\rSystem.out.println(date);\r输出：\nMon Jan 25 21:25:44 CST 2021\rDate有两个常用的构造器：一个无参构造器和一个传入long类型的时间戳变量的构造器。无参构造器构造的是当前时间的Date对象。时间戳是指1970年1月1日（格林尼治时间是00:00，东八区时间是8:00）到指定日期时间的所经历的毫秒数。通过时间戳也可以创建Date对象表示时间\n5.1.2 获取时间戳 例如：\nDate date = new Date();\rSystem.out.println(date.getTime());\r输出：\n1611581744578\r通过时间戳可以计算，两时间点所经历的时间长度。例如：\nDate old = new Date(1611581144493L);\rDate date = new Date();\rSystem.out.println((date.getTime()-old.getTime())/1000/60+\u0026quot;分钟\u0026quot;);\r输出：\n14分钟\r5.1.3 比较时间 date是否为old之后的日期时间，可以用curr.after(old)来判断；date是否为old之前的日期时间，可以用curr.before(old)来判断。\n例如：\nDate old = new Date(1611581144493L);\rDate curr = new Date();\rSystem.out.println(curr.after(old));\rSystem.out.println(curr.before(old));\r输出：\ntrue\rfalse\r5.2 java.text.DateFormat Date对象默认输出的格式，例如：Mon Jan 25 21:25:44 CST 2021。Java提供了java.text.DateFormat接口，可以自定义日期的字符串表示, 实现这个接口的类有SimpleDateFormat。\n5.2.1 格式化日期字符串表示 例如：\nSimpleDateFormat format = new SimpleDateFormat(\u0026quot;yyyy年MM月dd日 HH:mm ss\u0026quot;);\rString text = format.format(new Date());\rSystem.out.println(text);\r输出：\n2021年01月25日 21:51 18\r5.2.2 解析日期字符串表示 String s = \u0026quot;1999年01月22日 05:50 30\u0026quot;;\rDate date = format.parse(s);\rSystem.out.println(date + \u0026quot; ~ \u0026quot; +date.getTime());\r输出：\nFri Jan 22 05:50:30 CST 1999 ~ 916955430000\r5.2.3 日期和时间的模式 有些可以充当转义为日期和时间的特殊字符，如下：\n5.3 java.util.Calendar Calendar是个抽象类，不能直接new获得，但提供了静态方法getInstance()获取Calendar的子类对象。提供了getTime方法获取Date对象。\nget方法用来获取日历中日期某一字段的信息，像年份、月份、当月几号等等，这些字段信息是储存在int数组fields中，为了方便检索日期某一字段的信息,Calendar内定义许多int常量，比如Calendar.YEAR，这些常量在设置日历，对日历做运算都有要使用，有了它们就不用记住哪个下标的元素代表哪个字段的信息，若是要获得年份可以get(Calendar.YEAR)，要获取其他信息只要使用定义好的常量就行。注意get方法得到月份的信息，是0到11，0表示1月，真正月份是得到信息再加1.\nset方法设置日历某一字段，像set(Calendar.MONTH, Calendar.FEBRUARY)把日历设置成2月。set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY)，可以把日期的改为这个星期的星期天。注意一周的第一天是周日。\nadd方法可以按照指定时间量添加或减少给定的日历字段，像add(Calendar.YEAR, 1)把时间加了一年，add(Calendar.MONTH, -1)把时间减了一个月。\n获取某一日历字段的最大值用getActualMaximun方法，可以解决某年有多少天，某月有多少天，某年有多少周，某月有多少周的问题。\n例如：\nCalendar cl = Calendar.getInstance();\rDate date = cl.getTime();\rSystem.out.println(date);\rint year = cl.get(Calendar.YEAR);\rint month = cl.get(Calendar.MONTH);\rSystem.out.println(year);\rSystem.out.println(month+1);\rSystem.out.println(cl.getActualMaximum(Calendar.DAY_OF_MONTH));\rSystem.out.println(cl.getActualMaximum(Calendar.DAY_OF_YEAR));\rSystem.out.println(cl.getActualMaximum(Calendar.WEEK_OF_YEAR));\rSystem.out.println(cl.getActualMaximum(Calendar.WEEK_OF_MONTH));\rcl.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\rSystem.out.println(cl.getTime());\rcl.set(Calendar.MONTH, Calendar.FEBRUARY);\rSystem.out.println(cl.get(Calendar.MONTH)+1);\rcl.add(Calendar.YEAR, -1);\rSystem.out.println(cl.get(Calendar.YEAR));\r输出：\nMon Jan 25 22:35:35 CST 2021\r2021\r1\r31\r365\r52\r6\rSun Jan 24 22:35:35 CST 2021\r2\r2020\r六、java.lang.System 6.1 System.gc 运行垃圾回收器\n6.2 System.exit 终止当前运行的Java虚拟机，此方法要传入状态码参数，状态码是int类型，0表示正常，其他数表示非正常。\n6.3 System.arraycopy 其实System也提供了数组拷贝的方法arraycopy。它是native方法。按顺序传入的参数为，源数组的引用src，源数组被拷贝的开始位置srcPos，目标数组的引用dest，拷贝到目标数组的开始位置destPos，拷贝的长度length。\n如果目标数组引用就是源数组的引用，它甚至可以做到数组子序列在数组中的整体移动。System.arraycopy不像Arrays.copyOf具有填充和截断的操作。\nsrcPos+length大于源数组长度，或destPos+length大于目标数组长度，或desPos、srcPos和length任意一个为负数,会引发异常ArrayIndexOutOfBoundsException;src或dest为null，会引发NullPointerException;src和dest的基元类型不同,或者任意一个不是数组类型，或者一个数组的元素是基本数类型，另一个数组的元素是引用类型，引发ArrayStoreException；假设k小于length的非负整数，src[srcPos+k]无法转换类目标数组元素类型，也引发ArrayStoreException，注意srcPos到srcPos+k-1的部分已经被复制到目标数组，目标数组其他位置不会修改，\nArrays.copyOf拷贝肯定是从0开始的，而System.arraycopy是指定拷贝的位置，它的可操作空间更大。\n例如:\nint[] a = { 3, 8, 7, 2, 6, 4};\rint[] b = new int[a.length*2];\rSystem.arraycopy(a, 0, b, 0, a.length);\rSystem.out.println(Arrays.toString(a));\rSystem.out.println(Arrays.toString(b));\r输出:\n[3, 8, 7, 2, 6, 4]\r[3, 8, 7, 2, 6, 4, 0, 0, 0, 0, 0, 0]\r七、字符串 String、StringBuilder和StringBuffer都实现了CharSequence和Comparable接口。\n7.1 java.lang.String String表示字符串常量，是不可变的。\n7.1.1 String的创建 字符串最常用的创建方式，使用双引号包起一段文字。第一次出现的字符串，才会创建并保存在字符串常量池（在运行时常量池内）。可以赋值给String引用，如：String s = \u0026amp;quot;hello\u0026amp;quot;;\n第二次出现相同的字符串赋值给新的字符串引用，是不会重复创建，而是共享了第一次创建的字符串的内存地址。不过，把这个字符串传入构造器，使用new表达式是会在内存中重新创建字符串。\n例如：\nString s1 = \u0026quot;123\u0026quot;;\rString s2 = \u0026quot;123\u0026quot;;\rString s3 = new String(\u0026quot;123\u0026quot;);\rSystem.out.println(s1 == s2);\rSystem.out.println(s1 == s3);\r输出：\ntrue\rfalse\rs1和s2引用的同一个字符串，内存地址相同。凡是new表达式创建的对象，一定会在内存分配了空间，所以s1和s3的地址不同。\n7.1.2 常见方法 构造方法：\nString(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组构造新的 String 。 String(byte[] bytes, String charsetName) 构造一个新的String由指定用指定的字节的数组解码charset 。 String(char[] value) 分配新的 String ，使其表示当前包含在字符数组参数中的字符序列。\rString(String original) 初始化新创建的String对象，使其表示与参数相同的字符序列; 换句话说，新创建的字符串是参数字符串的副本。\r静态方法:\nstatic String format(String format, Object... args) 使用指定的格式字符串和参数返回格式化字符串。\rstatic String copyValueOf(char[] data) 相当于 valueOf(char[]) 。 static String copyValueOf(char[] data, int offset, int count) 相当于 valueOf(char[], int, int) 。 static String join(CharSequence delimiter, CharSequence... elements) 返回由 CharSequence elements的副本组成的新String，该副本与指定的 delimiter的副本连接在一起。 static String join(CharSequence delimiter, Iterable\u0026lt;? extends CharSequence\u0026gt; elements) 返回由 String的副本组成的新 String ，其中 CharSequence elements指定的 delimiter的副本。 static String valueOf(boolean b) 返回 boolean参数的字符串表示形式。 static String valueOf(char c) 返回 char参数的字符串表示形式。 static String valueOf(char[] data) 返回 char数组参数的字符串表示形式。 static String valueOf(char[] data, int offset, int count) 返回 char数组参数的特定子数组的字符串表示形式。 static String valueOf(double d) 返回 double参数的字符串表示形式。 static String valueOf(float f) 返回 float参数的字符串表示形式。 static String valueOf(int i) 返回 int参数的字符串表示形式。 static String valueOf(long l) 返回 long参数的字符串表示形式。 static String valueOf(Object obj) 返回 Object参数的字符串表示形式。\r非静态方法：\nint length() 返回此字符串的长度。 char charAt(int index) 返回指定索引处的 char值。 int codePoints(int index) 返回指定索引处的字符（Unicode代码点）。 int offsetByCodePoints(int index, int codePointOffset) 返回此 String中的索引，该索引从给定的 index偏移 codePointOffset的代码点。 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。\rboolean startsWith(String prefix, int toffset) 测试从指定索引开始的此字符串的子字符串是否以指定的前缀开头。 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结尾。\rint compareTo(String anotherString) 按字典顺序比较两个字符串。 int compareToIngnoreCase(String str) 按字典顺序比较两个字符串，忽略大小写差异。\rboolean contains(CharSequence s) 当且仅当此字符串包含指定的char值序列时，才返回true。 boolean contentEquals(CharSequence cs) 将此字符串与指定的 CharSequence 内容比较。 boolean contentEquals(StringBuffer sb) 将此字符串与指定的 StringBuffer 内容比较。\rboolean equals(Object anObject) 将此字符串与指定的对象进行比较。\rboolean equalsIgnoreCase(String anotherString) 将此 String与另一个 String比较，忽略了大小写。 byte[] getBytes() 使用平台的默认字符集将此 String编码为字节序列，将结果存储到新的字节数组中。 byte[] getBytes(String charsetName) 使用命名的字符集将此 String编码为字节序列，将结果存储到新的字节数组中。\rvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) int indexOf(int ch) 返回指定字符第一次出现的字符串中的索引。 int indexOf(int ch, int fromIndex) 返回指定字符第一次出现的此字符串中的索引，从指定索引处开始搜索。 int indexOf(String str) 返回指定子字符串第一次出现的字符串中的索引。 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回指定子字符串第一次出现的字符串中的索引。 int lastIndexOf(int ch) 返回指定字符最后一次出现的字符串中的索引。 int lastIndexOf(int ch, int fromIndex) 返回指定字符最后一次出现的字符串中的索引，从指定的索引开始向后搜索。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串最后一次出现的字符串中的索引，从指定索引开始向后搜索。 String intern() 返回字符串对象的规范表示。与此字符串具有相同内容的字符串，但保证来自唯一字符串池。 boolean isBlank() 如果字符串为空或仅包含 white space代码点，则返回 true ，否则 false 。 boolean isEmpty() 当且仅当length()是 0 ，返回 true。\rboolean matches(String regex) 判断此字符串是否与给定的 regular expression匹配。 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。\rboolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。\rString repeat(int count) 返回一个字符串，其值为此字符串的串联重复 count次。 String replace(char oldChar, char newChar) 返回从替换所有出现的导致一个字符串 oldChar在此字符串 newChar 。 String replace(CharSequence target, CharSequence replacement) 将此字符串中与文字目标序列匹配的每个子字符串替换为指定的文字替换序列。 String replaceAll(String regex, String replacement) 将给定替换的、给定 regular expression匹配的此字符串的每个子字符串替换。 String replaceFirst(String regex, String replacement) 将给定替换的、给定 regular expression匹配的此字符串的第一个子字符串替换。 String[] split(String regex) 将此字符串拆分为给定 regular expression的匹配 项 。 String[] split(String regex, int limit) 将此字符串拆分为给定 regular expression的匹配 项 。 String strip() 返回一个字符串，其值为此字符串，并删除了所有前导和尾随 white space 。 String stripLeading() 返回一个字符串，其值为此字符串，并删除了所有前导 white space 。 String stripTrailing() 返回一个字符串，其值为此字符串，并删除所有尾随 white space 。 CharSequence subSequence(int beginIndex, int endIndex) 返回作为此序列的子序列的字符序列。 String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 String substring(int beginIndex, int endIndex) 返回一个字符串，该字符串是此字符串的子字符串。 char[] toCharArray() 将此字符串转换为新的字符数组。 String toLowerCase() 使用默认语言环境的规则将此 String所有字符转换为小写。 String toUpperCase() 使用默认语言环境的规则将此 String所有字符转换为大写。 String trim() 返回一个字符串，其值为此字符串，删除了所有前导和尾随空格，其中space被定义为其代码点小于或等于 'U+0020' （空格字符）的任何字符。 7.2 java.lang.StringBuilder 可认为是线程不安全的字符串变量，拼接字符串更加高效。\nStringBuilder sb = new StringBuilder();\rfor (int i=0; i\u0026lt;10; i++) {\rsb.append(i);\r}\rString s = sb.toString();\rSystem.out.println(s);\r输出：\n123456789\r常用方法：\n构造方法：\nStringBuilder() 构造一个字符串构建器，其中不包含任何字符，初始容量为16个字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。\r非静态方法：\nint length() 返回长度（字符数）。 char charAt(int index) 返回指定索引处的此序列中的 char值。 int codePointAt(int index) 返回指定索引处的字符（Unicode代码点）。 int codePointBefore(int index) 返回指定索引之前的字符（Unicode代码点）。 int codePointCount(int beginIndex, int endIndex) 返回此序列的指定文本范围内的Unicode代码点数。 int compareTo(StringBuilder another) StringBuilder字典顺序比较两个 StringBuilder实例。 int offsetByCodePoints(int index, int codePointOffset) 返回此序列中的索引，该索引从给定的 index偏移 codePointOffset代码点。 StringBuilder replace(int start, int end, String str) 使用指定的 String的字符替换此序列的子字符串中的字符。 StringBuilder reverse() 导致此字符序列被序列的反向替换。 StringBuilder append(boolean b) 将 boolean参数的字符串表示形式追加到序列中。 StringBuilder append(char c) 将 char参数的字符串表示形式追加到此序列。 StringBuilder append(char[] str) 将 char数组参数的字符串表示形式追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子数组的字符串表示形式追加到此序列。 StringBuilder append(double d) 将 double参数的字符串表示形式追加到此序列。 StringBuilder append(float f) 将 float参数的字符串表示形式追加到此序列。 StringBuilder append(int i) 将 int参数的字符串表示形式追加到此序列。 StringBuilder append(long lng) 将 long参数的字符串表示形式追加到此序列。 StringBuilder append(CharSequence s) 将指定的字符序列追加到此 Appendable 。 StringBuilder append(CharSequence s, int start, int end) 将指定的 CharSequence序列追加到此序列。 StringBuilder append(Object obj) 追加 Object参数的字符串表示形式。 StringBuilder append(String str) 将指定的字符串追加到此字符序列。 StringBuilder append(StringBuffer sb) 将指定的 StringBuffer追加到此序列。 StringBuilder appendCodePoint(int codePoint) 将 codePoint参数的字符串表示形式追加到此序列。 StringBuilder delete(int start, int end) 删除此序列的子字符串中的字符。 StringBuilder deleteCharAt(int index) 按此顺序删除指定位置的 char 。 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst 。 int indexOf(String str) 返回指定子字符串第一次出现的字符串中的索引。 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回指定子字符串第一次出现的字符串中的索引。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串最后一次出现的字符串中的索引，从指定索引开始向后搜索。 StringBuilder insert(int offset, boolean b) 将 boolean参数的字符串表示形式插入此序列中。 StringBuilder insert(int offset, char c) 将 char参数的字符串表示形式插入此序列中。 StringBuilder insert(int offset, char[] str) 将 char数组参数的字符串表示形式插入此序列中。 StringBuilder insert(int index, char[] str, int offset, int len) 将str数组参数的子数组的字符串表示形式插入此序列中。 StringBuilder insert(int offset, double d) 将 double参数的字符串表示形式插入此序列中。 StringBuilder insert(int offset, float f) 将 float参数的字符串表示形式插入此序列中。 StringBuilder insert(int offset, int i) 将第二个 int参数的字符串表示形式插入此序列中。 StringBuilder insert(int offset, long l) 将 long参数的字符串表示形式插入此序列中。 StringBuilder insert(int dstOffset, CharSequence s) 将指定的 CharSequence插入此序列。 StringBuilder insert(int dstOffset, CharSequence s, int start, int end) 将指定的 CharSequence序列插入此序列。 StringBuilder insert(int offset, Object obj) 将 Object参数的字符串表示形式插入此字符序列中。 StringBuilder insert(int offset, String str) 将字符串插入此字符序列。 void setCharAt(int index, char ch) 指定索引处的字符设置为 ch 。 void setLength(int newLength) 设置字符序列的长度。 CharSequence subSequence(int start, int end) 返回一个新的字符序列，它是该序列的子序列。 String substring(int start) 返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。 String substring(int start, int end) 返回一个新的 String ，其中包含当前包含在此序列中的字符的子序列。 void trimToSize() 尝试减少用于字符序列的存储空间。 7.2 java.lang.StringBuffer 用于StringBuffer类似，但可认为线程安全的字符串变量，里面很多方法用synchronized修饰，表示同步方法，多个线程操作StringBuffer对象，是不会同时进行，字符串处理是互斥的。\n常用方法：\n构造器：\nStringBuffer() 构造一个字符串缓冲区，其中没有字符，初始容量为16个字符。 StringBuffer(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。 非静态方法：\nchar charAt(int index) 返回指定索引处的此序列中的 char值。 int codePointAt(int index) 返回指定索引处的字符（Unicode代码点）。 int codePointBefore(int index) 返回指定索引之前的字符（Unicode代码点）。 int codePointCount(int beginIndex, int endIndex) 返回此序列的指定文本范围内的Unicode代码点数。 int offsetByCodePoints(int index, int codePointOffset) 返回此序列中的索引，该索引从给定的 index偏移 codePointOffset代码点。 StringBuffer replace(int start, int end, String str) 使用指定的 String的字符替换此序列的子字符串中的字符。 StringBuffer reverse() 导致此字符序列被序列的反向替换。 StringBuffer append(boolean b) 将 boolean参数的字符串表示形式追加到序列中。 StringBuffer append(char c) 将 char参数的字符串表示形式追加到此序列。 StringBuffer append(char[] str) 将 char数组参数的字符串表示形式追加到此序列。 StringBuffer append(char[] str, int offset, int len) 将 char数组参数的子数组的字符串表示形式追加到此序列。 StringBuffer append(double d) 将 double参数的字符串表示形式追加到此序列。 StringBuffer append(float f) 将 float参数的字符串表示形式追加到此序列。 StringBuffer append(int i) 将 int参数的字符串表示形式追加到此序列。 StringBuffer append(long lng) 将 long参数的字符串表示形式追加到此序列。 StringBuffer append(CharSequence s) 将指定的 CharSequence追加到此序列。 StringBuffer append(CharSequence s, int start, int end) 将指定的 CharSequence序列附加到此序列。 StringBuffer append(Object obj) 追加 Object参数的字符串表示形式。 StringBuffer append(String str) 将指定的字符串追加到此字符序列。 StringBuffer append(StringBuffer sb) 将指定的 StringBuffer追加到此序列。 StringBuffer appendCodePoint(int codePoint) 将 codePoint参数的字符串表示形式追加到此序列。 int compareTo(StringBuffer another) StringBuffer字典顺序比较两个 StringBuffer实例。 StringBuffer delete(int start, int end) 删除此序列的子字符串中的字符。 StringBuffer deleteCharAt(int index) 按此顺序删除指定位置的 char 。 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst 。 int indexOf(String str) 返回指定子字符串第一次出现的字符串中的索引。 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回指定子字符串第一次出现的字符串中的索引。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串最后一次出现的字符串中的索引，从指定索引开始向后搜索。 StringBuffer insert(int offset, boolean b) 将 boolean参数的字符串表示形式插入此序列中。 StringBuffer insert(int offset, char c) 将 char参数的字符串表示形式插入此序列中。 StringBuffer insert(int offset, char[] str) 将 char数组参数的字符串表示形式插入此序列中。 StringBuffer insert(int index, char[] str, int offset, int len) 将 str数组参数的子数组的字符串表示形式插入此序列中。 StringBuffer insert(int offset, double d) 将 double参数的字符串表示形式插入此序列中。 StringBuffer insert(int offset, float f) 将 float参数的字符串表示形式插入此序列中。 StringBuffer insert(int offset, int i) 将第二个 int参数的字符串表示形式插入到此序列中。 StringBuffer insert(int offset, long l) 将 long参数的字符串表示形式插入此序列中。 StringBuffer insert(int dstOffset, CharSequence s) 将指定的 CharSequence插入此序列。 StringBuffer insert(int dstOffset, CharSequence s, int start, int end) 将指定的 CharSequence序列插入此序列。 StringBuffer insert(int offset, Object obj) 将 Object参数的字符串表示形式插入此字符序列。 StringBuffer insert(int offset, String str) 将字符串插入此字符序列。 void setCharAt(int index, char ch) 指定索引处的字符设置为 ch 。 void setLength(int newLength) 设置字符序列的长度。 CharSequence subSequence(int start, int end) 返回一个新的字符序列，它是该序列的子序列。 String substring(int start) 返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。 String substring(int start, int end) 返回一个新的 String ，其中包含当前包含在此序列中的字符的子序列。 void trimToSize() 尝试减少用于字符序列的存储空间。 ","description":"一些常用类库的使用，如日期和时间，字符串处理，数组处理等","id":27,"section":"posts","tags":["常用类库"],"title":"Java常用类库","uri":"https://qinry.github.io/posts/2021/01/java-common-class-library/"},{"content":"一、类和对象 面向对象是相对于面向过程来讲的，指的是把 相关的数据和方法组织为一个整体来看待。面向过程关注的是执行的过程，面向对象关注的是具备功能的对象。 面向过程到面向对象，是程序员思想上 从执行者到指挥者的转变。\n1.1 定义类 类定义格式：\nclass 类名 {\r成员属性\r成员方法\r}\r属性定义格式：\n// 1.定义成员属性，没有指定初始值，初始为默认值\r权限修饰符 数据类型 属性名;\r// 2.定义成员属性，指定初始值\r权限修饰符 数据类型 属性名 = 初始化值;\r方法定义格式：\n权限修饰符 返回值类型 方法名(形式参数列表) {\r// 方法体\rreturn 返回值;\r}\r成员变量和方法的修饰符是可选的。一般都是要写上去来限定访问权限，不写将采用默认权限限制成员变量与方法。其实默认的权限只允许包内私有访问，即只能被同一包内的类访问。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Cat { String name; int age; public void setName(String s) { name = s; } public void setAge(int i) { age = i; } public String getName() { return name; } public int getAge() { return age; } public void running() { System.out.println(name+\u0026#34;在跑\u0026#34;); } }   对象的属性可以在类内赋值，也可以用方法给予像setName()和setAge()。这里还可以在main方法中对创建好的Cat对象直接.加属性名再赋值，由于属性都没用权限修饰符限制对外的访问。\n1.1.1 构造方法 构造方法是在创建某类的对象时自动调用的方法，用于初始化对象。如果程序员没有编写构造方法，编译器会自动生成默认的构造方法，默认的构造方法没有参数列表。程序员根据自己的需要编写带有形参的构造器，形参用来指定属性的初始化。自己写构造器，Java将不自动生成默认构造器。所以建议全参构造器和无参构造器一起写。\n构造方法的格式：\n权限修饰符 类名(形式参数列表) {\r// 方法体\r}\r例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Cat { // ...  public Cat() {} public Cat(String s) { name = s; } public Cat(int i) { age = i; } public Cat(String s, int i) { name = s; age = i; } }   Java提供了this关键字来表示当前对象，可以解决对象的成员变量与本地变量的命名冲突。this完全可以当作对象来看待，对象属性可以通过this.属性来访问。在方法中直接使用成员变量，其实都隐含this，可以省略，但有方法有同名变量时，则不能省略，必须指出是局部变量还是对象的成员变量。\n例如：\n1 2 3 4 5 6 7 8 9 10 11  class Cat { String name; int age; public Cat() { } public Cat(String name, int age) { this.name = name; this.age = age; } }   this还有个特别的用法，在构造器中用this()调用其他重载的构造器，\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Cat { String name; int age; public Cat(int age) { this(null, age); } public Cat(String name) { this(name, 0); } public Cat(String name, int age) { this.name = name; this.age = age; } }   Java规定使用this()时必须在构造器的第一行。\n1.1.2 方法的重载 Java方法支持重载，重载用于解决需要多个有同一个方法名但传入的参数有所不同的方法的问题。单纯返回值类型不同，方法签名相同的多个方法的重载是不支持的，也就是说方法重载与返回值类型无关，与方法的形参列表的长度，形参类型，形参的顺序有关。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Cat { String name; int age; public Cat(int age) { this(null, age); } public Cat(String name) { this(name, 0); } public Cat(String name, int age) { this.name = name; this.age = age; } }   1.1.3 可变参数 JDK1.5后支持可变参数列表，方法的参数的数量可以任意一个，不过可变参数必须放在参数列表的最后的位置，否则编译出错。\n写法：\n权限修饰符 返回值类型 方法名(数据类型... 参数名称) {\r// 方法体\r}\r// 可变参数前可有多个形参，但可变参数后不能有别的参数，否则无法确定可变参数的位置\r权限修饰符 返回值类型 方法名(数据类型 参数名称, 数据类型... 参数名称) {\r// 方法体\r}\r/*\r这个绝对不允许\r权限修饰符 返回值类型 方法名(数据类型... 参数名称, 数据类型 参数名称) {\r// 方法体\r}\r*/\r可变参数会被打包成数组在方法内部使用。可变参数只在方法内才被当作数组，在传参的位置并不是，所以不可以把可变参数的类型的一个数组传入。如果传入一个数组，可变参数就只有一个，把这个数组打包成含有一个元素为这个数组的数组，导致类型不一致。并不是数组内容当作可变参数的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Print { public static void printf(String s, int... args) { for (int i=0; i\u0026lt;args.length; i++) System.out.printf(s, args); } public static void main(String[] args) { // 1，2，3在prinf中会被打包成数组{ 2021, 1, 22 }  Print.print(\u0026#34;%d-%d-%d\u0026#34;, 2021, 1, 22); // 不可取：  // Print.print(\u0026#34;%d-%d-%d\u0026#34;, new int[3]{ 1, 2, 3 });  } }   1.2 对象的初始化 对象创建的格式：\n类名 对象名 = new 构造方法();\r访问对象属性和调用格式：\n对象名.属性名;\r对象名.方法名(实际参数列表);\r例如：\n1 2 3 4  Cat cat = new Cat(); cat.age = 1; cat.name = \u0026#34;汤姆\u0026#34;; cat.running();   简单了解对象实例化过程在内存中分配空间（地址信息是假设的）。先是在栈中为Cat对象引用分配空间（对象引用可能是用于指向对象在堆中的的起始地址的引用指针，也可能是代表对象的句柄或者其他与此对象相关的位置），然后是在堆中为对象申请空间并存储对象的成员变量，假如类有静态变量，是存在方法区中，与对象和局部变量不同，对象是在堆中，局部变量是在栈中。\n例如：\n1.2.1 静态代码块 关键字static，修饰成员变量时，表示它是类所有实例对象共享的变量；修饰方法类似，表示类所有对象共有的方法，说明static修饰的属性和方法与对象无关，与类相关。static修饰的成员属性，有时又称“类变量”，方法又称“类方法”。类与对象的关系，可以简单认为，一个是图纸，一个是根据图纸造出的实物。类就是图纸，对象就是实物。static修饰的变量会储存在JVM运行时内存区域的方法区中，方法区存放类加载信息，静态变量和常量等。\n关键字还可以修饰代码块在结构定义语句块内，例如：\nclass Cat {\r// ...\rstatic { // ... }\r// ...\r}\r在第一次创建对象或访问类的静态变量时，类加载器会加载该类的类型信息，并只执行一次static代码块，其作用是初始化静态变量，在构造方法调用前。\n1.2.2 构造代码块 与静态代码块类似，只是没有static关键字的代码块放在结构定义语句块中，例如：\nclass Cat {\r// ...\r{ // ... }\r// ...\r}\r它在构造器调用前，静态代码块执行后，执行。每次实例化该类是都会执行的代码块。起作用是构造对象内部，初始化成员变量。其意义有时对于匿名内部类初始化是必须的，由于没有构造方法，只能使用静态代码块和构造代码块来实例初始化。\n1.3 main方法 .java文件可以有多个class。但只能拥有一个public修饰的class，而且其类名必须与.java文件名一致，公共类是这个java源文件的主类，它的main方法才是程序的执行入口。\nmain方法形式：\npublic static void main(String[] args) {\r}\rJava中的main方法，被public和static修饰，可以被Java解释程序直接调用执行，而不用创建相关类的对象（在命令行中输入\u0026quot;java 主类名\u0026quot;回车直接调用main方法）。主方法可以没有返回值，但方法名不能写错，否则抛出\u0026quot;NoSuchMethodError: main\u0026quot;的错误。形参列表是字符串数组，可以接受控制台输入参数。\n每个表示实际参数的字符串不含空格的话，可以不用双引号扩起来，如果含有空格，请用一定要用双引号包起来。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* 命令行： (1) java Main 1 2 3 4 5 6 7 (2) java Main \u0026#34;Hello World\u0026#34; \u0026#34;I love Java\u0026#34; \u0026#34;I love Spring Boot\u0026#34; */ class Main { public static void main(String[] args) { for (int i=0; i\u0026lt;args.length; i++) { System.out.println(args[i]); } } } /* 输出： (1) 1 2 3 4 5 6 7 (2) Hello World I love Java I love Spring Boot */   二、 继承 Java通过使用关键字extends，来定义一个子类继承父类。允许多重继承，但支持不多继承。多重继承意思说，允许一个子类的父类也有父类，不断追溯祖先，继承体系可以构建出一个家族树，树的高度没有限制，家族的代数没有限制，所有类都有一个共同的祖先类就是Object，在java.lang包中。多继承，就是子类可以继承多个父类，简单理解为一个儿子有多个生父，这个在Java不允许。\n继承格式：\nclass Parent {\r}\rclass Son extends Parent {\r}\r2.1 super关键字 super关键字用法与this类似，不过它代表子类中从父类继承的部分。通过它可以访问父类部分的变量，如\u0026quot;super.父类成员属性名称;\u0026quot;。还可以调用父类的构造方法。\n2.2 子类实例化 子类的构造器的第一行必须是super()，先构造出对象父类部分，再初始化子类部分变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person() {} } class Student extends Person { String id; public Student(String name, int age, String id) { super(name, age); this.id = id; } }   子类实例化如下：\n1 2 3  Student s = new Student(\u0026#34;张三\u0026#34;, 19, \u0026#34;a1001\u0026#34;); Person p = s; Student s2 = (Stduent)p;   简单看看子类对象实例化在内存中如何分配空间的（地址信息是假设的）。子类对象有super，其实可以认为是指向子类实例对象父类部分的地址的引用指针。\n子类对象引用可以赋值给父类引用，会自动类型转换，在家族树中通常由老到小往下排的，故又叫做向上类型转换。如果父类对象引用赋值给子类对象引用，必须加上强制类型转换符，属于强制类型转换，又叫做向下类型转换。\n多态\n多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。\n2.2 方法的覆写 父类已有的非静态方法会继承到子类当中，子类的方法是允许改写父类的实现的，这又被叫做方法的重写。可以使用Java提供的注解@Override来说明这个方法是重写父类的方法，如果这个重写父类方法的声明是父类中不存在的方法就会编译出错，用来保证自己重写方法的方法签名编写正确。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Animal { public void running() { } } class Cat extends Animal { String name; public Cat(String name) { this.name = name; } public Cat() {} @Override public void running() { System.out.println(name+\u0026#34;在跑\u0026#34;); } }   2.3 final修饰符 final可以修饰成员变量，非静态成员方法和类。\n final变量只能赋值一次，必须赋值 final方法在继承中不能被重写，如果不在继承中使用，编译器会将方法内嵌提供方法体的执行效率 final类不能被继承，其所有方法隐式为final。  三、访问权限 3.1 包  把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 包如同文件夹一样，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名 加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。  3.1.1 包名规范 包名必须小写，并用.划分目录，一般为com.公司名.项目名.模块。如：com.github.qinry。\n3.1.2 定义包和包导入 包的定义必须在java源文件的首行，例如:\npackage 包名。\r在开发过程，会使用自己编写的库或第三方的API,就需要导包。例如：\nimport 包名.类名;\rimport static 包名.类名.静态对象;\rimport static 包名.类名.静态方法;\r静态导入的对象和方法直接访问和调用，不用使用.。\n3.2 权限修饰符 不使用修饰符修饰的类、成员变量、方法，表示默认的权限，可以认为是包内私有，只允许同包访问，下面都说是默认权限。\n类只能用public权限或者默认权限，编译单元只能拥有一个public权限的类；成员内部类可以用public、private权限和默认权限。\n成员变量和方法可供选择的权限是全部。局部变量不能用static修饰也不能用权限修饰符修饰\n\r\r\r修饰符\r类\r包\r子类\r其他包\r\r\r\r\rpublic\r✓\r✓\r✓\r✓\r\r\rprotected\r✓\r✓\r✓\r✗\r\r\r(默认)\r✓\r✓\r✗\r✗\r\r\rprivate\r✓\r✗\r✗\r✗\r\r\r\r四、内部类 4.1 成员内部类 成员内部类在结构定义语句块中，写法：\n1 2 3 4 5 6 7 8 9 10  class Outter { int a; String s; class Inner { int x; { x = Outter.this.a; } } }   成员内部类可以链接外部类，意思说可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。具体来说，可以以\u0026quot;外部类名.this.成员变量\u0026quot;的方式访问或外部类名.this.成员方法(实际参数列表)的方式来调用。如果内部类和外部类之间没有命名冲突可以不加这些限定，但如果有冲突，则必须加上这些限定。\n内部类的实例化，内部类类型要指明外部类类型，要通过外部类的对象才能使用内部类new表达式\n例如：\n1 2  Outter outter = new Outter(); Outter.Inner inner = outter.new Inner();   4.2 局部内部类 局部内部类在一个方法内部或者一个作用域内定义。它和成员内部类的区别在于局部内部类的访问仅限 于方法内或者该作用域内。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Person{ public Person() { } } class Man { public Man(){ } public People getPerson(){ class Student extends People{ //局部内部类  int age =0; } return new Student(); } }   局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及 static修饰符的。\n4.3 匿名内部类 匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：\nnew 父类构造器（参数列表）|实现接口() {\r//匿名内部类的类体部分 }\r例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  class B { public void do() {} } class A { public B getB() { return new B() { @Override public void do() { System.out.println(\u0026#34;...\u0026#34;); } }; } }   在使用匿名内部类的过程中，我们需要注意如下几点：\n 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能 继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 只能访问final型的局部变量  建议使用lambda表达式，其应优先于匿名内部类。\n4.4 静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。 静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非 static成员变量或者方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Test { public static void main(String[] args) { Outter.Inner inner = new Outter.Inner(); } } class Outter { public Outter() { } static class Inner { public Inner() { } } }   五、抽象类和接口 5.1 抽象类 抽象类必须使用abstract class声明 一个抽象类中可以没有抽象方法。抽象方法必须写在抽象类或者接口中。\n写法：\nabstract class 抽象类名 {\rpublic abstract 返回值类型 方法名(形参列表);\r}\r只声明而未实现的方法称为抽象方法（未实现指的是：没有“{}”方法体），抽象方法必须使用abstract关键字声明。\n在抽象类的使用中有几个原则：\n 抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字new完成。 一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则必须覆写(重写)抽象类中的全部抽象方法  常见问题\n1、 抽象类能否使用final声明？\n不能，因为final属修饰的类是不能有子类的，而抽象类必须有子类才有意义，所以不能。\n2、 抽象类能否有构造方法？\n能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的 构造方法（默认是无参的），之后再调用子类自己的构造方法。\n抽象类和普通类的区别\n 抽象类必须用public或procted 修饰(如果为private修饰，那么子类则无法继承，也就无法实现其 抽象方法）。默认缺省为 public 抽象类不可以使用new关键字创建对象， 但是在子类创建对象时， 抽象父类也会被JVM实例化。 如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必 须定义为 abstract类  5.2 接口 如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接口。\n写法：\ninterface 接口名称{ 全局常量 ; 抽象方法 ; }\r因为接口本身都是由全局常量和抽象方法组成 ， 所以接口中的成员定义可以简写：\n1、全局常量编写时， 可以省略public static final 关键字，例如：\n1  public static final String INFO = \u0026#34;内容\u0026#34; ;   简写后：\n1  String INFO = \u0026#34;内容\u0026#34; ;   2、抽象方法编写时， 可以省略 public abstract 关键字， 例如：\n1  public abstract void print() ;   简写后：\n1  void print();   实现接口的导出类，用法：\nclass 类名 implements 父接口1,父接口2... {\r@Override\rpublic 返回值类型 方法名(形参列表) {\r// 方法体\rreturn 返回值;\r}\r}\r如果一个类即要实现接口，又要继承抽象类，用法：\nclass 类名 extends 基类 implements 父接口1,父接口2... {\r}\rJava中的接口允许多继承，用法：\ninterface A extends B, C{\r}\r如果一个接口要想使用，必须依靠子类。 子类（如果不是抽象类的话）要实现接口中的所有抽象方法。\n接口和抽象类的区别\n 抽象类要被子类继承，接口要被类实现。 接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类使用继承来使用， 无法多继承。 接口使用实现来使用， 可以多实现 抽象类中可以包含static方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明静态方法） 接口不能有构造方法，但是抽象类可以有  5.3 instanceof运算符 作用：判断某个对象是否是指定类的实例，则可以使用instanceof关键字 格式：\n实例化对象 instanceof 类 //此操作返回boolean类型的数据\r六、异常处理 异常是在程序中导致程序中断运行的一种指令流。\n异常类继承体系，如下：\nThrowable存在两个子类：\n Error：表示的是错误，是JVM发出的错误操作,只能尽量避免，无法用代码处理。 Exception：一般表示所有程序中的错误，所以一般在程序中将进行try…catch的处理。  异常类分两类：一类是非受检异常，又为运行时异常；另一类是受检异常。\n多异常捕获的注意点：\n 捕获更粗的异常不能放在捕获更细的异常之前。 如果为了方便，则可以将所有的异常都使用Exception进行捕获。  6.1 异常捕获 try块中执行代码，遇到异常抛出，交给catch捕获, 然后进行异常处理。由于try中抛出异常，会在catch中匹配，是不会回到原来的地方，将try-catch语句可以放入while循环，在while的帮助下，能回到到原来中断的地方继续执行，这是一种恢复操作的模型（不太实用，尽量少用，因为它会导致耦合）。\n语法:\ntry {\r// 假如这里会抛出异常\r} catch(异常类1 对象名1) {\r// 这里匹配异常后处理\r} ... catch(异常类n 对象名n) {\r// 这里匹配异常后处理\r}\r子类（或者导出类）重写方法声明的异常说明所列的异常范围可以比父类（或接口）声明的范围窄，这与子类（或导出类）的方法会比父类（或接口）声明的方法多的情况是相反的。\n子类（或者导出类）所列的异常类，不要求对应的异常类一定一致，可以是对应异常类的派生类。\n异常限制对构造器不起作用，派生类构造器不能捕获基类构造器抛出的异常，所以派生构造器的异常说明必须包括基类构造器的异常说明；\n6.2 异常抛出 创建一个异常对象，然后从当前环境将异常对象抛出，中断当前方法或作用域的执行。\n语法:\nthrow new 异常类名(\u0026quot;异常信息\u0026quot;);\r关键字throw之后，和创建普通对象一样创建异常对象。\n6.3 异常说明 异常说明不会处理异常，只是将异常交给方法调用来处理。\n为了让调用者能知道方法可能抛出异常，以便于捕获它们，用关键字throws跟上一个或多个异常类名，作为方法声明的一部分,在参数列表之后，花括号之前。声明方法将会抛出的异常，实际上不一定抛出。为异常先占个位子，对于定义抽象基类和接口时比较重要，其派生类或接口实现将能抛出预声明的异常。\n语法:\n权限修饰符 返回值类型 方法名() throws 异常类1, 异常类2, ..., 异常类n {\r// 会抛出异常\r}\r6.4 自定义异常类 编写一个类， 继承Exception，并重写一参构造方法 即可完成自定义受检异常类型。 编写一个类， 继承RuntimeExcepion，并重写一参构造方法 即可完成自定义运行时异常类型。\n比如：\nclass MyException extends Exception{ // 继承Exception，表示一个自定义异常类 public MyException(String msg){ super(msg) ; // 调用Exception中有一个参数的构造 } }\r6.5 finally子句 用finally子句进行清理，不仅有内存清理，还有资源恢复初始态，如把打开的文件关闭等等。常常将finally放在catch之后。\n语法:\ntry {\r// 抛出异常\r} catch(Exception e) {\r// 处理异常\r} finally {\r// 清理\r}\rfinally能保证总是执行的，除非在try或catch中停止了JVM（比如：System.exit(0)）,则finally不会执行。\n即使是在它之前有return语句，也会在方法结束前，执行finally子句。这里要注意，如果return语句返回的是局部变量，实际上是返回这个变量的拷贝。所以return返回变量，finally即使重新赋值给这个变量，也不会对这个变量的拷贝产生任何作用。不过finally子句操作的变量是对象的引用，对其属性进行赋值修改， 却会影响对象属性的值。\nfinally代码中不建议包含return，因为程序会在上述的流程中提前退出，也就是说返回的值不是try或 catch中的值。\nfinally还有缺陷，会导致一些异常被忽略,如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 在某个类内部 static void f() throws FirstException {} static void g() throws SecondException {} public static void main(String[] args) { try { try { f(); } finally { g(); } } catch(Exception e) { } }   这里导致 f() 的FirstException被忽略。\n6.6 异常链 捕获底层异常后再抛出高层异常，还可以把原始异常信息保存在这个新抛出的异常内，通过getCause()可以查看原始异常信息。对于简单的程序而言，通过异常链可以实现将受检异常转换为非受检异常来达到屏蔽检查的目的。\nThrowable子类包括Error（报告系统错误）, Exception（最常用的异常）以及RuntimeException（运行时异常，又称未检查异常）。他们的构造器，有接受Throwable类型的cause参数(表示原始异常对象)的构造器,能够把原始异常传递给新异常。有同等效果的一个方法initCause()也能传递原始异常，如果异常类没有传入cause参数的构造器就可以使用initCause()方法。\n例如:\n// LowLevelException表示底层异常\r// HighLevelException表示高层异常\rtry {\r// ..\r} catch(LowLevelException e) {\rthrow new HighLevelException(e);// 传递新异常，并抛出\r}\r或\ntry {\r// ...\r} catch(LowLevelException e) {\r// 在某个方法内\r// 自定义继承Exception的异常类\rHighLevelException e2 = new HighLevelException(); e2.initCause(e);\rthrow e2;\r}\r","description":"本文介绍基于对象、面向对象的编程范式和异常处理。基于对象仅仅是将数据与方法组织一个单元，面向对象进一步可以将这些单元构建出庞大的继承体系。Java中的包能够分门别类管理类和接口，方便查找和使用。Java把异常看成是类，异常处理涉及异常捕获，异常抛出和异常说明。还支持自定义异常类。","id":28,"section":"posts","tags":["面向对象编程"],"title":"面向对象编程","uri":"https://qinry.github.io/posts/2021/01/java-oriented-object/"},{"content":"一、基本数据类型 Java的数据类型有基本数据类型（primitive）、类（包括枚举）、接口（包括注解）和数组，后三个类型有被称为引用类型（reference）。本文着重基本数据类型。Java中有8种基本数据类型，分别有4种表示整数的整型（byte、short、int、long）；2种表示浮点数的浮点型（float和double）；1种字符类型char；还有用于表示真或假的布尔类型boolean。\n\r\r\r类型\r范围\r存储需求\r默认值\r\r\r\r\rbyte\r-128 ~ 127\r1 byte\r(byte)0\r\r\rshort\r-32 768 ~ 32 767\r2byte\r(short)0\r\r\rint\r-2 147 483 648 ~ 2 147 483 647(刚刚超过20亿)\r4byte\r0\r\r\rlong\r-9 223 372 036 854 775 808 ~ 9 223 972 036 854 775 807\r8byte\r0.0L\r\r\rfloat\r大约±3.402 823 47E+38F(有效位数6~7位)\r4byte\r0.0f\r\r\rdouble\r大约±1.797 693 134 862 315 70E+308(有效位数为15为)\r8byte\r0.0d\r\r\rchar\r\u0026lsquo;\\u0000\u0026rsquo; ~ \u0026lsquo;\\uFFFF\u0026rsquo;\r2byte\r\u0026lsquo;\\u0000\u0026rsquo;\r\r\rboolean\rfalse,true\r1 byte\rfalse\r\r\r\r1.1 声明变量和初始化 Java声明变量要先指定变量类型，再指定变量名，最后不要忘记分号结束。变量初始化会用到下面会讲的赋值运算符。\n1 2 3 4  double salary = 0.0; int size = 0; long time = 0L; boolean done = true;   标识符是对包、类、方法、参数和变量等要素命名时使用字符序列。其规则是\n 由字母、数字、下划线(_)和美元符号($)组成 必须以字母开头 区分大小写 长度不限制 不能使用Java保留字  还有一点虽然不是强制的，建议标识符命名要见名知意。\n1.2 类型转换 数值类型之间是可以转换。\n上面6条黑线表示的类型转换没有信息损失，而3条红线表示的类型转换可能精度丢失。\n像没有信息损失的类型转换，Java是会自动帮我们实现转换的，这种类型转换叫做自动类型转换，也就是容量小的类型自动转换容量大的数据类型或者精度低自动转换精度高的数据类型。\n而容量大类型转换容量小类型或者精度高自动转换精度低的数据类型，需要加上强制转换符的被称为强制类型转换，这种类型转换可能造成数据的溢出和精度的降低，使用时要小心。圆括号里面放要转换的类型就是强制转换符格式:(type)。\n写法：\n1 2  int i = 15616161; short s = (short)i;   二、运算符 运算符用于连接值，计算出各种结果。\n2.1 算数运算符 参与数字加、减、乘、除和取模（求余运算）的运算符分别是+, -, *, /和%。当参与除法运算的两个操作数都为整数时，表示整数除法；否则，表示浮点数除法，Java的整数除法是地板除，除法的结果小数位是会被截断的，如15/2等于7。相同的数分别用整数和浮点数表示来求余得到的结果可能不同，如：15%2等于，15.0%2等于7.5。需要注意整数除以0会产生异常，浮点数除以0则会得到无穷大或NaN结果。\n2.2 自增自减运算符 Java借鉴C/C++的自增自减运算符，n++是先使用变量原来的值再加1，++n则是先加1再使用变量；n–与–n类似只不过是减1罢了。\n1 2 3  int n = 2; int m = n++; // m为2，n为3 int p = ++n; // p为4，n为4   2.3 赋值运算符 赋值运算符不只=号一个，一般把其他运算符放在=号左边也构成赋值运算符，像+=,-=,*=,/=,%=等等。\n写法：\n1  x += 4;   以上等价于\n1  x = x + 4;   2.4 关系运算符 用于检测相等性，可以使用两个等号==。\n写法：\n1  15 % 2 == 0   上面得到的值为false。说明关系运算符操作的结果为布尔类型。\n用于检测不相等有!=。\n写法：\n1  3 != 0   上面得到的值为true。\n还有检测大小的小于\u0026amp;lt;，小于等于\u0026amp;lt;=，大于\u0026amp;gt;，大于等于\u0026amp;gt;=运算符。\n2.5 逻辑运算符 逻辑运算符操作后得到的结果是布尔类型。逻辑运算符使用的表达式得到的结果必须是布尔类型，不能是整型1或0，否则语法是错误的，这与C/C++用法不同。\n逻辑与\u0026amp;用法格式:\n表达式 \u0026amp; 表达式\r任意一边为false，结果为false。当两边同时都为true，结果才为true。\n例如：\n1  3 == 0 \u0026amp; 15 % 2 != 0   得到的值为false。要注意两个表达式都要执行，才能得出结果。\n逻辑或|用法格式:\n表达式 | 表达式\r任意一边为true，结果为true。当两边都为false，结果才为false。\n例如：\n1  15 % 2 != 0 | 3 == 0   得到的值为true。要注意两个表达式都要执行，才能得出结果。\n下面介绍更加高效的逻辑与和逻辑或运算符，也是比较常用的。\n短路逻辑与\u0026amp;\u0026amp;用法格式：\n表达式 \u0026amp;\u0026amp; 表达式\r任意一边为false，结果为false。当两边同时都为true，结果才为true。\n例如：\n1  3 == 0 \u0026amp;\u0026amp; 15 % 2 != 0   虽然与逻辑与\u0026amp;得到的值同为false。但与逻辑与\u0026amp;不同是，有时候不需要两个表达式都执行，如果在\u0026amp;\u0026amp;前面的表达式操作得到false，那么\u0026amp;\u0026amp;后面的表达式不用得到执行，直接得到false结果。\n短路逻辑或||用法格式：\n表达式 || 表达式\r任意一边为true，结果为true。当两边都为false，结果才为false。\n例如：\n1  15 % 2 != 0 || 3 == 0   虽然与逻辑或|得到的值同为true。与逻辑或|不同，有时候不需要两个表达式都执行，如果在||前面的表达式操作得到true，那么||后面的表达式不用得到执行，直接得到true结果。\n逻辑否!用法格式：\n!(表达式)\r把表达式结果取反，当表达式为true时，结果为false；当表达式为false，结果为true。\n例如：\n!(15 % 2 == 0)\r得到结果为true，本来15 % 2 == 0为false，取反得到true结果。\n逻辑运算符通常会和使用关系运算符的表达式一起使用，常常放在条件判断语句中。\n2.6 字符串连接符 将字符串连接符之前，将Java提供的字符串类String。它是Java类库给用户提供的一个类，属于引用类型，也是我们用到的第一个类，方便我们存取字符串和操作字符串。\n字符串变量的声明与初始化，写法如下：\n1 2  String s; s = \u0026#34;I love Java!\u0026#34;;   上面的第一句是变量声明，引用类型与基本类型的声明一样，都是变量类写在前，后跟变量，分号结束。初始化可以使用双引号把一段文字包围起来赋值给String变量。一般引用类型变量的赋值，要使用new表达式创建一个对象再赋给变量，像new String(\u0026amp;quot;I love Java!\u0026amp;quot;);。String类特殊，可以不使用new表达式，直接双引号把文字阔起来赋值给变量即可。\n字符串连接符是+号，当+号两边任意一边操作数是字符串，+就是字符串连接符，起到字符串拼接的作用。\n写法：\n1  String s = \u0026#34;I love \u0026#34;+\u0026#34;Java\u0026#34;+11·;   s为\u0026quot;I love Java11\u0026quot;。字符串连接符会把非字符串类型转换为字符串类型再进行拼接，正如上方那样。\n例如：\n1  String s = 1+2+\u0026#34;00\u0026#34;+0;   s结果是3000（运算符运算顺序是从左到右的，如果有圆括号的情况下，优先执行圆括号里面的表达式）。1加2等于3，3接着字符连接符和字符串\u0026quot;00\u0026quot;，3转换成字符串\u0026quot;3\u0026quot;和\u0026quot;00\u0026quot;连接成\u0026quot;300\u0026quot;，其后是0，将其转换为\u0026quot;0\u0026quot;和前面的\u0026quot;300\u0026quot;拼接，最后为\u0026quot;3000\u0026quot;。\n2.7 三目运算符 写法：\n条件? 表达式1: 表达式2;\r意思为如果条件为`true,返回表达1；否则返回表达式2。\n例如：\nx \u0026lt; y ? x : y;\r上方会得到x和y中较小的哪个。\n三、条件判断和循环分支 在命令式编程语言中，程序结构离不开条件判断和循环分支，又为流程控制。\n3.1 if、if-else语句 一种条件判断语句，一般是用变量通过相等性检测(==)，不相等性检测(!=)，甚至区间范围的检测(\u0026gt;,\u0026gt;=,\u0026lt;,\u0026lt;=)，来选择执行路径\nif语句，用法：\n// 1\rif (条件) {\r... 表达式;\r...\r}\rif语句圆括号中的条件，其实是表达式，它的结果必须式布尔类型，如果条件为真，花括号里面的表达式则会得到执行，否则不执行。\n例如：\nint x = 0;\rif(x == 0) {\rx = 100;\r}\rif-else语句，用法：\n// 1\rif (条件) {\r... 表达式;\r...\r} else {\r... 表达式;\r...\r}\r// 2\rif (条件1) {\r... 表达式;\r...\r} else if (条件2) {\r... 表达式;\r...\r} else if (条件3) {\r... 表达式;\r...\r} ... else if (条件n) {\r... 表达式;\r...\r} else {\r... 表达式;\r...\r}\r如果if的条件判断满足，执行if语句块；否则，执行else语句块。\n由于if-else语句中else里面是可以嵌套if-else语句。因此if-else语句非常擅长判断值是否在某个区间范围，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 随机获取0 ~ 100之间的随机数 int goal = (int)(Math.random()*(100+1)); if (goal \u0026gt;= 90 \u0026amp;\u0026amp; goal \u0026lt;= 100) { System.out.println(\u0026#34;优秀\u0026#34;); } else if (goal \u0026lt; 90) { System.out.println(\u0026#34;良好\u0026#34;); } else if (goal \u0026lt; 80) { System.out.println(\u0026#34;一般\u0026#34;); } else if (goal \u0026lt; 70) { System.out.println(\u0026#34;合格\u0026#34;); } else { System.out.println(\u0026#34;不合格\u0026#34;); }   System.out.println(...)这条语句是直接使用System内部的公共静态域，并调用它的普通成员方法，会在控制台打印内容。这里简单说一下静态方法的调用格式：类名.静态方法名(参数列表)，还有对于普通成员方法调用格式：对象名.成员方法名(参数列表)。System是java.lang包提供的类，out就是其内部有静态成员字段(或域)，println就是out的普通成员方法。使用静态方法和静态域，通常不需要自己创建对象，关联一个类就可以直接使用，但也可以关联对象来使用。在Java中方法是对象的成员，静态方法是类的成员。\n3.2 switch语句 switch语句也是条件判断语句，不过是通过变量与常量的相等检测来选择执行路径。与if相比，灵活性没那么高，适合变量变化小的条件判断。\n用法格式：\nswitch(变量) {\rcase 常量1: 表达式1或{语句块1};break;\rcase 常量2: 表达式2或{语句块2}:break;\r...\rcase 常量n: 表达式n或{语句块n};break;\rdefault: 表达式;break;\r}\rdefault是可选的，break也是不强制加的。若是变量匹配到某一个case中没有break，在这个case执行完后，不是结束switch语句，而是往下一个case中执行表达式或语句块，直到碰到第一个break才结束swith语句。如果忘记break，可能无意中执行下面几条case中的代码，这个非常要注意。switch圆括号里面可以放byte、short、int、String和枚举类型的变量。case中想要执行多条表达式，要用花括号{}括起来为一个语句块，才能执行多语句。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 随机生成1到12的值 int month = 1 + (int)(Math.random() * (13 - 1)); switch(month) { case 1: case 2: case 3: System.out.println(\u0026#34;是春天\u0026#34;); break; case 4: case 5: case 6: System.out.println(\u0026#34;是夏天\u0026#34;); break; case 7: case 8: case 9: System.out.println(\u0026#34;是秋天\u0026#34;); break; case 10: case 11: case 12:System.out.println(\u0026#34;是冬天\u0026#34;); break; default: System.out.println(\u0026#34;出错了\u0026#34;);break; }   3.3 while循环 先判断条件，再执行循环语句块，当循环条件不满足时，结束循环。\n用法格式：\nwhile (条件) {\r循环体; }\r例如：\n1 2 3 4 5  int i = 0; while (i \u0026lt; 6 ) { System.out.println(i+1); i++; }   3.4 do-while循环 先执行一次循环，后判断条件，满足条件接着循环，不满足就结束。\n用法格式：\ndo {\r循环体; } while (条件);\r例如：\n1 2 3 4 5  int j = 0; do { j = j + 2; } while (j % 3 != 0); System.out.println(j);   3.5 for循环 能够确定循环的次数的循环，通常用于遍历数组。\n用法格式：\nfor(初始化参数; 判断条件 ;更新循环变量){ 循环体; }\r例如：\n1 2 3 4 5 6  for (int i = 1; i \u0026lt; 10; i++) { for (int j = 1; j \u0026lt; 10; j++) { System.out.print(j+\u0026#34;×\u0026#34;+i+\u0026#34;=\u0026#34;+(j*i)+\u0026#34;\\t\u0026#34;); } System.out.println(); }   3.6 break与continue break之前用于跳出switch语句，它还可以跳出循环，甚至能跳出多重循环（在需要跳出的循环前的某个一个位置作标记,格式：标记名:，然后通过break 标记名;退出标记的一层或多层循环）；而continue是跳出当前循环，进行下一次的循环, 它也可以停止当前多层循环，进入下一次循环，不过比较少用（在需要的跳出循环前的某个一个位置作标记,格式：标记名:，然后通过continue 标记名;跳出标记的一层或多层循环，不过进入下一次循环）。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  outter: // 标记位置 while (true) { int i = 0; int j = (int)(Math.random() * (10)); while (i \u0026lt; 100) { i = i + 1; if (i == 40) { break; } if (i == 37) { /* 程序跳出最里面的循环， 跳到outter标记的循环， 重新进入下一次循环 */ continue outter; } if (j == 5) { // 完全跳出outter标记的循环  break outter; } i = i + 1; } }   四、接受输入 使用java.util包提供的Scanner类来接受用户从控制台传来的输入。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* 由于它来自java.util包需要手动导包 而java.lang包是默认导入的， 所以使用System.out.println的时候不用导包 */ Scanner input = new Scanner(System.in); String question; while (true) { question = input.nextLine(); question.replace(\u0026#34;吗\u0026#34;, \u0026#34;\u0026#34;); question.replace(\u0026#34;我\u0026#34;, \u0026#34;我也\u0026#34;); question.replace(\u0026#34;？\u0026#34;, \u0026#34;!\u0026#34;); System.out.println(question); }   Scanner有nextLine()方法读取一行输入。它还可以格式化输入，比如读取一个整数可以使用nextInt()，读取一个浮点数可以使用nextDouble()等。\n要读取什么基本数据类型的数据，在next后面加对应的单词即可。next()方法是读取不包含空白字符的一串文字，如果一开始输入空格、回车、tab这些空白字符输入，这个方法是略过的这些字符的，继续等待输入，当我们输入非空白字符的一串文字后再输入空白字符才会结束输入。千万记住如果nextLine()方法，就不能使用next()及其格式化输入的方法，如：nextInt()、nextDouble()等。\n如果先使用next()，后用nextLine()，nextLine()是接受不了任何输入。因为如果在之前的next()输入回车结束此次输入，换行符没有被读到还会在缓冲区，此时调用nextLine()，会接受缓冲区这个换行符，结束输入，所以nextLine()就没有作用。\n五、数组 数组是相同类型数据的集合，它存储多个相同类型的数据，不过它的容量是固定的，一旦创建，长度就不能修改。\n5.1 定义格式 有四种定义格式，在定义处初始化的数组有3种方式，还一种不在定义处初始化。\n在定义处初始化：\n// 1. 常见的初始化格式，并填充了数组的内容\r数据类型[] a = { 元素1, 元素2, ..., 元素n }; // 2. 不常见的初始化格式，并填充了数组的内容\r数据类型[] a = new 数据类型[]{ 元素1, 元素2, ..., 元素n }; // 3. 常见的初始化格式，但每填充了数组的内容\r数据类型[] a = new 数据类型[数组长度]; 不在定义处初始化：\n数据类型[] a; // 4. 创建了数组的引用，但没有在内存分配数组空间\r5.2 下标 数组a的下标范围是0到a.length-1(数组有一个成员变量length表示数组长度)。通过下标i，我们可以从数组a中取出元素，在数组变量名后加上方括号，括号里有下标，就取出该下标的元素。即a[i]。数组里的元素是可以修改的，如：a[i] = 数据内容;\n1 2 3  int[] a = { 1, 3, 5, 7, 9}; System.out.println(a[2]); // 取下标2的数组元素，这里是5 a[2] = 0;// 修改下标2的数组元素，这里修改为0   5.2 求数组中最值 假设有个数组A，其长度为N，数组中的元素是可以比较大小的，即可以使用大于号，小于号，大于等于号，小于等于号这些运算符进行操作。\n因为只有数据类型是可以比较出大小，数组求最大值和最小值才有意义。\n求数组最大值的算法，伪代码如下:\nmax(A, N):\ri ← 1\rmax ← 0\rwhile i \u0026lt; N\rif (A[i] \u0026gt; A[max])\rmax ← i\ri ← i + 1\rreturn A[i]\r求数组最小值的算法，伪代码如下：\nmin(A, N):\ri ← 1\rmin ← 0\rwhile i \u0026lt; N\rif (A[i] \u0026lt; A[min])\rmin ← i\ri ← i + 1\rreturn A[i]\rjava中完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class Demo { // 求数组最大值  public static int max(int[] a) { int max = 0; for (int i = 1; i \u0026lt; a.length; i++) { max = a[max] \u0026lt; a[i] ? i : max; } return a[max]; } // 求数组最小值  public static int min(int a) { int min = 0; for (int i = 1; i \u0026lt; a.length; i++) { min = a[min] \u0026gt; a[i] ? i : min; } return a[min] } }   求其他类型数组的最值算法类似上面的算法，只不过是更换类型罢了\n5.3 冒泡排序 升序的冒泡排序，操作的过程如下：\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class BubbleSort { public static void sort(int[] a) { int n = a.length; for (int i=0; i\u0026lt;n-1; i++) { for (int j=0; j\u0026lt;n-i-1; j++) { if (a[j] \u0026gt; a[j+1]) { int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } }   降序的排序与升序的算法类型，只要把循环中的比较大小的条件调反即可。\n5.4 二分查找 二分查找算法：\n要查找的目标元素为target，数组元素已经升序排序。\n如果数组序列长度为1，此数组的元素等于target，找到并返回下标;否则,未找到并返回-1；\n如果数组序列长度大于1，数组的中间元素为mid：\n如果target小于mid，将数组序列一分为二，对数组前半部分的序列进行二分查找算法；\n如果target大于mid，将数组序列一分为二，对数组后半部分的序列进行二分查找算法；\n如果target等于mid，找到找到并返回下标mid;\n递归版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class BinarySearch { public static int search(int[] a, int target) { if (a == null || a.length == 0) { return -1; } return search(a, target, 0, a.length-1); } private static int search(int[] a, int target, int lo, int hi) { if (hi == lo) { if (a[lo] == target) { return lo; } else { return -1; } } int mid = lo + ((hi - lo)\u0026gt;\u0026gt;1); if (target \u0026lt; a[mid]) { return search(a, target, lo, mid-1); } else if (target \u0026gt; a[mid]) { return search(a, target, mid+1, hi); } else { return mid; } } }   迭代版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class BinarySearch { public static int search(int[] a, int target) { int lo = 0, hi = a.length-1; int mid; while (lo \u0026lt;= hi) { mid = lo + ((hi-lo)\u0026gt;\u0026gt;1); if (target \u0026gt; a[mid]) { hi = mid - 1; } else if (target \u0026lt; a[mid]) { lo = mid + 1; } else { return mid; } } return -1; } }   对降序排序的数组，进行的二分查找的算法与上面算法类似，把target与数组比较的大于号换成小于号，把小于号换成大于号即可。\n5.5 多维数组 常见的多维数组是二维数组，二维数组本质是数组的数组。由于二维以上的数组，内部嵌套的数组层数过多，导致数组结构过于复杂且使用效率低下，不常使用。\n不规则二维数组的的创建格式：\n数据类型[][] a = new 数据类型[数组长度][];\rfor (int j=0; j\u0026lt;a.length; j++) {\ra[j] = new 数据类型[一维数组长度]; // 一维数组的长度未定，根据需要定多长\r}\r规则二维数组,可以当作矩阵，其创建格式：\n数据类型[][] a = new 数据类型[行长][列长];\r二维数组的初始化\n1 2 3 4 5  for (int i=0; i\u0026lt;a.length; i++) { for (int j=0;j\u0026lt;a[i].length; j++) { a[i][j] = 0; } }   ","description":"本文介绍Java中8种基本数据类型，操作符有哪些，通过循环分支可以写出具有逻辑的语句，最后定义和使用数组。","id":29,"section":"posts","tags":["基础语法"],"title":"Java基础语法","uri":"https://qinry.github.io/posts/2021/01/java-basic-grammar/"},{"content":"一、环境搭建 开发Java工程离不开JDK（Java Development Kit Java开发工具包），这个是最基本的必须下载和安装，还有为了方便开发者编写、运行和调试程序出现了IDE（Integrated Development Environment 集成开发环境）。\n用于开发Java程序的IDE有很多，其中知名有开源的eclipse，还有别的IDE，如：Intellij IDEA，由于是商业软件，需要收费。下面主要说明JDK与eclipse的安装(Windows10来说明)。\n1.1 JDK的安装 1.1.1 下载JDK 官网地址：https://www.oracle.com，下载操作如下一系列图所示\n 进入官网，点击Products进入下一步   点击Java，进入下一步   下拉到Java，点击Oracle JDK 进入下一步   选择JDK的版本，选择Java SE 11(LTS) ，点击JDK Download并进入下一步   找到适合的JDK安装包，点击下载   下载前需要登入Oracle账号，有账号登入即可，没有可以申请。申请遇到问题，可以上百度寻求答案  1.1.2 安装JDK  双击运行jdk-11.0.9_windows-x64_bin.exe   连续点击默认的下一步即可   最后安装完成，点击关闭  1.2 eclipse的安装 1.2.1 下载eclipse 官网地址：http://www.eclipse.org\n 进入官网，点击Download   点击Download Packages，进入下一步   选择安装压缩包，进入下一步   点击Download，下载   之后会出现donate页面，有能力的可以捐献，没有的默默点击关闭吧！  1.2.2 安装eclipse  解压压缩包eclipse-jee-2020-12-R-win32-x86_64.zip到任何喜欢的目录即可，这里我选择在用户的目录    为eclipse.exe创建桌面快捷方式或着固定到任务栏，方便我们打开eclipse\n  打开eclipse\n  1.3 配置环境变量 在windows10中，右键此电脑点击属性，点击高级系统设置，点击环境变量，创建环境变量JAVA_HOME，设置为JDK的家目录\n再设置变量PATH，在原有变量值的基础上追加英文分号;，还有%JAVA_HOME%/bin即可，后面全部确定完成环境变量的配置。\n为什们配置JAVA_HOME?\n因为变量PATH系统帮我们创建好的，它的值关联到系统中其他命令的工作，修改可能会影响它们的工作，所以我们应该避免频繁的修改。如果创建了JAVA_HOME变量，只需将PATH追加一次%JAVA_HOME%/bin，以后需要切换JDK版本，只改JAVA_HOME就可以，避免修改PATH可能带来的风险。\n1.4 创建Java工程 1.4.1 HelloWorld工程 点击菜单 File，拉到new中的project并点击\n选择Java Project，点Next\n项目命名HelloWorld，JRE选择Use a project specific JRE的jdk-11.0.9，最后点Finish\n点Don’tCreate\n在HelloWorld项目下右键New-\u0026gt;Class，完成源文件创建\n编写第一个Java程序并运行\nJava源文件名与public类名是一致的，main方法是程序启动的入口，没有main方法Java程序是无法运行的\nJava语法中分有结构定义语句和逻辑功能语句（class关键字紧跟着后面的花括号内的就是结构定义语句所在的区域，方法的花括号内是逻辑功能语句所在区域）\n可以在编辑区右键在Run As中点击1 Java Application运行或在工具栏点击运行结果如下：\n1.4.2 自动关机程序 在eclipse中语句下存在红色波浪线，说明存在异常，鼠标在语句停留几秒会出现处理的建议，这里我们抛出异常，加入异常说明即可，将异常处理交给JVM\n正确代码如下：\n1 2 3 4 5 6 7 8 9 10 11  package io.github.qinry import java.io.IOException; public class HelloWorld { public static void main(String[] args) throws IOException { // System.out.println(\u0026#34;Hello World\u0026#34;);  Runtime.getRuntime().exec(\u0026#34;shutdown -s -t 6000\u0026#34;); // Runtime.getRuntime().exec(\u0026#34;shutdown -a\u0026#34;);  } }   获取Runtime实例，允许Java程序与运行程序环境进行交互，可以执行cmd命令，关机名命令为shutdown -s -t [时间/秒]\n取消关机命令为shutdown -a\n自动关机和取消关机执行结果如下：\n二、介绍 2.1 Java重要发展历程 1991.04 —— Java的前身Oak，最初开发一种能够在各种消费性电子产品上运行的程序架构\n1995.05 —— Sun将Oak更名为Java，在SunWorld大会上正式发布Java 1.0，提出\u0026quot;Write Once, Run Anywhere\u0026quot;的口号\n1996.01 —— JDK1.0发布，技术代表有JVM、applet、AWT等\n1997.02 —— JDK1.1技术代表有JAR文件格式、JDBC、JavaBeans、RMI等，内部类和反射的出现\n1998.12 —— JDK1.2将技术体系拆分为面向桌面的J2SE、面向企业的J2EE、面向移动端的J2ME\n1999.04 —— HotSpot VM诞生\n2004.09 —— JDK5发布，增添了自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环等，而且提供JUC并法包\n2009.04 —— Oracle收购Sun\n2013.09 —— JDK8发布，增加了Lambda表达式的支持，拥有函数式表达能力，更新了时间和日期的API，目前企业当中使用比较多的版本\n2018.09 —— JDK11发布，是最新的LTS版本的JDK\n2.2 Java技术体系 组成部分：\n  Java程序设计语言\n  各大硬件平台的JVM实现\n  Class文件格式\n  Java类库API\n  一些概念的解释：\n  JDK —— Java开发工具集，包含了Java程序设计语言、Java虚拟机、Java类库\n  JRE —— Java 运行时环境，包含了Java虚拟机、和Java类库API中的JavaSE API子集\n  JVM —— Java虚拟机，一个可以执行Java字节码的虚拟计算机系统，有解释器组件帮助Java字节码与操作系统的交互，不同平台，它的实现不同，而且屏蔽底层运行平台的差别，实现跨平台。\n  2.3 Java特点  跨平台 由于虚拟机的存在，不同平台实现有所不同，屏蔽了底层运行差别，能够”一次编写，随处运行“ 健壮性 有异常处理机制，能处理错误与异常的输入和操作 安全性 有垃圾回收机制、引用代替指针（可以简单理解引用是智能指针），所以程序员不需要手动释放垃圾内存，大大减少了内存泄漏的风险 面向对象 Java是纯面向对象的编程语言，在Java中一切都是对象  2.4 GC   不再使用的内存空间应当进行回收-垃圾回收。\n  在 C/C++等语言中，由程序员负责回收无用内存。\n  Java 语言消除了程序员回收无用内存空间的责任：\n  JVM 提供了一种系统线程跟踪存储空间的分配情况。并在 JVM 的空闲时，检查并释放那些可以被释放的存储空间。\n  垃圾回收器在 Java 程序运行过程中自动启用，程序员无法精确控制和干预\n  ","description":"本文介绍Java在Windows10中开发环境如何搭建，以及创建第一个Java工程，如何实现自动关机，最后讲讲Java语言概念特性及技术体系","id":30,"section":"posts","tags":null,"title":"Java开发环境搭建与介绍","uri":"https://qinry.github.io/posts/2021/01/java-setup-development-environment/"},{"content":"一、什么是单件模式 单件模式是在设计模式中常用的一种需要为类只实例化唯一对象的设计方案。意思是说，对于某个类来说，其对象只能创建一个，且每次使用这个类的时候，用到的都是同一个对象。在有些场景下，有些对象我们只需要一个，比如：线程池、缓存、对话框、处理偏好设置和注册表的对象、日志对象、打印机、显卡等表示设备某些资源的对象。也常常用来管理共享的资源，比如数据库连接池等。\n看看单件模式的官方定义：单件模式 确保一个类只有一个实例，并提供一个全局访问点。\n二、单件模式的优点 单件模式除了可以确保只有一个实例会被创建，还提供与全局变量一样方便的访问。全局变量，它可能必须在程序一开始就要创建好，如果这个对象很耗资源，而程序偏偏没有使用到它，这对资源就是一种实实在在的浪费，所以应该在需要时才被创建就可以解决这个问题，正好单件模式能够做到。\n三、如何做到只实例化和管理唯一的对象 在Java中通过new表达式公开创建对象，我们必须隐藏这个创建动作，只能由类自己进行，对外禁止使用new。那么客户如何获得对象呢？\n首先类内管理一个私有成员实例变量，这成员类型就是本身，由于要求对象唯一，声明为static变量，再可以通过一个公共静态方法，叫getInstance()好了，向类发出请求访问并获得这个实例变量即可。为什么要用静态方法？\n避免外部显式直接获取对象导致硬编码。还有获取对象的构造器对外是严令禁止，实例方法无法使用，借助类方法（或者叫静态方法）不用实例化就可以直接使用的方法获得对象。对象的创建其实就封装在这个静态方法getInstance()。\n如果通过条件判断实例变量是否为空，为空则创建对象再返回；不为空直接返回对象。这种在需要时创建的对象叫做延迟实例化。\n1 2 3 4 5 6 7 8 9 10  public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public static getInstance() { if(uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } }   3.1 需要注意的问题 在使用单件模式需要考虑多线程多次调用getInstance()方法获取对象可能导致创建对象不唯一的问题，那这还算单件吗？就如同前面的代码就是线程不安全的单件，如果有两个线程同时交替执行通过了if(uniqueInstance == null)语句,接下来就会导致new使用了两次，实例化了两个不同的对象。\n3.2 使用synchronized方法解决 将getInstance()方法声明为synchronized，给这个方法加了锁，确保只有一个线程访问这个方法。虽然解决了线程安全问题，但是执行效率下去了，因为只有第一次调用getInstance()才需要同步，之后的同步是累赘，拖慢程序。\n1 2 3 4 5 6 7 8 9 10  public class Singleton { private static Singleton uniqueInstance; private Singleton() {} public synchronized static getInstance() { if(uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } }   不考虑性能时，synchronized方法解决最直接。\n3.3 去延迟实例化而急切实例化解决 在静态初始化器中创建单件，保证线程安全，getInstance()也不用声明synchronized直接返回实例变量即可。JVM保证任何线程在访问getIntance()方法之前，创建单件实例。\n1 2 3 4 5 6 7  public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() {} public static getInstance() { return uniqueInstance; } }   解决线程不安全单件的一种可行方案。如果创建的对象小巧不太耗资源可以考虑使用这个方案。\n3.4 使用双重检查加锁解决 利用双重检查加锁(double-checked locking)，可以减少同步，首先检查是否实例化，如果还没有，才进行同步，这样只有第一次调用getInstance()同步，后面直接返回对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Singleton { private static volatile Singleton uniqueInstance; private Singleton() {} public static getInstance() { if(uniqueInstance == null) { synchronized(Singleton.class) { if(uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } }   使用双重检查加锁是在考虑性能因素时解决线程不安全的单件的最优方案，不过如果某些原因使用旧版Java（1.4以前版本）就不支持这个方案，这要求Java5及其以后的版本才能正确执行。现在都2020年了，基本上用的都是Java8及其以后的版本。\n四、小结 单例模式确保程序中一个类最多只有一个实例；单件提供全局访问点。实现该模式，需要私有构造器，一个静态方法和一个静态变量。确定性能和资源上的限制，然后小心选择适当的方案实现单件，以解决多线程问题（同步方法，急切实例化，双检测加锁）。如果使用多个类加载器可能导致单件失效，所以要指定一个类加载器。\n参考  Head First 设计模式（中文版）  ","description":"快速开始单件模式","id":31,"section":"posts","tags":null,"title":"快速开始单件模式","uri":"https://qinry.github.io/posts/2020/11/designpatterns-singleton/"},{"content":"Java I/O库提供压缩功能输入、输出流，这些类是按字节方式处理，常用的压缩类有DeflaterOutputStream和它的子类ZipOutputStream、GZIPOutputStream、CheckedOutputStream，这些是用于压缩的，相应地，有解压的的InflaterInputStream和它的子类ZipInputStrea、GZIPInputStream、CheckedInputStream。\n对单个数据流进行压缩 GZIP接口简单，一般用于单个数据流的压缩,用例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import java.util.zip.*; // 导入压缩格式的数据流类 import java.io.*; public class GZIPcompress { public static void main(String[] args) throws IOException { if(args.length == 0) { System.out.println( \u0026#34;Usage: \\nGZIPcompress file\\n\u0026#34; + \u0026#34;\\tUses GZIP compression to compress \u0026#34; + \u0026#34;the file to test.gz\u0026#34;); System.exit(1); } // 读取要压缩的文件数据  BufferedReader in = new BufferedReader( new FileReader(args[0])); // 创建压缩文件  BufferedOutputStream out = new BufferedOutputStream( new GZIPOutputStream( new FileOutputStream(\u0026#34;test.gz\u0026#34;))); System.out.println(\u0026#34;Writing file\u0026#34;); int c; while((c = in.read()) != -1) out.write(c); in.close(); out.close(); System.out.println(\u0026#34;Reading file\u0026#34;); BufferedReader in2 = new BufferedReader( new InputStreamReader(new GZIPInputStream( new FileInputStream(\u0026#34;test.gz\u0026#34;)))); String s; while((s = in2.readLine()) != null) System.out.println(s); } }   GZIPOutputStream的构造器的参数类型是FileOutputStream，还可用BufferedOutputStream类包装。GZIPOutputStream的构造器只能接受OutputStream对象，不接受Writer对象。打开文件时,GZIPInputStream会转换为Reader。\n多文件压缩保存 Java压缩库使用标准的zip格式，用Checksum类进行计算和校验文件的校验和(Adler32和CRC32两种格式，前者速度快，后者慢但准确)。用例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  import java.util.zip.*; import java.io.*; import java.util.*; public class ZipCompress { public static void main(String[] args) { // 压缩:  //1 创建压缩输出流，输出流套四层 T_T  FileOutputStream f = new FileOutputStream(\u0026#34;test.zip\u0026#34;); CheckedOutputStream csum = new CheckedOutputStream(f, new Adler32()) ZipOutputStream zos = new ZipOutputStream(csum); BufferedOutputStream out = new BufferedOutputStream(zos); // 为文件设置注释  zos.setComment(\u0026#34;测试Java压缩文件\u0026#34;); int ch; BufferedReader in = new BufferedReader(new FileReader(\u0026#34;a.txt\u0026#34;)); //2 压缩条目添加到压缩输出流  zos.putNextEntry(new ZipEntry(\u0026#34;a.txt\u0026#34;)); //3 往缓冲输出流写入压缩文件数据  while((ch = in.read()) != -1) { out.write(ch); } in.close(); out.flush(); // 注意读完一个文件刷新缓冲区  //4 重复2，3步骤，添加第二个文件，如果压缩更多文件采用循环  in = new BufferedReader(new FileReader(\u0026#34;b.txt\u0026#34;)); //2 压缩条目添加到压缩输出流  zos.putNextEntry(new ZipEntry(\u0026#34;b.txt\u0026#34;)); //3 往缓冲输出流写入压缩文件数据  while((ch = in.read()) != -1) { out.write(ch); } in.close(); out.flush(); out.close(); // 读取压缩文件  //1 创建解压缩输入流，又套四层 T_T  FileInputStream fi = new FileInputStream(\u0026#34;test.zip\u0026#34;); CheckedInputStream csumi = new CheckedInputStream(f, new Adler32()) ZipInputStream zi = new ZipInputStream(csum); BufferedInputStream bis = new BufferedInputStream(zos); ZipEntry ze; while((ze = zi.getNextEntry()) != null) { System.out.println(\u0026#34;File: \u0026#34; + ze); while((ch = bis.read()) != -1) System.out.write(ch); } bis.close(); /* 另一种读取压缩文件 ZipFile zf = new ZipFile(\u0026#34;test.zip\u0026#34;); Enumeration e = zf.entries(); while(e.hasMoreElement()) { ZipEntry ze2 = (ZipEntry)e.nextElement(); System.out.println(\u0026#34;File: \u0026#34; + ze2); while((ch = bis.read()) != -1) System.out.write(ch); } */ } }   jar工具打包和解压 Java项目常常要打包成文件名后缀为.jar的压缩格式，类似于zip格式。\njar常用命令:\n1.类文件简单打包\n1  jar cf myJar.jar *.class   2.类文件，用户自建清单文件打包\n1  jar cfm myJar.jar *.class MANIFEST.MF   3.多目录打包\n1  jar cf myApp.jar audio classes image   4.jar文件解压\n1  jar xf myApp.jar   ","description":"压缩和解压文件的IO","id":32,"section":"posts","tags":["jar","zip","io"],"title":"Java 压缩文件的IO流","uri":"https://qinry.github.io/posts/2020/04/java-zip/"},{"content":"一、递归的含义 递归就是函数或方法通过调用自己本身来达到解决问题的目的，这种解法形式叫递归。用欧几里得算法的 Java 描述说明问题：\n任意一对非负整数 p，q（p \u0026gt; q），设 r 是 p 与 q 相除的余数。p，q 的最大公约数等于 q，r 的最大公约数。\n1 2 3 4 5  public static int gcd(int p, int q) { if(q == 0) return p; int r = p % q; return gcd(q, r); }   二、为什么使用递归   面对某些复杂的问题使用递归可以很好的描述并有效解决，例如汉诺塔问题、二叉树的遍历、查询目录等等。\n  递归使算法实现的代码更加简洁，而且可能更加易懂。\n  当递归使用的是尾递归本质其是就是迭代，效率不亚于普通迭代(不考虑函数的开销，递归比迭代更好)。如果使用使用双递归、三递归等等，才会是算法极度低效的反例\r 三、如何使用递归 使用数学归纳法诠释重要三点：\n  递归总有一个最简单的情况：方法的第一句总是包含return的条件语句\n  递归调用总是尝试解决一个规模更小的子问题，递归才能收敛到最简单的情况。\n  递归调用的父问题和尝试解决的子问题之间不应该有交集。\n  四、一些递归的例子 4.1 阶乘 1 2 3 4  public static int fact(int N) { if(N == 0) return 1; return N * fact(N - 1); }   典型的尾递归，效率最高的递归形式\n4.2 斐波那契数列 1 2 3 4 5  public static int fibonacci(int N) { if(N == 0) return 0; if(N == 1) return 1; return fibonacci(N - 2) + fibonacci(N - 1); }   典型的双递归，子问题有重复了工作，问题有交集，故效率低于迭代形式\n迭代如下：\n1 2 3 4 5 6 7 8 9 10  public static int fibonacci(int N) { int n_2 = 0, n_1 = 1; int temp; for(int i = 0; i \u0026lt; N; i++) { temp = n_2 + n_1; n_2 = n_1; n_1 = temp; } return n_2; }   4.3 幂运算 底数，指数为非负整数的幂运算\n1 2 3 4 5 6 7 8 9  public static int pow(int X, int N) { if(N == 0) return 1; if(N == 1) return X; if(N % 2 == 0) return pow(X*X, N/2); else return pow(X*X, N/2) * X; }   根据条件分路解决规模更小子问题，递归调用次数随N递减不呈指数增长,而是线性增长,也是尾递归。\n参考  维基百科-辗转相除法(https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95#%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E8%AF%81%E6%98%8E)  ","description":"简简单单知道递归","id":33,"section":"posts","tags":["递归"],"title":"简简单单知道递归","uri":"https://qinry.github.io/posts/2020/04/algorithm-recursion/"},{"content":"配置Git 提供Git用户名和邮箱\n1 2  git config --global user.name \u0026#34;username\u0026#34; git config --global user.email \u0026#34;usernaem@example.com\u0026#34;   忽略文件 创建文件 .gitignore ，让Git忽略某目录中的所有文件(不跟踪这些文件)，使用它可以避免项目混乱\n初始化仓库 1  git init   仓库是程序中被Git主动跟踪的一组文件。Git用来管理仓库的文件都存储在隐藏的.git/中，你根本不需要与这个目录打交道，但千万不要删除这个目录，否则将丢弃项目的所有历史记录。\n检查状态 1  git status   在Git中，分支 是项目的一个版本。提交 是项目在特定时间点的快照。\n文件添加到仓库 1  git add \u0026lt;file\u0026gt;|\u0026lt;path\u0026gt;   只是让Git开始关注指定文件或目录中的文件。但未提交。\n执行提交 1  git commit -m \u0026lt;message\u0026gt;   标志-m 让Git将接下来的消息记录到项目的历史记录中\n1  git commit -am \u0026lt;message\u0026gt;   标志 -am 中 a 让 Git 将仓库中所有修改了的文件都加入到当前提交中，m 同上是提交记录信息\n保证最后的工作目录是干净的，否则很有可能忘记添加文件\n查看提交历史 1  git log   每次提交时，Git 都会生成一个包含40字符的独一无二的引用ID。它记录提交是谁执行的、提交的时间以及提交时指定的消息。并非在任何情况下你都需要所有这些信息，因此\nGit提供了一个选项，让你能够打印提交历史条目的更简单的版本：\n1  git log --pretty=oneline   将显示提交的引用ID及提交记录的信息\n撤销修改 1  git checkout --\u0026lt;file\u0026gt;   命令 git checkout 让你能够恢复到以前的任何提交。命令 git checkout . 放弃自最后一次提交后所做的所有修改，将项目恢复到最后一次提交的状态。\n检出以前的提交 1  git checkout \u0026lt;id\u0026gt;|master   可以检出提交历史中的任何提交，而不仅仅是最后一次提交，为此可在命令 git checkout 末尾指定该提交的引用ID的前6个字符（而不是句点）。还可以从之前的提交回到 master\n除非你要使用Git的高级功能，否则在检出以前的提交后，最好不要对项目做任何修改。\n1  git reset --hard \u0026lt;id\u0026gt;   永久地恢复到引用ID是此前6个字符的提交。\n删除仓库 mac/linux\n1  rm -rf .git   window\n1  rmdir /s .git   仓库的历史记录被你搞乱了，而你又不知道如何恢复。如果无法恢复且参与项目开发的只有一个人，可继续使用这些文件，但要将项目的历史记录删除——删除目录.git。这不会影响任何文件的当前状态，而只会删除所有的提交。\n","description":"介绍Git的简单入门的操作，学会如何配置Git的用户名和邮箱，创建Git仓库，代码添加并提交Git仓库，撤销修改和删除Git仓库等。","id":34,"section":"posts","tags":null,"title":"git入门使用","uri":"https://qinry.github.io/posts/2019/10/git-simple-usage/"}]