<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on 欢迎来到槎城小子的博客！</title>
    <link>https://qinry.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on 欢迎来到槎城小子的博客！</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 31 Jan 2021 22:14:45 +0800</lastBuildDate><atom:link href="https://qinry.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>链表</title>
      <link>https://qinry.github.io/posts/2021/01/algorithm-list/</link>
      <pubDate>Sun, 31 Jan 2021 22:14:45 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2021/01/algorithm-list/</guid>
      <description>一、数组与链表 链表 [Linked List]：链表是由一组不必相连（不必相连：可以连续也可以不连续）的内 存结构（节点），按特定的顺序链接在一起的抽象数据类</description>
    </item>
    
    <item>
      <title>优先队列的实现</title>
      <link>https://qinry.github.io/posts/2020/08/algorithm-priority-queue/</link>
      <pubDate>Thu, 06 Aug 2020 21:36:55 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020/08/algorithm-priority-queue/</guid>
      <description>最大优先队列 API: public class MaxPQ&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;&amp;gt; 方法 功能描述 MaxPQ(int max) 创建一个初始容量为max的优先队列 void insert(Key x) 向优先队列插入一个元素 Key delMax() 删除最大元素并返回最大元素 boolean isEmpty() 返回</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://qinry.github.io/posts/2020/08/algorithm-sort/</link>
      <pubDate>Thu, 06 Aug 2020 08:00:11 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020/08/algorithm-sort/</guid>
      <description>排序算法类的模板 public class Example { public static void sort(Comparable[] a){ // ... 见下面详解 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &amp;lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i];a[i] = a[j];a[j] = t; } private static void show(Comparable[] a) { for(int i = 0; i &amp;lt; a.length;</description>
    </item>
    
    <item>
      <title>并查集的实现</title>
      <link>https://qinry.github.io/posts/2020/07/algorithm-union-find/</link>
      <pubDate>Mon, 06 Jul 2020 07:34:59 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020/07/algorithm-union-find/</guid>
      <description>问题描述：输入一对整数p、q，程序判断它们是否相连，如果相连，忽略这对数并处理下对数；否则将它们相连。p和q相连具有一种等价关系,说明： p和</description>
    </item>
    
    <item>
      <title>背包、栈、队列实现</title>
      <link>https://qinry.github.io/posts/2020/05/algorithm-basic-datastructure/</link>
      <pubDate>Wed, 06 May 2020 08:24:50 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020/05/algorithm-basic-datastructure/</guid>
      <description>API: 背包 public class Bag&amp;lt;Item&amp;gt; implements Iterable&amp;lt;Item&amp;gt; 方法 功能描述 Bag() 创建一个空包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 先进先出队列(FIFO) public class Queue&amp;lt;Item&amp;gt; implements Iterable&amp;lt;Item&amp;gt; 方法 功能描</description>
    </item>
    
    <item>
      <title>简简单单知道递归</title>
      <link>https://qinry.github.io/posts/2020/04/algorithm-recursion/</link>
      <pubDate>Mon, 27 Apr 2020 20:21:23 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2020/04/algorithm-recursion/</guid>
      <description>递归的含义 递归就是函数或方法通过调用自己本身来达到解决问题的目的，这种解法形式叫递归。用欧几里得算法的Java描述说明问题： 任意一对非负整数</description>
    </item>
    
    <item>
      <title>数据结构与算法分析(笔记) -- 开始</title>
      <link>https://qinry.github.io/posts/2019/10/algorithm-beginning/</link>
      <pubDate>Thu, 17 Oct 2019 23:29:10 +0800</pubDate>
      
      <guid>https://qinry.github.io/posts/2019/10/algorithm-beginning/</guid>
      <description>递归使用的基本法则 基准情形：要有退出条件 不断推进：从初始条件趋向退出条件 设计准则 ：假设递归准确执行 合成效益法则：防止重复工作，比如生成斐波那</description>
    </item>
    
  </channel>
</rss>
