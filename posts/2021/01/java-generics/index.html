<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>泛型 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="泛型类，泛型接口，泛型方法，泛型通配符以及类型擦除" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    
<aside class="post-toc right-0" style="position:fixed;top: 20px;">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#理解泛型">理解泛型</a></li>
    <li><a href="#使用泛型">使用泛型</a></li>
  </ul>
</nav>
        
</aside>


    <main class="content container">
    <div class="post">

  <h1>泛型</h1>
  <span class="post-date">
    2021-01-31 17:09 &nbsp;
    字数：<strong>1435</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/java/">Java</a>&nbsp;
  </span>

  <h2 id="理解泛型">理解泛型</h2>
<p>泛型是将类型参数化，类定义时一些成员变量和一些方法形式参数的类型成为变量，在使用时再传入一个具体类型，进一步抽象了变量的类型。好像是给方法或类写了一个模板，根据模板赋予不同的类型参数，就会生成不同的类。将那些类似方法或类都集中在一起编写，也就是将相同的部分都封装起来，不同的部分参数化。某种程度，减少编写只因类型不同，逻辑大部分相同的多个类的代码量，使这部分代码耦合度降低，提高了代码的复用率。在Java中的泛型使用时指定类型但不需要强制类型转换，不必担心，类型是安全的，编译器会检查。</p>
<h2 id="使用泛型">使用泛型</h2>
<h3 id="泛型类">泛型类</h3>
<p>定义泛型类：</p>
<pre><code>public class Stack&lt;E&gt; implements Iterable {
    private Node first;
    private class Node {
 		private E element;
  		private Node next;
  		public Node(E e) {
        	this.element = e;
        	next = null;
  		}
    	public Node(Node x) {
    		element = x.element;
  			if (x.next != null) {
     			next = new Node(x.next);
    		}
  		}
	}
    // 其他方法省略
}
</code></pre><p>创建泛型类的对象：</p>
<pre><code>Stack stack = new Stack&lt;String&gt;();
</code></pre><p>成员内部类是可以使用外部类的类型参数，静态内部类却不能。</p>
<h3 id="泛型接口">泛型接口</h3>
<p>定义泛型接口：</p>
<pre><code>interface Callable&lt;V&gt; {
    V call() throws Exception;
}
</code></pre><p>实现泛型接口，指定类型：</p>
<pre><code>class StringCaller implements Callable&lt;String&gt; {
   @Override
   public String call() {
       return &quot;String&quot;;
   }
}
</code></pre><p>实现泛型接口，不指定类型：</p>
<pre><code>class Caller&lt;V&gt; implements Callable&lt;V&gt; {
    private V val;
    public V call() {
        return val;
    }
    public void setVal(V val) {
        this.val = val;
    }
}
</code></pre><h3 id="泛型方法">泛型方法</h3>
<p>一个普通类的方法可以使用泛型。形式大致：</p>
<pre><code>权限修饰符 &lt;T&gt; T 方法名(T a, T b) {}
</code></pre><p>非静态方法：</p>
<pre><code>class GenericMethod {
    public &lt;T&gt; void f(T t) {
        System.out.println(t.getClass().getName());
    }
}
</code></pre><p>静态方法：</p>
<p>例如：</p>
<pre><code>import java.lang.reflect.*;
import java.util.regex.*;
class StaticGenericMethod&lt;T&gt; {
    public static &lt;T&gt; void f(T t) {
        Pattern p = Pattern.compile(&quot;\\w+\\.&quot;);
        for(Method m : t.getClass().getMethods())
            System.out.println(
                p.matcher(
                    m.toString()).replaceAll(&quot;&quot;));
    }
}
</code></pre><p>由于static方法无法访问泛型类的类型参数，static的泛型方法必须在返回值类型前加上<code>&amp;lt;类型参数&amp;gt;</code>这个类型参数的声明。非静态方法如果是在泛型类内部，其实已经隐含了声明，所以不用特别写出来，但如果是普通类中，一定要写。</p>
<h3 id="泛型限制类型">泛型限制类型</h3>
<p>在使用泛型时， 可以指定泛型的限定区域 ，</p>
<ul>
<li>例如： 必须是某某类的子类或 某某接口的实现类，格式：</li>
</ul>
<pre><code>&lt;T extends 类或接口1 &amp; 接口2&gt; 
</code></pre><h3 id="泛型的通配符">泛型的通配符</h3>
<pre><code>public class Demo {
   public static void main(String[] args) {
       ArrayList&lt;Fruit&gt; fruits = new ArrayList&lt;Apple&gt;();
   }
}
class Fruit {}
class Apple extends Fruit {}
</code></pre><p>上面的main方法，编译器是无法通过运行的。不同于方法的多态，是可以传入变量参数时，实际参数时可以为形参的子类。但泛型的使用不允许这么做，这里可以理解，类型ArrayList&lt;Fruit&gt;和ArrayList&lt;Apple&gt;是完全不同的类型，之间更没父子关系。Java为了更好的使用泛型，提出了泛型的通配符。</p>
<p>类型通配符是使用？代替方法具体的类型实参。</p>
<p>无界通配符&lt;?&gt;表示某种特定类型，创建对象时传入的类型参数可以是任意类型，对象一旦传入创建好了，类型就确定，它方法使用类型参数也就跟着确定了。与&lt;Object&gt;是不同的意思，类型参数确定为Object，只不过使用这个类型参数的方法是可以传入任何类型的变量（因为Object是所有类共同的基类，Java是走单继承体系的）;</p>
<p>超类通配符&lt;? super T&gt;或&lt;? super 具体类&gt;,由T或具体类的基类来界定类型参数，它规定类型的下界;</p>
<p>子类通配符&lt;? extends T&gt;或&lt;? extends 具体类&gt;，由T或具体类的子类来界定类型参数，规定了类型的上界。通配符用在方法的泛型类参数或泛型类变量声明上。</p>
<p>就如:</p>
<pre><code>List&lt;?&gt; fruits = new ArrayList&lt;Fruit&gt;();
</code></pre><pre><code>// 假设定义好类Fruit及其子类Apple,下面的代码在某个类内部

void write(List&lt;? super Fruit&gt; fruit, Fruit newFruit) {
    fruit.add(newFruit);
}

Fruit read(List&lt;? extends Fruit&gt; fruit, int i) {
    return fruit.get(i);
}
</code></pre><h3 id="泛型擦除">泛型擦除</h3>
<p>在编译之后程序会采取去泛型化的措施。</p>
<p>也就是说Java中的泛型，只在编译阶段有效。</p>
<p>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加 类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段</p>

</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
