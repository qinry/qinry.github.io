<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>链表 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="数组与链表是最基础的数据结构，其他很多数据结构，都是通过它们变形来实现的。这里说明了它们的优缺点，还有链表的分类，以及相关的算法" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/tabs.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/styles/base16/solarized-light.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/properties.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/powershell.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/groovy.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/gradle.min.js"></script>

<script src="../../../../jquery/jquery.min.js"></script>

<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    
<aside class="post-toc right-0">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一数组与链表">一、数组与链表</a></li>
    <li><a href="#二链表分类">二、链表分类</a>
      <ul>
        <li><a href="#21-单链表">2.1 单链表</a></li>
        <li><a href="#22-双链表">2.2 双链表</a></li>
        <li><a href="#23-循环链表">2.3 循环链表</a></li>
      </ul>
    </li>
  </ul>
</nav>
        
</aside>


    <main class="content container">
    <div class="post">

  <h1>链表</h1>
  <span class="post-date">
    2021-01-31 22:14 &nbsp;
    字数：<strong>1378</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/algorithm/">Algorithm</a>&nbsp;
  </span>

  <h2 id="一数组与链表">一、数组与链表</h2>
<p>链表 [Linked List]：链表是由一组不必相连（不必相连：可以连续也可以不连续）的内
存结构（节点），按特定的顺序链接在一起的抽象数据类型。</p>
<p>数组和链表的区别和优缺点：
数组是一种连续存储线性结构，元素类型相同，大小相等</p>
<!-- raw HTML omitted -->
<p>链表是离散存储线性结构
n 个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一
个后续节点，首节点没有前驱节点，尾节点没有后续节点。</p>
<!-- raw HTML omitted -->
<h2 id="二链表分类">二、链表分类</h2>
<h3 id="21-单链表">2.1 单链表</h3>
<p>单链表 [Linked List]：由各个内存结构通过一个 Next 指针链接在一起组成，每一个内存结构都存在后继内存结构(链尾除外），内存结构由数据域和 Next 指针域组成。如图：</p>
<p><img src="../../../../images/posts/2021/01/algorithm-list/1.png" alt="picture"></p>
<p>Java表达单链表结点的结构：</p>
<pre><code>class LinkedList&lt;E&gt; {
    Node first;
    class Node {
        E elem;
        Node next;
    }
}
</code></pre><h4 id="211-插入">2.1.1 插入</h4>
<p>插入的位置为i，插入的元素为elem。从头结点开始遍历链表，找到第i-1个结点，创建包含elem的新结点插入第i-1个结点后面。</p>
<p>Java表达：</p>
<pre><code>void insert(int i, E elem) {
Node temp = new Node();
temp.elem = elem;
Node curr = first;
for (int j = 1; j &lt; i; j++) {
    curr = curr.next;
}
temp.next = curr.next;
curr.next = temp;
}
</code></pre><p>链表的插入、删除与查找之前是要边界检查的，在这些操作过程中可以使用成员变量size，统计结点数，也就是链表长度，为了突出重要的步骤，不过这里省略了。后面的代码也是如此。</p>
<h4 id="212-删除">2.1.2 删除</h4>
<p>删除第i个元素。从头结点开始遍历链表，找到第i-1个结点，删除其后面的结点。</p>
<p>Java表达：</p>
<pre><code>E delete(int i) {
    Node curr = first;
    for (int i = j; i &lt; i-1; j++) {
        curr = curr.next;
    }
    Node old = curr;
    curr = curr.next;
    old.next = curr.next;
    curr.next = null;
    return curr.elem;
}
</code></pre><h4 id="213-查询">2.1.3 查询</h4>
<p>查询第i个元素。从头结点开始遍历链表，找到第i个结点，取出元素。</p>
<p>java表达：</p>
<pre><code>E find(int i) {
    Node curr = first;
    for (int j = 0; j &lt; i; j++) {
        curr = curr.next;
    }
    return curr.elem;
}
</code></pre><h3 id="22-双链表">2.2 双链表</h3>
<p>双向链表 [Double Linked List]：由各个内存结构通过指针 Next 和指针 Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构(链头没有前驱，链尾没有后继），内存结构由数据域、Prev 指针域和 Next 指针域组成。</p>
<p><img src="../../../../images/posts/2021/01/algorithm-list/2.png" alt="picture"></p>
<p>它的结构类似单链表，我在链表的首尾加了两个哨兵结点（pre和post），加不加哨兵结点只是出于策略的考虑和自己的喜好使用即可，不过我喜欢在双向链表使用哨兵结点，方便插入与删除的操作，且代码写起来更加简单。</p>
<pre><code>class DoublyLinkedList&lt;E&gt; {
    Node pre;
    Node post;
    class Node {
        E elem;
        Node prev;
        Node next;
    }
    {
        pre = new Node();
        post = new Node()
        pre.next = post;
        post.prev = pre;
    }
}
</code></pre><h4 id="221-插入">2.2.1 插入</h4>
<p>与单链表插入类似。先创建新结点，顺序查找到第i-1个结点x，再得到其后驱结点y，将新结点插入它们之间。</p>
<p>java表达：</p>
<pre><code>void insert(int i, E elem) {
    Node temp = new Node();
    temp.elem = elem;

    Node x = pre;
    for (int j = 0; j &lt; i; j++) {
        x = x.next;
    }
    Node y = x.next;
    x.next = temp;
    temp.prev = x;
    temp.next = y;
    y.prev = temp;
}
</code></pre><h4 id="222-删除">2.2.2 删除</h4>
<p>顺序查找到第i个结点y，得到它的前驱结点x和后驱结点z，将y删除。</p>
<p>java表达：</p>
<pre><code>E delete(int i) {
    Node y = pre.next;
    for (int j = 0; j &lt; i; j++) {
        y = y.next;
    }
    Node x = y.prev;
    Node z = y.next;

    x.next = z;
    z.prev = x;
    y.next = null;
    y.prev = null;
}
</code></pre><h4 id="223-查询">2.2.3 查询</h4>
<p>与单链表一样。</p>
<h3 id="23-循环链表">2.3 循环链表</h3>
<p>单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 Next 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。</p>
<p>双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 Next 和指针Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p>
<p><img src="../../../../images/posts/2021/01/algorithm-list/3.png" alt="picture"></p>
<p>把单向链表的尾结点的Next指针指向头结点就成了单向循环链表。双向循环链表也是一样。一般地，循环链表都是保存尾结点的指针，通过尾结点的到第一个结点，来遍历链表，方便所有位置的插入、删除。插入、删除还有查找的操作与单链表和双链表没什么区别，这里就不多余展示了。</p>

</div>


    </main>
    <button class="backtop-btn">
<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
</svg>
</button>
    
      
    
  </body>
</html>
