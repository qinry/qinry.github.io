<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Java内部类 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="Java编程思想读书笔记——内部类" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script>hljs.highlightAll();</script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>Java内部类</h1>
  <span class="post-date">
    2019-10-24 16:48 &nbsp;
    字数：<strong>2381</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
  </span>

  <h2 id="创建内部类">创建内部类</h2>
<p>直接将内部类置于外围类中</p>
<pre><code>// innerclasses/Parcel1.java
// Creating inner classes
public class Parcel1 {
 class Contents {
  private int i = 11;
  public int value() { return i; }
 }

 class Destination {
  private String label;

  Destination(String whereTo) {
   label = whereTo;
  }

  String readLabel() { return label; }
 }
 // Using inner classes looks just like
 // using any other class, within Parcel1;
 public void ship(String dest) {
  Contents c = new Contents();
  Destination d = new Destination(dest);
  System.out.println(d.readLabel());
 }
 public static void main(String[] args) {
  Parcel1 p = new Parcel1();
  p.ship(&quot;Tasmania&quot;);
 }
} /* Output:
Tasmania
*///:~
</code></pre><p>如果想从外部类的非静态方法之外的任意位置创建内部类的对象，那么不像在 <strong>main</strong>方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。</p>
<h2 id="链接到外部类">链接到外部类</h2>
<p>内部类除了时名字隐藏和组织代码的模式，它还与制造它的外围类发生联系，能访问其外围对象的所有成员，无需任何特殊条件</p>
<pre><code>//: innerclasses/Parcel2.java
// Returning a reference to an inner class
public class Parcel2 {
 class Contents {
  private int i = 11;

  public int value() { return i; }
 }

 class Destination {
  private String label;

  Destination(String whereTo) {
   label = whereTo;
  }

  String readLabel() { return label; }
 }

 public Destination to(String s) {
  return new Destination(s);
 }

 public Contents contents() {
  return new Contents();
 }

 public void ship(String dest) {
  Contents c =  contents();
  Destination d = to(dest);
  System.out.println(d.readLabel());
 }

 public static void main(String[] args) {
  Parcel2 p = new Parcel2();
  p.ship(&quot;Tasmaina&quot;);
  Parcel2 q = new Parcel2();
  // Defining references to inner classes:
  Parcel2.Contents c = q.contents();
  Parcel2.Destination d = q.to(&quot;Borneo&quot;);
 }
}
</code></pre><p>这是个迭代器设计模式。内部类用到了<strong>items</strong>，它并不是内部类的部分，是外围类的private字段，说明了内部类可以访问外部类的成员。</p>
<p>当某个外围类创建了一个内部类对象，此内部类对象必定秘密捕获一个指向外围类的引用。然后，在你访问此外围类的成员时，就是通过那个引用来选择外围类成员。一般编译器会处理捕获引用的细节，而且内部对象只能在与其外围类的对象发生相关联的情况下才能被创建（内部类有使用外围类成员就会发生关联）。内部类是非static类。</p>
<h2 id="使用this-与-new">使用.this 与 .new</h2>
<p>如果内部类需要生成对外部类对象的引用，可以<strong>OuterClassName.this</strong>像这样，产生的引用会在编译器自动确定正确类型，没有运行时开销。</p>
<pre><code>//: innerclasses/DotThis.java
// Accessing the outer-class object
public class DotThis {
 void f() { System.out.println(&quot;DotThis.f()&quot;); }
 public class Inner {
  public DotThis outer() {
   return DotThis.this;
   // A plain &quot;this&quot; would be Inner's &quot;this&quot;
  }
 }

 public Inner inner() { return new Inner(); }
  public static void main(String[] args) {
   DotThis dt = new DotThis();
   DotThis.Inner dti = dt.inner();
   dti.outer().f();
 }
}
</code></pre><p>如果可能创建某个对象的内部类对象，要在new表达式中提供外部类对象的引用, 像<strong>OuterObject.new</strong>的表达式</p>
<pre><code>//: innerclasses/DotNew.java
// Creating an inner class directly using .new syntax
public class DotNew {
 public class Inner { }
 public static void main(String[] args) {
  DotNew dn = new DotNew();
  DotNew.Inner dni = dn.new Inner(); 
 }
}
</code></pre><h2 id="内部类向上转型">内部类向上转型</h2>
<p>内部类向上转型为其基类，尤其是转型为一个接口，会有大用途。这是因为内部类可以设定为private（或protected），能够对外部（或包外除继承子类）不可见且不可用，得到的只是指向基类或接口的引用，所以通过这种方式可以完全组织任何依赖于类型的编码，很方便地实现隐藏实现细节。只有内部类可以设为private和protected。</p>
<h2 id="在方法和作用域的内部类">在方法和作用域的内部类</h2>
<p>在方法中或任意的作用域中定义内部类，有两个原因：</p>
<p>1.实现某个类型的接口，可以创建并返回对其的引用</p>
<p>2.要解决一个复杂问题，借用一个类辅助，但又不希望此类是公共可用的</p>
<h3 id="局部内部类">局部内部类</h3>
<p>在方法和作用域中，需要已命名的构造器或重载构造器，使用局部内部类，相比匿名类，可以使用多个该类对象。</p>
<h3 id="匿名内部类">匿名内部类</h3>
<p>把对象生成和类型定义结合在一起，用在方法的返回值中, 只能实例初始化，如：</p>
<pre><code>public interfaces Destination {
    String readLabel();
}
public class Parcel9 {
// Argument must be final or &quot;effectively final&quot;
// to use within the anonymous inner class:
 public Destination destination(final String dest) {
  return new Destination() {
   private String label = dest;
   @Override
   public String readLabel() { return label; }
  };
 }
 public static void main(String[] args) {
  Parcel9 p = new Parcel9();
  Destination d = p.destination(&quot;Tasmania&quot;);
  //System.out.println(d.readLabel());
 }
}
</code></pre><p>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final。想做一些类似构造器的行为，但匿名类没有命名的构造器，可以用实例初始化来达到构造器的行为。</p>
<h3 id="再访工厂方法">再访工厂方法</h3>
<pre><code>//: innerclasses/Factories.java
import static net.mindview.util.Print.*;

interface Service {
    void method1();
    void method2();
}

interface ServiceFactory {
    Service getService();
}

class Implementation1 implements Service {
    private Implementation1() {}
    public void method1() { print(&quot;Implementation1.method1&quot;); }
    public void method2() { print(&quot;Implementation1.method2&quot;); }
    public static ServiceFactory factory = 
        new ServiceFactory() {
            @Override
            public Service getService() {
                return new Implementation1();
            }
        };
}

class Implementation2 implements Service {
    private Implementation2() {}
    public void method1() { print(&quot;Implementation2.method1&quot;); }
    public void method2() { print(&quot;Implemetation2.method2&quot;); }
    public static ServiceFactory factory =
        new ServiceFactory() {
            @Override
            public Service getService() {
                return new Implementation2();
            }
        };
}

public class Factories {
    public static void serviceConsumer(ServiceFactory fact) {
        Service s = fact.getService();
        s.method1();
        s.method2();
    }
    public static void main(String[] args) {
        serviceConsumer(Implementation1.factory);
        serviceConsumer(Implementation2.factory);
    }
}
</code></pre><p><strong>Implementation1</strong> 和 <strong>Implementation2</strong>的构造器是private的，并且没有任何要去创建作为工厂的具名类。另外，你经常只需要单一的工厂对象，因此在本例中它被创建为Service实现中的一个static域。</p>
<h3 id="嵌套类">嵌套类</h3>
<p>将内部类声明为static，通称为嵌套类。意味着要创建嵌套类的对象，并不需要其外围类的对象；不能从嵌套类的对象中访问非静态的外围类对象。也就说嵌套类是与外部类没有联系的内部类。它和内部类的区别在于，普通内部类的字段和方法不能是static，也不能包含嵌套类，而嵌套类可以包含这些。</p>
<h4 id="接口内部的类">接口内部的类</h4>
<p>如果想创建某些 <em>公共代码</em> ，使得它可以被某个接口的所有不同实现所共用，那么在接口内部嵌套类会显得方便。接口中的类自动地是public 和 static的，因为类是static的，只是将嵌套类置于接口的命名空间内，并不会违反接口的规则。</p>
<pre><code>
public interface ClassInInterface {
    void howdy();
    class Test implememnts ClassInInterface {
        public void howdy() {
            System.out.println(&quot;Howdy!&quot;);
        }
        public static void main(String[] args) {
            new Test().howdy();
        }
    }
}
</code></pre><p>一般建议为每个类写一个<strong>main</strong>函数，用来测试这个类，这样做有个缺点，必须带着那些已编译过的额外代码。如果这对你很麻烦，可以使用嵌套类来放置测试代码，在不需要的时候，删掉嵌套类文件。</p>
<p>一个内部类被嵌套多少层，都能够透明地访问到所有它所嵌入的外围类的所有成员。</p>
<h2 id="为什么需要内部类">为什么需要内部类</h2>
<p>可以认为内部类提供某种进入其外围类的窗口。还可以是多继承的解决方案变得完整，
如果拥有的是抽象的类或具体的类，而不是接口，只能使用内部类实现多继承。</p>
<h2 id="继承内部类">继承内部类</h2>
<p>继承内部类的构造器必须连接到指向基类的外围类的引用，还要在构造器内调用基类的构造器
，编译才能通过。</p>
<pre><code>//: innerclasses/InheritInner.java
// Inheriting an inner class
class WithInner {
 class Inner {}
}
public class InheritInner extends WithInner.Inner {
 //- InheritInner() {} // Won't compile
 InheritInner(WithInner wi) {
  wi.super();
 }
 public static void main(String[] args) {
  WithInner wi = new WithInner();
  InheritInner ii = new InheritInner(wi);
 }
}
</code></pre><h2 id="内部类可以覆盖吗">内部类可以覆盖吗</h2>
<p>当继承了某个外围类时，内部类并没有发生什么神奇的变化,两个内部类时完全独立的两个实体。</p>
<h2 id="内部类标识符">内部类标识符</h2>
<p>类文件命名规则其实是外围类名字加上$，再加上内部类的名字;
如果内部类是匿名类，编译器简单地产生一个数字作为标识符；
如果内部类是嵌套在别的内部类之中，只需直接将它们的名字放在其外围类标识符与$的后面
例如：</p>
<blockquote>
<p>Counter.class,
LocalInnerClass$1.class, // 匿名类标识符：用一个数字表示，文件命名：外围类名字+$+数字
LocalInner$1LocalCounter.class, //
LocalInnerClass.class</p>
</blockquote>

</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
