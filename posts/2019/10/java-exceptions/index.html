<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Java的异常处理 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="Java编程思想读书笔记——异常处理" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script>hljs.highlightAll();</script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>Java的异常处理</h1>
  <span class="post-date">
    2019-11-24 08:47 &nbsp;
    字数：<strong>1831</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
  </span>

  <h2 id="异常抛出">异常抛出</h2>
<p>创建一个异常对象，然后从当前环境对象抛出，阻止当前方法或作用域的执行。</p>
<p>语法: <code>throw new NullPointerException</code>, 关键字<code>throw</code>之后，和创建普通对象一样创建异常对象, <code>new &lt;异常类&gt;</code>。</p>
<h2 id="异常捕获">异常捕获</h2>
<p>try块中执行代码，遇到异常抛出，交给catch捕获, 然后进行异常处理。将try-catch语句可以放入while循环，由于try中抛出异常，会在catch中匹配，是不会回到原来的地方，在while帮助下，会恢复原来之前地方继续执行，这是一种恢复模型（不太实用，尽量少用，因为它会导致耦合），不然就是终止模型。</p>
<p>语法:</p>
<pre><code>try {
    // 这里抛出异常
} catch(Exception e) {
    // 这里匹配后处理
}
</code></pre><h2 id="异常说明">异常说明</h2>
<p>为了让调用者能知道方法可以抛出异常，以便于捕获它们，使用异常说明，作为方法声明的一部分,在参数列表之后，花括号之前。可以声明方法将抛出异常，实际不抛出，为异常先占个位子，对于定义抽象基类和接口时比较重要，其派生类或接口实现将能抛出预声明的异常</p>
<p>语法:</p>
<pre><code>void f() throws Exception {
    /// 会抛出异常
}
</code></pre><h2 id="finally子句">finally子句</h2>
<p>用finally子句进行清理，不仅限于内存清理，还有资源恢复初始态，如把打开的文件关闭等等。常常将finally放在catch之后。</p>
<p>语法:</p>
<pre><code>try {
    // 抛出异常
} catch(Exception e) {
    // 处理异常
} finally {
    // 清理
}
</code></pre><p>finally能保证总是执行的。在它之前有return，也会在方法结束前，执行finally子句。</p>
<p>注意：finally有缺陷，会导致一些异常被忽略,如下:</p>
<pre><code>// 在某个类内部
static void f() throws FirstException {}
static void g() throws SecondException {}
public static void main(String[] args) {
    try {
        try {
            f();
        } finally {
            g();
        }
    } catch(Exception e) {

    }
}
</code></pre><p>这里导致 f( ) 的FirstException被忽略。</p>
<p>对于构造阶段可能抛出的异常，并且要清理的类，最安全的做法是嵌套的try。防止对象未创建部分被清理，如下:</p>
<pre><code>public class Cleanup {
    public static void main(String[] args) {
        try {
            // 自定义的类,打开文件
            InputFile in = new InputFile(&quot;text.txt&quot;); 
            try {
                String s;
                int i = 0;
                while ((s = in.getLine()) != null)
                    ; // 文件一行一行读到s中
            } catch(Exception e) {
                System.out.println(&quot;Caught Exception in main&quot;);
                e.printStackTrace(System.out); // 打印栈轨迹
            } finally {
                in.dispose(); // 清理
            }
        } catch(Exception e) {
            System.out.println(&quot;InputFile construction failed&quot;);
        }
    }
}
</code></pre><h2 id="异常的限制">异常的限制</h2>
<p>当覆盖方法的时候，只能抛出在基类方法的异常说明列出异常及其派生的异常。</p>
<p>注意：某个类继承它的基类，和实现它的接口，其中基类和接口有同名方法，分别有不同的异常说明，接口的不能改变基类方法的异常说明接口；异常限制对构造器不起作用，派生类构造器不能捕获基类构造器抛出的异常，所以派生构造器必须包括基类构造器的异常说明；一个出现在基类的异常说明不一定在派生类方法的异常说明出现，说明某个特定方法的“异常说明接口”可能是变小，这和类接口在继承的情况相反。</p>
<h2 id="异常匹配">异常匹配</h2>
<p>抛出异常后，会根据代码书写顺序找出最前的catch子句处理后，不再向下查找catch子句。还有不要求完全匹配，可以是基类异常。</p>
<p>注意:应该把派生类异常放在前，基类放在后面，否则报告错误。如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">// 这样做如果成功，会导致派生异常屏蔽，故不允许，报错.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> DerivedException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span>BaseException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span>DerivedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><h2 id="异常类的方法">异常类的方法</h2>
<p>Java标准库异常类的基类是Throwable。</p>
<p>方法如下:</p>
<pre><code>// 获取详细信息，或本地语言表示信息
String getMessage()
String getLocalizedMessage()

// 对Throwable的简单描述，有详细信息就包括在内
String toString()

// 打印栈轨迹
void printStackTrace()
void printStackTrace(PrintStream)
void printStackTrace(java.io.PrintWriter)

// 在Throwable对象内部记录栈帧的当前(新)状态
Throwable fillInStackTrace() 
</code></pre><h2 id="异常链">异常链</h2>
<p>定义：捕获异常后抛出另一个异常，并把原始异常信息保存下来。</p>
<p>Throwable子类包括Error（报告系统错误）, Exception（最常用的异常）以及RuntimeException（运行时异常，又称未检查异常）的构造器，有接受Cause参数(表示原始异常对象)的构造器,把原始异常传递给新异常。有同等效果的一个方法,initCause()也能传递原始异常。</p>
<p>如下:</p>
<pre><code>try {
    // ..
} catch(OneException e) {
    throw new RuntimeException(e);// 传递新异常，并抛出
}
// 在某个方法内
OneException e = new OneException(); // 自定义继承Exception的异常类
e.initCause(new NullPointerException());
throw e;
</code></pre><h3 id="把异常传递给控制台">把异常传递给控制台</h3>
<p>给main()声明异常说明Exception, 把它传递个控制台</p>
<pre><code>import java.io.*;
public class MainException {
    public static
    void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(
            new InputStreamReader(System.in)
            );
        String s = in.readLine();
        System.out.println(&quot;s =  &quot; + s);
    }
}
</code></pre><p>这样就不必在main()中写try-catch语句。</p>
<h3 id="把被检查异常转换为不检查类型">把被检查异常转换为不检查类型</h3>
<p>异常链保证把被检查异常的检查屏蔽掉，又不丢失它的信息。用getCause()找回原始异常类的信息。如下:</p>
<pre><code>import java.io.*;

class WrapCheckedException {
    void throwRuntimeException(int type) {
        try {
            switch(type) {
                case 0: throw new FileNotFoundException();
                case 1: throw new IOException();
                case 2: throw new RumtimeException(&quot;Where am I？&quot;);
                default: return;
            }
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class SomeOtherException extends Exception {}

public class TurnOffChecking {
    public static void main(String[] args) {
        WrapCheckedException wce = new WrapCheckedException();
        wce.throwRuntimeException(3);
        for (int i = 0; i &lt; 4; i++)
            try {
                if (i &lt; 3)
                    wce.throwRuntimeException(i);
                else
                    throw new SomeOtherException();
            } catch(SomeOtherException e) {
                System.out.println(&quot;SomeOtherException: &quot; + e);
            } catch(RuntimeException e) {
                try {
                    throw e.getCause();
                } catch(FileNotFoundException e) {
                    System.out.println(&quot;FileNotFoundException: &quot; + e);
                } catch(IOException e) {
                    System.out.println(&quot;IOException: &quot; + e);
                } catch(Throwable e) {
                    System.out.println(&quot;Throwable: &quot; + e);
                }
            }
    }
}

</code></pre>
</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
