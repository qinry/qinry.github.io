<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>数据结构与算法分析(笔记) -- 开始 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="简单说明时间复杂度和时间复杂度的概念；掌握写递归算法的法则，知道大O标记来描述算法时间复杂度，最大子序列和问题的解法，介绍两条简单的算法" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>数据结构与算法分析(笔记) -- 开始</h1>
  <span class="post-date">
    2019-10-17 23:29 &nbsp;
    字数：<strong>736</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/algorithm/">Algorithm</a>&nbsp;
  </span>

  <h2 id="递归使用的基本法则">递归使用的基本法则</h2>
<ol>
<li>基准情形：要有退出条件</li>
<li>不断推进：从初始条件趋向退出条件</li>
<li>设计准则 ：假设递归准确执行</li>
<li>合成效益法则：防止重复工作，比如生成斐波那契数列的递归实现使用双递归，导致一些工作的重复，进而影响效率</li>
</ol>
<p>递归符合前三个法则才能正确进行，符合第四法则递归的使用才有意义。虽然递归的代码逻辑清晰，不过某些情况效率不高。当递归不能很好解决问题时，可能考虑采用迭代。</p>
<h2 id="算法分析">算法分析</h2>
<p>4种描述算法效率的数学模型，常用的有大O记法</p>
<p>大O记法：时间T(N) = O( f( N ) ), 意思是T( N ) 的相对增长率小于 f(N)</p>
<h3 id="计算运行时间">计算运行时间</h3>
<p>一般法则</p>
<ol>
<li>FOR循环</li>
<li>嵌套的FOR循环</li>
<li>顺序语句</li>
<li>IF/ELSE语句</li>
</ol>
<hr>
<h4 id="最大子序列和问题解">最大子序列和问题解</h4>
<h5 id="算法1嵌套3层for循环">算法1（嵌套3层for循环）</h5>
<pre><code>int
MaxSubsequenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i, j, k;

    MaxSum = 0;
    for (i = 0; i &lt; N; i++)
        for (j = i; j &lt; N; j++)
        {
            ThisSum = 0;
            for (k = i; k &lt;= j; k++)
                ThisSum += A[k];
            if (ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    return MaxSum;
}
</code></pre><h5 id="算法2嵌套2层for循环">算法2（嵌套2层for循环）</h5>
<pre><code>int
MaxSubsequenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i, j;

    MaxSum = 0;
    for (i = 0; i &lt; N; i++)
    {
        ThisSum = 0;
        for (j = i; j &lt; N; j++)
        {
            ThisSum += A[j];
            if (ThisSum &gt; MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}
</code></pre><h5 id="算法3分治">算法3（分治）</h5>
<pre><code>int Max3(int x, int y, int z)
{
    return (x &gt; y
            ? (x &gt; z ? x : z)
            : (y &gt; z ? y : z)
            );
}
static int
MaxSubSum(const int A[], int Left, int Right)
{
    int MaxLeftSum, MaxRightSum;
    int MaxLeftBorderSum, MaxRightBorderSum;
    int LeftBorderSum, RightBorderSum;
    int Centerm i;

    if ( Left == Right )
        if ( A[Left] &gt; 0 )
            return A[ Left ];
        else
            return 0;

    Center = (Left + Right) / 2;
    MaxLeftSum = MaxSubSum( A, Left, Center);
    MaxRightSum = MaxSubSum(A, Center + 1, Right);

    MaxLeftBorderSum = 0;LeftBorderSum = 0;
    for (i = Center; i &gt;= Left; i--)
    {
        LeftBorderSum += A[i];
        if (LeftBorederSum &gt; MaxLeftBorderSun)
            MaxLeftBorderSum = LeftBorderSum;
    }

    MaxRightBorderSum = 0;RightBorderSum = 0;
    for (i = Center + 1; i &lt; Right; i++)
    {
        RightBorderSum += A[i];
        if (RightBorderSum &gt; MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    return Max3(MaxLeftSum, MaxRightSum,
            MaxLeftBorderSum + MaxRightBorderSum);
}
int
MaxSubsquenceSum(const int A[], int N)
{
    return MaxSubSum(A, 0, N - 1);
}
</code></pre><h5 id="算法4联机算法">算法4(联机算法)</h5>
<pre><code>int
MaxSubsquenceSum(const int A[], int N)
{
    int ThisSum, MaxSum, i;

    ThisSum = MaxSum = 0;
    for (i = 0; i &lt; N; i++)
    {
        ThisSum += A[i];

        if (ThisSum &gt; MaxSum)
            MaxSum = ThisSum;
        else if (ThisSum &lt; 0)
            ThisSum = 0;
    }
    return MaxSum;
}
</code></pre><h4 id="欧几里得算法">欧几里得算法</h4>
<pre><code>int gcd(int M, int N)
{
    int Rem;
    while ( N == 0 )
    {
        Rem = M % N;
        M = N;
        N = Rem;
    }
    return M;
}
</code></pre><h4 id="求幂运算">求幂运算</h4>
<pre><code>_Bool IsEven(int N)
{
    if (N % 2)
        return 0;
    return 1;
}
int Pow(int X, int N)
{
    if (N == 0)
        return 1;
    if (N == 1)
        return X;
    if IsEven(N)
        return Pow(X * X, N / 2);
    else
        return Pow(X * X, N / 2) * X;
}
</code></pre>
</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
