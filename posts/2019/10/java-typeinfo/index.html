<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Java类型信息 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="Java编程思想读书笔记——类型信息" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>Java类型信息</h1>
  <span class="post-date">
    2019-11-28 18:25 &nbsp;
    字数：<strong>2858</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
  </span>

  <h2 id="class对象">Class对象</h2>
<p>每个类都存在包含类型信息的Class对象，Class对象属于Java类中Class类型。有两种方法获得某类型的Class 对象，一种是使用<code>Class.forName()</code>静态方法，接受包含完整类名的字符串参数，创建对应类型的Class对象;第二种类字面量，<code>&lt;ClassName&gt;.class</code>。forName()方法必须放在try语句块，而类字面量不需要，故效率更高。</p>
<p>例子：</p>
<pre><code>class Rock {
    static { System.out.println(&quot;Hi, I'm a Rock!&quot;); }  
    public String  toString() {
        return &quot;I don't like water&quot;;
    }
}

public class PlayRock {
    static void play(Rock rc) {
        System.out.println(rc);
    }
    public static void main(String[] args) {
        try {
            Class&lt;?&gt; type = Class.forName(&quot;Rock&quot;);  // ?是通配符表示任何事物
        } catch(ClassNotFoundException e) {
            System.out.println(&quot;No find Rock&quot;);
        }
        Rock rc = null;
        try {
            rc = (Rock)type.newInstance(); // 实例化得到却是Object引用，所以要强制类型转换
            play(rc);
        } catch(InstantiationException e) {
            System.out.println(&quot;Cannot instantiate&quot;);
            System.exit(1);
        } catch(IllegalAccessException e) {
            System.out.println(&quot;Cannot access&quot;);
            System.exit(1);
        }
    }
}
</code></pre><p>output:</p>
<blockquote>
<p>Hi, I&rsquo;m a Rock!<br>
I don&rsquo;t like water</p>
</blockquote>
<p>Class包含了很多方法，比如: 获取类型的名称的getName(),getSimpleName( ),getCanonicalName( );获得当前Class对象指向某个类的超类的Class对象getSuperclass( ),
获得的Class对象不等同当前class对象的超类;实例化方法newInstance( ),注意其返回的是Object引用;isAssignableFrom()检查对象是否在Class对象引用类型的继承体系。</p>
<h2 id="cast-方法">cast( )方法</h2>
<p>cast( )接受参数对象，将其类型转换为Class指向的类型。用法形似c++的dynamic_cast&lt; T &gt;(obj ) 。</p>
<p>例子:</p>
<pre><code>class Building {}
class House extends Building {}

public class ClassCasts {
    public static void main(String[] args) {
        Building b = new House();
        Class&lt;House&gt; houseType = House.class; // 使用泛化Class引用
        House h = houseType.cast(b);
        h = (House)b; // ... 或者这样做.
    }
}
</code></pre><p>如果类型转换出错了，回抛出 <code>ClassCastException</code> 异常</p>
<h2 id="类型检查">类型检查</h2>
<p>它们都是用来检查某个对象是否是某个类型的实例对象，类型检查用在类型转换之前。</p>
<h3 id="关键字instanceof">关键字instanceof</h3>
<p>它会返回boolean类型值。不过其之后必须跟类型名，否则报错。</p>
<pre><code>if  (x instanceof Dog)
    ((Dog)x).bark( );
</code></pre><p>当进行多个类型检查必须一个一个罗列。</p>
<h3 id="classisinstance-方法">Class.isInstance( )方法</h3>
<p>提供动态测试对象类型的方法，使用更为灵活。使用for循环可以方便对一个对象进行多次检查</p>
<pre><code>for (class t : types)
    if (t.isInstance(obj))
        // 执行一些操作
</code></pre><p>解释:types是Class数组，obj实例对象，检查obj是否是types数组中所指类型。</p>
<h2 id="反射机制">反射机制</h2>
<p>由java.lang.reflect类库提供支持，包含实现Member接口的Field, Method, Constructor类，分别表示未知类型的域，方法，构造器。getFields( )得到Field数组,
同理getMethods( )和 getConstructors( )是Method数组，Constructor数组。比较常用的是对Method对象调用invoke()使用Method关联的方法, 对Field对象
用get( )读取字段，set( ) 设置字段。</p>
<h3 id="与rtti的区别">与RTTI的区别</h3>
<p>对于 RTTI，编译器在编译时打开和检查.class文件，而反射机制是在运行时进行的，还有要知道Class.forName( )生成结果在编译时是不知道的。</p>
<p>反射机制提供足够的支持，使得能够创建一个编译时期完全未知的对象，并调用该对象的方法。还支持对象序列化和JavaBean。</p>
<h3 id="类方法提取器">类方法提取器</h3>
<p>通过反射机制能很好帮助我们了解某个类的完整接口。</p>
<p>例程：</p>
<pre><code>// e.g {java ShowMethods ShowMethods}
import java.lang.reflect.*;

public class ShowMethods {
    public static void main(String[] args) {
        if (args.length &lt;  1) {
            System.exit(0);
        }
        try {
            Class&lt;?&gt;  c = Class.forName(args[0]);
            Method[] methods = c.getMethods();
            Constructor[] ctors = c.getConstructors();
            if (args.length == 1) {
                for (Method method : methods) {
                    System.out.println(method.toString());
                }
                for (Constructor ctor : ctors) {
                    System.out.println(ctor.toString());
                }
            } else {
                for (Method method : methods) {
                    if (method.toString().indexOf(args[1]) != -1) {
                        System.out.println(method.toString());
                    }
                }
                for (Constructor ctor : ctors) {
                    if (ctor.toString().indexOf(args[1]) != -1) {
                        System.out.println(ctor.toString());
                    }
                }
            }
        } catch(ClassNotFoundException e) {
            System.out.println(&quot;No such class: &quot; + e);
        }
    }
}
</code></pre><p>output:</p>
<blockquote>
<p>public static void ShowMethods.main(java.lang.String[])
public final void java.lang.Object.wait(long,int) throws
java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws
java.lang.InterruptedException
public final void java.lang.Object.wait() throws
java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
public ShowMethods()</p>
</blockquote>
<h2 id="动态代理">动态代理</h2>
<p>例程:</p>
<pre><code>import java.lang.reflect.*;

interface Interfaces {
    void doSomething();

    void somethingElse(String arg);
}

class RealObject implements Interfaces {
    public void doSomething() {
        System.out.println(&quot;doSomething&quot;);
    }

    public void somethingElse(String arg) {
        System.out.println(&quot;somethingElse : &quot; + arg);
    }
}

class DynamicProxyHandler implements InvocationHandler {
    private Object proxied; // 被代理

    public DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }
    // 接口调用重定向为代理的调用
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(
                &quot;**** proxy: &quot; + proxy.getClass() + &quot;, method: &quot; + method + &quot;, args: &quot; + args);
        if (args != null)
            for (Object arg : args)
                System.out.println(&quot; &quot; + arg);
        return method.invoke(proxied, args); // 转发给被代理对象调用
    }
}

public class SimpleDynamicProxy {
    public static void consumer(Interfaces iface) {
        iface.doSomething();
        iface.somethingElse(&quot;bonobo&quot;);
    }

    public static void main(String[] args) {
        RealObject real = new RealObject();
        consumer(real);
        // 添加代理并再次调用实际对象
        Interfaces proxy = (Interfaces) Proxy.newProxyInstance(Interfaces.class.getClassLoader(),
                new Class[] { Interfaces.class }, new DynamicProxyHandler(real));
        consumer(proxy);
    }
}
</code></pre><p>Output:</p>
<blockquote>
<p>doSomething<br>
somethingElse : bonobo<br>
**** proxy: $Proxy0, method: public abstract void<br>
Interfaces.doSomething(), args: null<br>
doSomething<br>
**** proxy: $Proxy0, method: public abstract void<br>
Interfaces.somethingElse(java.lang.String), args:<br>
[Ljava.lang.Object;@4b67cf4d
bonobo
somethingElse : bonobo</p>
</blockquote>
<p>静态方法Proxy.newProxyInstance()可以创建动态代理，它接受三个参数，一、类加载器,通过已经加载的对象获取，如上的Interfaces.class.getClassLoader( );二、希望代理实现的接口列表不包括类或者抽象类;三、InvocationHandler接口的实现。动态代理将所有方法的调用重定向给调用处理器，所以常常向调用处理器的构造器传入“实际”对象的引用，以便调用处理器请求转发任务。</p>
<h2 id="空对象">空对象</h2>
<p>内置null表示缺少对象，每次使用引用是都必须检测是否为null，使用null会引发NullPointerException异常;而使用空对象就可以不检查null，但同样来表示为空值，可以简单理解为通过实际对象虚拟的空值对象，来替代null，变得更智能。不过如果需要测试其为空，只要创建一个标记接口就行了。如：</p>
<pre><code>// Null.java
public interface Null { }
</code></pre><p>让空对象实现这个标记接口，通过<code>instanceof</code>来探测空对象，不强制为所有的类添加像isNull( )方法。空对象通常是单例，用<code>staic</code> 和<code>final</code> 修饰，故还可以使用equals()，== 与 空对象比较。空对象可以使用具体类或接口来创建，如果是通过接口，可以使用DynamicProxy自动创建空对象。</p>
<p>例程：</p>
<pre><code>// Book.java
public interface Book {
    String title();
    double price();
    int count();
    double total();
    class Test {
        public static void test(Book b) {
            if (b instanceof Null)
                System.out.println(&quot;Null Object&quot;);
            System.out.println(&quot;title : &quot; + b.title());
            System.out.println(&quot;count: &quot; + b.count() + &quot;, price: &quot;
             + b.price());
            System.out.println(&quot;total price: &quot; + b.total());
        }
    }
}

// Novel.java
public class Novel implements Book {
    private String title;
    private double price;
    private int count;

    public Novel(String title) {
        this.title = title;
    }

    public Novel(String title, double price) {
        this(title);
        this.price = price;
    }

    public Novel(String title, double price, int count) {
        this(title, price);
        this.count = count;
    }

    public String title() {
        return title;
    }

    public int count() {
        return count;
    }

    public double price() {
        return price;
    }

    public double total() {
        return price * (double) count;
    }

    public static void main(String[] args) {
        Book.Test.test(new Novel(&quot;Robinson Crusoe by Daniel Defoe&quot;, 47.10, 3));
    }
}
</code></pre><p>output:</p>
<blockquote>
<p>title : Robinson Crusoe by Daniel Defoe<br>
count: 3, price: 47.1<br>
total price: 141.3</p>
</blockquote>
<pre><code>// NullBook.java
import java.lang.reflect.*;

class NullBookProxyHandler implements InvocationHandler {
    private String nullName;
    private Book proxied = new NBook();

    public NullBookProxyHandler(Class&lt;? extends Book&gt; type) {
        nullName = type.getSimpleName() + &quot; NullBook&quot;;
    }

    private class NBook implements Book, Null {
        public String title() {
            return nullName;
        }

        public int count() {
            return 0;
        }

        public double price() {
            return 0.0;
        }

        public double total() {
            return 0.0;
        }
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(proxied, args);
    }
}

public class NullBook {
    public static Book newNullBook(Class&lt;? extends Book&gt; type) {
        return (Book) Proxy.newProxyInstance(Book.class.getClassLoader(), new Class[] { Book.class, Null.class },
                new NullBookProxyHandler(type));
    }

    public static void main(String[] args) {
        Book books[] = { new Novel(&quot;Thinking in Java&quot;, 108.00, 1), newNullBook(Novel.class) };
        for (Book book : books)
            Book.Test.test(book);
    }
}
</code></pre><p>output:</p>
<blockquote>
<p>title : Thinking in Java<br>
count: 1, price: 108.0<br>
total price: 108.0<br>
Null Book<br>
title : Novel NullBook<br>
count: 0, price: 0.0<br>
total price: 0.0</p>
</blockquote>
<h3 id="模拟对象和桩">模拟对象和桩</h3>
<p>空对象的逻辑变体是模拟对象和桩，它们都假扮可以传递实际信息的存活对象。模拟对象应用与轻量级和自测试，通常为了处理不同的测试情况被创建;桩返回桩数据，是重量级的，在测试之间被复用。</p>
<h2 id="接口与类型的信息">接口与类型的信息</h2>
<p>通过反射机制几乎可以访问类的任何成员，无论是private成员还是包访问权限的成员，抑或是内部类，匿名类。</p>
<p>举个简单例程：</p>
<pre><code>import java.lang.reflect.*;

class WithPrivateFinalField {
    private int i = 1;
    private final String s = &quot;I'm totally safe&quot;;
    private String s2 = &quot;Am I safe?&quot;;
    public String toString() {
        return &quot;i = &quot; + i + &quot;, &quot; + s + &quot;, &quot; + s2;
    }
}

public class ModifyingPrivateFields {
    public static void main(String[] args) throws Exception {
        WithPrivateFinalField pf = new WithPrivateFinalField();
        System.out.println(pf);
        Field f = pf.getClass().getDeclaredField(&quot;i&quot;);
        f.setAccessible(true);
        System.out.println(&quot;f.getInt(pf): &quot; + f.getInt(pf));
        f.setInt(pf, 47);
        System.out.println(pf);

        f = pf.getClass().getDeclaredField(&quot;s&quot;);
        f.setAccessible(true);
        System.out.println(&quot;f.get(pf): &quot; + f.get(pf));
        f.set(pf, &quot;No, you're not!&quot;);
        System.out.println(pf);

        f = pf.getClass().getDeclaredField(&quot;s2&quot;);
        f.setAccessible(true);
        System.out.println(&quot;f.get(pf): &quot; + f.get(pf));
        f.set(pf, &quot;No, you're not&quot;);
        System.out.println(pf);
    }
}
</code></pre><p>Output:</p>
<blockquote>
<p>i = 1, I&rsquo;m totally safe, Am I safe?<br>
f.getInt(pf): 1<br>
i = 47, I&rsquo;m totally safe, Am I safe?<br>
f.get(pf): I&rsquo;m totally safe<br>
i = 47, I&rsquo;m totally safe, Am I safe?<br>
f.get(pf): Am I safe?<br>
i = 47, I&rsquo;m totally safe, No, you&rsquo;re not</p>
</blockquote>
<p>不过final域是不能修改的，尽管遭到修改，运行系统会在不抛出异常的情况下接受任何修改的尝试，但是实际上不会发生任何修改</p>

</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
