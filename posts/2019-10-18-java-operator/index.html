<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.62.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>操作符 &middot; qinry&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io"><h1>qinry&#39;s blog</h1></a>
      <p class="lead">
       在此写下学习日志，努力充电中～ 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://github.com/qinry"> Github </a></li>
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>操作符</h1>
  <time datetime=2019-10-18T21:55:03&#43;0800 class="post-date">Fri, Oct 18, 2019</time>
  <h2 id="heading">静态导入</h2>
<p>通过封装，自建类库已到达更简短语句答应字符串。可以静态导入（import static LibraryName）类库中静态对象</p>
<h2 id="heading-1">表达式</h2>
<p>副作用：有些运算符可能会改变操作对象的值</p>
<p>一个表达式有多个操作符时，它们的优先级影响计算顺序，一般规则先乘除后加减，括号最先进行</p>
<p><code>System.out.println()</code> 内含<code>+</code><!-- raw HTML omitted --> , 其前是String，其后操作对象非String会转换成String，如果它是String， 不用字符串转换。最后<code>+</code> 起到拼接作用</p>
<h2 id="--">赋值( &lsquo;=&rsquo; )</h2>
<ul>
<li>
<p>基本类型，右值拷贝赋值给左值</p>
</li>
<li>
<p>对象，实际赋值操作是对象引用复制，可以理解为对象取多一个别名</p>
<p>注： 小心对象的赋值操作
一般不直接操作对象的域(形如 Object.field = value) ，容易导致混乱，违背良好的面向对象程序设计原则</p>
</li>
</ul>
<h2 id="heading-2">算术操作符</h2>
<h3 id="heading-3">加减乘除，取余运算</h3>
<p>加号 <code>+</code>, 减号 <code>-</code>, 乘号<code>*</code>, 除号 <code>/</code>, 求模<code>%</code> ,以及它们和赋值 <code>=</code><!-- raw HTML omitted --> 的复合：<code>+=</code>，<code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></p>
<p>注：%<code>%=</code> 作用于整数类型,以上是二元运算符</p>
<h3 id="heading-4">正负号</h3>
<p>一元加减运算符<code>+</code>, <code>-</code> 。 减号结果返回操作数的相反数，但操作数不改变, 加号返回值符号不变， 如果类型是小类型（如：short ,byte, char）会提升类型为int,也不改原操作数</p>
<p>注：boolean不能进行加减乘除，取余运算</p>
<h2 id="heading-5">自增自减运算符</h2>
<p>前缀自增自减是先算后返回 (如：++intVar)，后缀自增自减是先返回后算 (如：intVar++)</p>
<h2 id="heading-6">关系运算符</h2>
<p>运算结果是boolean类型值(非false即true), 分别有 <code>&gt; , &lt;, ==, !=, &gt;=, &lt;=</code>。等于和不等于适合所有的基本类型，其他比较运算符
对于boolean不适用</p>
<p>注：对象之间用 == 和 != 比较， 本质是引用上的比较，非内容的比较。比较内容用equals()方法(适用预定义好的类和自定义类覆盖equals()，新类equals()默认是比较引用)</p>
<h2 id="heading-7">逻辑运算符</h2>
<p>非(!), 且(&amp;&amp;), 或(||)</p>
<h3 id="heading-8">短路逻辑</h3>
<ul>
<li>&amp;&amp; 前一个比较结果是false,后一个不用比较，整个结果是false</li>
<li>|| 前一个比较结果是true，后一个不用比较, 整个结果是true</li>
</ul>
<h2 id="heading-9">按位运算</h2>
<p>按位且(&amp;), 按位或(|), 按位取反(~),按位异或(^), 和赋值符号复合(&amp;=, |=, ^=, 没有~=)</p>
<h2 id="heading-10">移位运算符</h2>
<p>它们只能处理整数</p>
<ul>
<li>
<p>有符号左移和右移运算符(&laquo;和&raquo;), 和赋值复合(&laquo;= 和 &raquo;=)</p>
</li>
<li>
<p>Java特有的无符号右移(&raquo;&gt;)，和赋值复合(&raquo;=)</p>
</li>
</ul>
<p>移位的位数不能超过操作数本身的宽度，也就是说int类型移位不过32位，long类型不过64位</p>
<p>char, byte, short在移位时会转换为int类型, 返回结果也为int</p>
<p>注意：&laquo;= 或 &raquo;=，其左操作数会移动右操作数指定的位数，再将结果赋值给左操作数。byte, short 使用 &raquo;&gt;=，可能遇到问题(结果会出现-1)</p>
<h2 id="heading-11">类型转换操作符</h2>
<p>形如：(type)value，具体可以写成 (byte)47;</p>
<p>基本类型可以互相转换(boolean除外), 对象也可以, 不过是派生类向上转型为基类或接口</p>
<ul>
<li>窄化转换 &ndash; 大类型降低为小类型, 会丢失一些信息</li>
<li>扩展转换 &ndash; 小类型提升为大类型</li>
</ul>
<h2 id="heading-12">三元操作符</h2>
<p>形式: (boolean-exp) ? (true-result) : (false-true);</p>
<p>等价为条件判断语句</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span><span style="color:#f92672">-</span>exp<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">true</span><span style="color:#f92672">-</span>result<span style="color:#f92672">;</span>
<span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">false</span><span style="color:#f92672">-</span>result<span style="color:#f92672">;</span>
</code></pre></div><h2 id="heading-13">字符串操作符</h2>
<ul>
<li><code>+</code> 将两个字符串拼接得到一个临时对象</li>
<li><code>+=</code> 将后字符串合并到前字符串，后字符串不改变</li>
</ul>
<p>如果表达式第一个字符串起头，后续所有操作数必须是字符串型(编译器会把双引号内的字符串序列自动转成字符串)</p>
<h2 id="heading-14">截尾和舍入</h2>
<h3 id="heading-15">截尾</h3>
<p>类型转换会截尾, 浮点类型转换整数类型，会将浮点数小数点后的数忽略得到整数</p>
<h3 id="heading-16">舍入</h3>
<p>使用Math.round()方法(在java.lang中，自动导入类，无须程序员导入)针对浮点数的四舍五入</p>
<h2 id="javasizeof">Java无sizeof</h2>
<p>C和C++有sizeof操作符出现的原因是为了代码可移植性, 不同机器相同数据类型的字长可能不同。但Java中的数据类型的字长已经确定了，也就无需sizeof</p>
<h2 id="heading-17">当心溢出</h2>
<ul>
<li>上溢 &ndash; 出现变量接受超过类型字长的值 或 运算结果超过类型值范围</li>
<li>下溢 &ndash; 大类型转换小类型，会截尾导致部分信息丢失</li>
</ul>
<h2 id="heading-18">生成随机数的类</h2>
<p>java.util 中有 Random类用于生成随机数列, 有成员方法nextInt(int), nextFloat(), nextLong(), nextDouble() 返回对应的类型值
用法如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Random rand <span style="color:#f92672">=</span> Random<span style="color:#f92672">(</span>47<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rand<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(</span>20<span style="color:#f92672">)</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 生成 0 ~ 19 中的数， 不包括
</span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> rand<span style="color:#f92672">.</span><span style="color:#a6e22e">nextFloat</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">double</span> d  <span style="color:#f92672">=</span> rand<span style="color:#f92672">.</span><span style="color:#a6e22e">nextDouble</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">long</span> l <span style="color:#f92672">=</span> rand<span style="color:#f92672">.</span><span style="color:#a6e22e">nextLong</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
</code></pre></div>
</div>


    </main>

    
  </body>
</html>
