<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>并查集 &middot; qinry&#39;s blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.top/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.top/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.top/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.top/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.top"><h1>qinry&#39;s blog</h1></a>
      <p class="lead">
       在此写下学习日志，努力充电中～ 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.top">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li>
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>并查集</h1>
  <time datetime=2020-07-06T07:34:59&#43;0800 class="post-date">Mon, Jul 6, 2020</time>
  <p><em>参考于《算法》第4版第一章第五节</em></p>
<p>问题描述：输入一对整数p、q，程序判断它们是否相连，如果相连，忽略这对数并处理下对数；否则将它们相连。p和q相连具有一种等价关系,说明：</p>
<ol>
<li>
<p>p和p本身相连；</p>
</li>
<li>
<p>如果p和q相连，那么q和p也相连；</p>
</li>
<li>
<p>如果p和q相连且q和r相连，那么p和r也相连。</p>
</li>
</ol>
<p>这个问题是个动态连通性问题，常应用于计算机网络上表示结点的连接，可能需要处理数百万的对象和数十亿的连接。</p>
<h3 id="数据结构">数据结构</h3>
<p>解决问题用到了数学抽象的集合，为了简化问题，用整数来表示对象，而不是用整数标识符和任意名称关联表示对象。将p和q是否相连问题转换为p和q是否在同一个集合。</p>
<h4 id="使用术语">使用术语</h4>
<p>对象用<em>触点</em>表示，整数对用<em>连接</em>表示。等价类，即相连的一系列对象称为<em>连通分量</em>，甚至可以为<em>分量</em>。</p>
<p>定义抽象数据类型 —— UF（union-find，并查集）</p>
<p>API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UF(int N)</td>
<td>以整数标识(0~N-1)初始化N个触点</td>
</tr>
<tr>
<td>void union(int p, int q)</td>
<td>在p和q之间添加一个连接</td>
</tr>
<tr>
<td>int find(int p)</td>
<td>p所在的分量标识符</td>
</tr>
<tr>
<td>boolean connected(int p, int q)</td>
<td>p和q是否相连，是返回true</td>
</tr>
<tr>
<td>int count()</td>
<td>连通分量的数量</td>
</tr>
</tbody>
</table>
<p>初步实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span> <span style="color:#75715e">// 分量id（以触点作为索引）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span> <span style="color:#75715e">// 分量数量
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">UF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    count <span style="color:#f92672">=</span> N<span style="color:#f92672">;</span>
    id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
      id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 以下方法，不同算法，实现各不同
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>不同算法实现并查集，性能各不同，因为在数据存放形式和数据的操作上有所不一样，或许是细微的差别。有简单的算法及其改进的算法，如：quick-find算法、quick-union算法、加权quick-union算法、路径压缩的加权quick-union算法。</p>
<h3 id="quick-find算法">quick-find算法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// ... 其他方法见上的初步实现
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// p和q归并到相同的分量中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> pID <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> qID <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>

    <span style="color:#75715e">// 如果p和q相连，不采取任何动作
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>pID <span style="color:#f92672">==</span> qID<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> id<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
      <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> pID<span style="color:#f92672">)</span> id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> qID<span style="color:#f92672">;</span>
    count<span style="color:#f92672">--;</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>分析：find()操作对数组直接操作一次，访问数组id[]一次，速度很快，这个算法无法处理大型问题，由于每一对输入union()都扫描整个数组。find()访问数组操作是常数级别的；union()是线性级别，归并时会调用2次find()，检查id数组的N个元素，还有改变元素的个数在1到N-1，总共访问数组N+3~2N+1之间。（方法主要开销在数组的访问，用数组访问操作作为算法分析的基准）用quick-find算法解决动态连通性问题且最后仅得一个分量，至少调用N-1次union()，那么至少(N+3)(N-1)~N^2次数组访问，说明quick-find解决此问题是平方级别的。</p>
<h3 id="quick-union算法">quick-union算法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// ... 其他方法见上的初步实现
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 找出分量名称
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>p<span style="color:#f92672">!=</span>id<span style="color:#f92672">[</span>p<span style="color:#f92672">])</span> p <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 将p和q的根节点统一
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> pRoot <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> qRoot <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>pRoot <span style="color:#f92672">==</span> qRoot<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span>

    id<span style="color:#f92672">[</span>pRoot<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> qRoot<span style="color:#f92672">;</span>
    count<span style="color:#f92672">--;</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>分析：数据结构用森林表示，节点与另一个节点的相连为链接，一节点指向其父节点，最终都是朝向根节点，用根节点标识分量，id[]数组是用父链接的形式表示的森林。find()操作从节点顺着链接找到根节点，在最好的情况下，访问数组一次完成操作，最坏也不过是2N+1次访问。该方法访问数组的次数为1加上两倍的所访问节点深度；union()操作假设两节点不在同一个森林，其中一个节点的根节点成为另一个根节点的父节点，接着两个树归并为一树。该方法访问数组次数是find()的两倍。quick-union最坏情况下运行时间是平方级别的，有赖于输入的特性。</p>
<h3 id="加权quick-union算法">加权quick-union算法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span> <span style="color:#75715e">// 父链接数组（由触点索引）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> sz<span style="color:#f92672">;</span> <span style="color:#75715e">// （由触点索引）各个根节点所对应的分量的大小
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span> <span style="color:#75715e">// 连通分量的数量
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">UF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    count <span style="color:#f92672">=</span> N<span style="color:#f92672">;</span>
    id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> id<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
      id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
    sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> sz<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
      sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>p<span style="color:#f92672">!=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">])</span> p <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i <span style="color:#f92672">=</span> j<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#75715e">// 将小树的根节点连接到大树的根节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> sz<span style="color:#f92672">[</span>j<span style="color:#f92672">]){</span>
      id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
      sz<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> sz<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
      id<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
      sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> sz<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
    count<span style="color:#f92672">--;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 其他方法见初步实现
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>分析：记录两棵树的大小，将小树连接到较大的树下，只需增加一个数组记录每个根节点的分量大小。访问节点所在的深度，有N个触点的话，深度最多lgN，最坏的情况下find()、union()的成本的增长数量级为lgN。改进quick-union算法的不足，保证运行时间是对数级别。</p>
<h3 id="路径压缩的加权quic-union算法">路径压缩的加权quic-union算法</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> sz<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>

  <span style="color:#75715e">// 其他方法参考加权quick-union算法和初步实现
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">int</span> root <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
		<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> id<span style="color:#f92672">[</span>root<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
			root <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>root<span style="color:#f92672">];</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">int</span> newp <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
			id<span style="color:#f92672">[</span>p<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
			p <span style="color:#f92672">=</span> newp<span style="color:#f92672">;</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>

</code></pre></div><p>分析：在加权quick-union的基础上，再进一步改进，所访问的触点向上找到根节点的同时把检查的所有触点直接与根节点连接，使得树更加扁平，可以说是最优算法了，union()和find()最坏情况下存在N触点的增长数量级非常接近1但未到的程度。</p>

</div>


    </main>

    
      
    
  </body>
</html>
