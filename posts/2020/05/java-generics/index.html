<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Java泛型 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="Java编程思想读书笔记——泛型" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>Java泛型</h1>
  <span class="post-date">
    2020-05-03 23:29 &nbsp;
    字数：<strong>1803</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
  </span>

  <p>有些一些方法处理不同类型，这些方法之间只有操作的类型的不同，方法名相同，方法的行为相似甚至相同，那么可以使用参数化类型，也叫泛型，用一个方法就能处理不同类型，大大地减少了代码的重复，提高它的重用性。泛型能使问题的解决对类型能更加宽泛，即使是未来创建的类型，此方法依然运行。</p>
<p>泛型类如何表示类名后跟上尖括号，括号里面就是类型参数。</p>
<p>简单定义泛型：</p>
<pre><code>class Generic&lt;T&gt; {
    public T a;
    public void set(T b) { a = b; }
    public T get() { return a; }
    public void print() { System.out.println(a); }
    public static void main(String[] args) {
        Generic&lt;String&gt; gs = new Generic&lt;String&gt;();
        gs.set(&quot;String&quot;);
        gs.print();
        Generic&lt;Integer&gt; gi = new Generic&lt;Integer&gt;();
        gs.set(17);
        gs.set(new Integer(47));
        gs.print();
    }
}
</code></pre><p>基本类型不能赋予泛型，所以基本类型对应的包装类来赋予解决基本数据类型的问题</p>
<h2 id="泛型方法和泛型接口">泛型方法和泛型接口</h2>
<p>有时需要定义类的某些方法需要类型参数，而类不使用类型参数：</p>
<pre><code>class GenericMethod {
    public &lt;T&gt; void f(T t) {
        System.out.println(t.getClass().getName());
    }
}
</code></pre><p>在方法的返回类型前声明参数化类型，加括号里面有类型参数。由于static方法无法访问泛型类的类型参数，也要像泛型方法的定义获得泛型能力。</p>
<pre><code>import java.lang.reflect.*;
import java.util.regex.*;
class StaticGenericMethod&lt;T&gt; {
    public static &lt;T&gt; void f(T t) {
        Pattern p = Pattern.compile(&quot;\\w+\\.&quot;);
        for(Method m : t.getClass().getMethods())
            System.out.println(
                p.matcher(
                    m.toString()).replaceAll(&quot;&quot;));
    }
}
</code></pre><p>定义泛型接口和泛型类一样</p>
<pre><code>import java.util.*;
interface Generator&lt;T&gt; {
    T next();
}

class StringGenerator implements Generator&lt;String&gt;, Iterable&lt;String&gt; {
    static final String[] array = {
        &quot;张三&quot;, &quot;王二&quot;, &quot;李四&quot;,&quot;梁九&quot;
    };
    static final Random rand = new Random(47);
    public String next() {
        return array[rand.nextInt(4)];
    }
    public Iterator&lt;String&gt; iterator() {
        return new Iterator&lt;String&gt;() {
            int count = array.length;
            public boolean hasNext() { return count &gt; 0; }
            public String next() {
                count--;
                return array[count];
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
     public static void main(String[] args) throws Exception {
        StringGenerator sg = new StringGenerator();
        System.out.println(sg.next());
        Iterator&lt;String&gt; it = sg.iterator();
        while(it.hasNext()) {
            String s = it.next();
            System.out.print(s + &quot; &quot;);
        }
        System.out.println();
        for(String s : sg)
            System.out.print(s + &quot; &quot;);
    }
}
</code></pre><p>StringGenerator分别实现自定义泛型接口Generator&lt; T &gt;和内建的泛型接口Iterable&lt; T &gt;。显然有实现自定义数据类型的迭代功能要实现Iterable&lt; T &gt;接口，StringGenerator就可以用于foeach语句。</p>
<p>Arrays有给数组排序的功能，如果是自定义的数据类型数组如何排序，元素类型因无法比较，就不能排大小。可以即将定义的元素类型实现Comparable&lt; T &gt;接口，如果是已定的元素类型，则另外实现一个Comparator&lt; T &gt;接口。<em>如何实现Comparator&lt; T &gt;见我数组那章笔记</em>。</p>
<pre><code>import java.util.*;
import java.lang.reflect.*;
class Dog implements Comparable&lt;Dog&gt; {
    public String name;
    public int age;
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public int compareTo(Dog o) {
        return age &lt; o.age ? -1 : (age == o.age ? 0 : 1);
    }
    public String toString() {
        return &quot;name:&quot; + name + &quot; age:&quot; + age;
    }
    public static void main(String[] args) {
        Dog[] dogs = (Dog[])Array.newInstance(Dog.class, 3);
        dogs[0] = new Dog(&quot;狗大&quot;, 13);
        dogs[1] = new Dog(&quot;狗二&quot;, 7);
        dogs[2] = new Dog(&quot;狗三&quot;, 2);
        System.out.println(Arrays.toString(dogs));
        Arrays.sort(dogs);
        System.out.println(Arrays.toString(dogs));
    }
}
</code></pre><h2 id="通配符">通配符</h2>
<p>无界通配符&lt;?&gt;表示某种特定类型;超类通配符&lt;? super T&gt;或&lt;? super MyClass&gt;,由某个特定类的基类来界定类型参数，它规定类型的下界;
子类通配符&lt;? extends T&gt;或&lt;? extends MyClass&gt;，由某种特定类的子类来界定类型参数，规定了类型的上界。通配符用在方法的泛型类参数或泛型类变量声明上。</p>
<p>就如:</p>
<pre><code>// 假设定义类Fruit及其子类Apple,下面的代码在某个类内部

List&lt;?&gt; fruits = new ArrayList&lt;Fruit&gt;();

void write(List&lt;? super Fruit&gt; fruit, Fruit newFruit) {
    fruit.add(newFruit);
}

Fruit write(List&lt;? extends Fruit&gt; fruit, int i) {
    return fruit.get(i);
}
</code></pre><p>由于擦除的影响，泛型在使用过程中，JVM不知道泛型类内部具体类型参数是什么类型，而是都看成Object。类型参数的变量在内存中是以Object形式存储，内部操作都看成是对Object的操作，这些变量在方法返回或传入时，即在类的外界使用时才会了解具体的类型，那么在方法返回时值进行自动转型。</p>
<p>擦除还影响类型参数不能引用运行时类型操作，如转型、instanceof操作、new表达式等等。</p>
<p>擦除的目的是为了向前兼容，容器类在JavaSE5之前是非泛型版本，元素类型就是Object，帮助之前非泛型类库依旧能正常使用。再强调一遍，泛型类型只有静态类型检查(前面提到的方法的接受参数和返回值)才能发挥它的作用。运行时，内部的类型参数被擦除为Object。通配符就是为了让类型信息擦除非得为Object，可以是你规定的边界。</p>
<p>擦除的补偿，使用类型标签(Class类)补偿，Class类可以很好帮助泛型类内部实现以下操作，如创建泛型数组，<code>Array.newInstance(Class&lt;?&gt; type, int length)</code>;动态使用<code>isInstance(Object)</code>来代替instanceof静态检查对象是否属于某个类型;动态使用<code>newInstance()</code>来代替new表达式创建类型参数的对象。</p>

</div>


    </main>
    <button class="backtop-btn">
<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
</svg>
</button>
    
      
    
  </body>
</html>
