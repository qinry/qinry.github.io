<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>背包、栈、队列实现 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="线性数据结构的实现和相关算法的描述" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script>
    hljs.highlightAll();
</script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>背包、栈、队列实现</h1>
  <span class="post-date">
    2020-05-06 08:24 &nbsp;
    字数：<strong>2278</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/algorithm/">Algorithm</a>&nbsp;
  </span>

  <p>API:</p>
<p>背包</p>
<p><code>public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bag()</td>
<td style="text-align:center">创建一个空包</td>
</tr>
<tr>
<td>void add(Item item)</td>
<td style="text-align:center">添加一个元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">背包是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">背包中的元素数量</td>
</tr>
</tbody>
</table>
<hr>
<p>先进先出队列(FIFO)</p>
<p><code>public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Queue()</td>
<td style="text-align:center">创建一个空队列</td>
</tr>
<tr>
<td>void enqueue(Item item)</td>
<td style="text-align:center">添加一个元素</td>
</tr>
<tr>
<td>Item dequeue()</td>
<td style="text-align:center">删除最早添加的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">队列中的元素数量</td>
</tr>
</tbody>
</table>
<hr>
<p>下压栈(LIFO)</p>
<p><code>public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stack()</td>
<td style="text-align:center">创建一个空栈</td>
</tr>
<tr>
<td>void push(Item item)</td>
<td style="text-align:center">添加一个元素</td>
</tr>
<tr>
<td>Item pop()</td>
<td style="text-align:center">删除最近添加的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">栈是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">栈中的元素数量</td>
</tr>
</tbody>
</table>
<h2 id="一栈">一、栈</h2>
<h3 id="1数组实现">1.数组实现</h3>
<h4 id="11定容栈">1.1定容栈</h4>
<pre><code>import java.lang.reflect.Array;
import java.util.Scanner;
import java.util.Iterator;

public class FixedCapacityOfStack&lt;Item&gt; implements Iterable&lt;Item&gt; {
    private Item[] a; // stack entries
    private int N; // size
    @SuppressWarnings(&quot;unchecked&quot;)
    public FixedCapacityOfStack(Class&lt;Item&gt; type, int size) {
        a = (Item[])Array.newInstance(type, size);  
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public FixedCapacityOfStack(int size) {
        a = (Item[])new Object[size];
    }
    public boolean isEmpty() { return N == 0;}
    public int size() { return N; }
    public void push(Item item) {
        a[N++] = item;
    }
    public Item pop() {
        Item item = a[--N];
        a[N] = null;// 防止对象流离
        return item;
    }
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private int i = N;
            public boolean hasNext() {
                return i &gt; 0;
            }
            public Item next()  {
                if(i == 0) throw new NoSuchElementException();
                return a[--i];
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
    public static void main(String[] args) {
        FixedCapacityOfStack&lt;String&gt; s =
            new FixedCapacityOfStack&lt;String&gt;();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            String item = in.next();
            if(!item.equals(&quot;-&quot;))
                s.push(item);
            else if(!s.isEmpty()) System.out.print(s.pop() + &quot; &quot;);
        }
        System.out.println(&quot;(&quot; + s.size() + &quot; left on stack)&quot;);
    }
}
</code></pre><h4 id="12动态调整数组大小的实现">1.2动态调整数组大小的实现</h4>
<pre><code>import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt; {
    @SuppressWarnings(&quot;unchecked&quot;)
    private Item[] a = (Item[])new Object[1]; // stack entries
    private int N = 0; // size
    @SuppressWarnings(&quot;unchecked&quot;)
    private void resize(int max) {
        Item[] temp = (Item[])new Object[max];
        for(int i = 0; i &lt; N; i++)
            temp[i] = a[i];
            a = temp;
    }
    public boolean isEmpty() { return N == 0;}
    public int size() { return N; }
    public void push(Item item) {
        if(N == a.length) resize(2*a.length);
        a[N++] = item;
    }
    public Item pop() {
        Item item = a[--N];
        a[N] = null;
        if(N &gt; 0 &amp;&amp; N == a.length/4) resize(a.length/2);
        return item;
    }
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private int i = N;
            public boolean hasNext() {
                return i &gt; 0;
            }
            public Item next()  {
                if(i == 0) throw new NoSuchElementException();
                return a[--i];
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
    public static void main(String[] args) {
        ResizingArrayStack&lt;String&gt; s =
            new ResizingArrayStack&lt;String&gt;();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            String item = in.next();
            if(!item.equals(&quot;-&quot;))
                s.push(item);
            else if(!s.isEmpty()) System.out.print(s.pop() + &quot; &quot;);
        }
        System.out.println(&quot;(&quot; + s.size() + &quot; left on stack)&quot;);
    }
}
</code></pre><h3 id="2链表实现">2.链表实现</h3>
<pre><code>import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; {
    private Node first; // the top of stack
    private int N;// size
    private class Node {
        Item item;
        Node next;
    }
    public boolean isEmpty() {return first == null; }
    public int size() { return N; }
    public void push(Item item) {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    public Item pop() {
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
    @Override
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private Node current = first;
            public boolean hasNext() {
                return current != null;
            }
            public Item next() {
                if(current == null) throw new NoSuchElementException();
                Item item = current.item;
                current = current.next;
                return item;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
    public static void main(String[] args) {
        Stack&lt;String&gt; s = new Stack&lt;String&gt;();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            String item = in.next();
            if(!item.equals(&quot;-&quot;))
                s.push(item);
            else if(!s.isEmpty()) System.out.print(s.pop() + &quot; &quot;);
        }
        System.out.println(&quot;(&quot; + s.size() + &quot; left on stack)&quot;);
    }
}
</code></pre><h2 id="二队列">二、队列</h2>
<h3 id="1-动态调整大小的数组实现">1. 动态调整大小的数组实现</h3>
<pre><code>import java.util.Iterator;
import java.util.Scanner;
public class ResizingArrayQueue&lt;Item&gt; implements Iterable&lt;Item&gt; {
    @SuppressWarnings(&quot;unchecked&quot;)
    private Item[] a = (Item[])new Object[1];
    private int head = 0, tail = 0;
    private int N = 0; // size
    @SuppressWarnings(&quot;unchecked&quot;)
    private void resize(int max) {
        Item[] temp = (Item[])new Object[max];
        int j = head;
        for(int i = 0; i &lt; N; i++, j++) {
            if(j == a.length )
                j = 0;
            temp[i] = a[j];
        }
        a = temp;
        head = 0;
        tail = N - 1;
    }
    public int size() { return N;}
    public boolean isEmpty() { return N == 0; }
    public void enqueue(Item item) {
        if(N == a.length) resize(2 * a.length);
        a[tail++] = item;
        if(tail == a.length)
            tail = 0;
        N++;
    }
    public Item dequeue() {
        Item item = a[head];
        a[head++] = null;// 防止对象琉璃
        if(head == a.length)
            head = 0;
        N--;
        if(N &gt; 0 &amp;&amp; N == a.length/4) resize(a.length/2);
        return item;
    }
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private int i = head;
            public boolean hasNext() {
                return i != tail;
            }
            public Item next() {
                if(i == a.length)
                    i = 0;
                return a[i++];
            }
            public void remove() {}
        };
    }
    public static void main(String[] args) throws Exception {
        ResizingArrayQueue&lt;String&gt; q =
            new ResizingArrayQueue&lt;String&gt;();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            String item = in.next();
            if(!item.equals(&quot;-&quot;))
                q.enqueue(item);
            else if(!q.isEmpty()) System.out.print(q.dequeue() + &quot; &quot;);
        }
        System.out.println(&quot;(&quot; + q.size() + &quot; left on queue)&quot;);
    }
}
</code></pre><h3 id="2-链表实现">2. 链表实现</h3>
<pre><code>import java.util.Scanner;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; {
    private Node first;
    private Node last;
    private int N;
    private class Node {
        Item item;
        Node next;
    }
    public boolean isEmpty() { return first == null; }
    public int size() { return N; }
    public void enqueue(Item item) {
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if(isEmpty()) first = last;
        else oldlast .next = last;
        N++;
    }
    public Item dequeue() {
        Item item = first.item;
        first = first.next;
        if(isEmpty()) last = null;
        N--;
        return item;
    }
    @Override
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private Node current = first;
            public boolean hasNext() {
                return current != null;
            }
            public Item next() {
                if(current == null)
                    throw new NoSuchElementException();
                Item item = current.item;
                current = current.next;
                return item;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
    public static void main(String[] args) {
        Queue&lt;String&gt; q = new Queue&lt;String&gt;();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            String item = in.next();
            if(!item.equals(&quot;-&quot;))
                q.enqueue(item);
            else if(!q.isEmpty()) System.out.print(q.dequeue() + &quot; &quot;);
        }
        System.out.println(&quot;(&quot; + q.size() + &quot; left on queue)&quot;);
    }
}
</code></pre><h2 id="三背包">三、背包</h2>
<pre><code>import java.util.Iterator;
import java.util.NoSuchElementException;
public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; {
    private Node first;
    private int N;
    private class Node {
        Item item;
        Node next;
    }
    public void add(Item item) {
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    public boolean isEmpty() { return first == null; }
    public int size() { return N; };
    @Override
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private Node current = first;
            public boolean hasNext() {
                return current != null;
            }
            public Item next() {
                if(current == null)
                    throw new NoSuchElementException();
                Item item = current.item;
                current = current.next;
                return item;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }
}
</code></pre><h2 id="运用例子">运用例子</h2>
<h3 id="dijkstra的双栈算术表达式求值算法">Dijkstra的双栈算术表达式求值算法</h3>
<p>考虑未省略括号的表达式，以求简单，省略括号的表达式要添加处理相应的优先级规则</p>
<pre><code>import java.util.Scanner;
public class Evaluate {
public static void main(String[] args) {
        Stack&lt;String&gt; ops = new Stack&lt;String&gt;(); // 操作符栈
        Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;(); // 操作数栈
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            // Windows下，扫描完成时ctrl + z，才会返回结果
            // Linux下，扫描完成时ctrl + d, 才返回结果
            String s = in.next();
            if(s.equals(&quot;(&quot;)) continue;
            else if(s.equals(&quot;+&quot;))    ops.push(s);
            else if(s.equals(&quot;-&quot;))    ops.push(s);
            else if(s.equals(&quot;*&quot;))    ops.push(s);
            else if(s.equals(&quot;/&quot;))    ops.push(s);
            else if(s.equals(&quot;sqrt&quot;)) ops.push(s);
            else if(s.equals(&quot;)&quot;)) {
                String op = ops.pop();
                double v = vals.pop();
                if(op.equals(&quot;+&quot;))         v = vals.pop() + v;
                else if(op.equals(&quot;-&quot;))    v = vals.pop() - v;
                else if(op.equals(&quot;*&quot;))    v = vals.pop() * v;
                else if(op.equals(&quot;/&quot;))    v = vals.pop() / v;
                else if(op.equals(&quot;sqrt&quot;)) v = Math.sqrt(v);
                vals.push(v);
            }
            else vals.push(Double.parseDouble(s));
        }
       System.out.println(vals.pop());
    }
}

</code></pre><h3 id="中序表达式转为后序表达式">中序表达式转为后序表达式</h3>
<h4 id="不考虑优先级">不考虑优先级</h4>
<pre><code>import java.util.Scanner;
public class InfixToPostfix {
    public static void main(String[] args) {
        Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
        Scanner stdin = new Scanner(System.in );
        while (stdin.hasNext()) {
            String s = stdin.next();
            if      (s.equals(&quot;+&quot;)) stack.push(s);
            else if (s.equals(&quot;*&quot;)) stack.push(s);
            else if (s.equals(&quot;)&quot;)) System.out.print(stack.pop() + &quot; &quot;);
            else if (s.equals(&quot;(&quot;)) System.out.print(&quot;&quot;);
            else System.out.print(s + &quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><h4 id="考虑优先级">考虑优先级</h4>
<pre><code>import java.util.Scanner;
import java.util.TreeMap;
public class InfixToPostfixWithPrecedence {
    public static void main(String[] args) {
        Scanner stdin = new Scanner(System.in);
        Stack&lt;String&gt; stack = new Stack&lt;String&gt;();

        TreeMap&lt;String, Integer&gt; precedence = new TreeMap&lt;String, Integer&gt;();
        precedence.put(&quot;(&quot;, 0);
        precedence.put(&quot;)&quot;, 0);
        precedence.put(&quot;+&quot;, 1);
        precedence.put(&quot;-&quot;, 1);
        precedence.put(&quot;*&quot;, 2);
        precedence.put(&quot;/&quot;, 2);

        while(stdin.hasNext()) {
            String s = stdin.next();
            if(!precedence.containsKey(s)) {
                System.out.print(s + &quot; &quot;);
                continue;
            }
            while(true) {
                if(stack.isEmpty() || s.equals(&quot;(&quot;)) {
                    stack.push(s);
                    break;
                } else if(s.equals(&quot;)&quot;)) {
                    System.out.print(stack.pop() + &quot; &quot;);
                    if(stack.peek().equals(&quot;(&quot;)) {
                        stack.pop();
                        break;
                    }
                } else if(precedence.get(s) &gt; precedence.get(stack.peek())) {
                        stack.push(s);
                        break;
                } else {
                        System.out.print(stack.pop() + &quot; &quot;);
                }
            }
        }
    }
    while(!stack.isEmpty())
    System.out.print(stack.pop() + &quot; &quot;);
    stdin.close();
    }
}
</code></pre><h3 id="求后序表达式值">求后序表达式值</h3>
<pre><code>import java.util.Scanner;
public class EvaluatePostfix {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        Scanner stdin = new Scanner(System.in );
        while (stdin.hasNext()) {
            String s = stdin.next();
            if(s.equals(&quot;+&quot;)) {
                int val = stack.pop();
                stack.push(stack.pop() + val);
            } else if (s.equals(&quot;*&quot;)) {
                int val = stack.pop();
                stack.push(stack.pop() * val);
            } else if(s.equals(&quot;-&quot;)) {
                int val = stack.pop();
                stack.push(stack.pop() - val);
            } else if(s.equals(&quot;/&quot;)) {
                int val = stack.pop();
                stack.push(stack.pop() / val);
            }
            else stack.push(Integer.parseInt(s));
        }
        StdOut.println(stack.pop());
    }
}
</code></pre><h3 id="带有优先级的中序表达式求值">带有优先级的中序表达式求值</h3>
<pre><code>import java.util.Scanner;
import java.util.TreeMap;
public class EvaluateDeluxe {
    public static double eval(String op, double val1, double val2) {
        if (op.equals(&quot;+&quot;)) return val1 + val2;
        if (op.equals(&quot;-&quot;)) return val1 - val2;
        if (op.equals(&quot;/&quot;)) return val1 / val2;
        if (op.equals(&quot;*&quot;)) return val1 * val2;
        throw new RuntimeException(&quot;Invalid operator&quot;);
    }

    public static void main(String[] args) {
        TreeMap&lt;String, Integer&gt; precedence = new TreeMap&lt;String, Integer&gt;();
        precedence.put(&quot;(&quot;, 0);
        precedence.put(&quot;)&quot;, 0);  
        precedence.put(&quot;+&quot;, 1);
        precedence.put(&quot;-&quot;, 1);
        precedence.put(&quot;*&quot;, 2);
        precedence.put(&quot;/&quot;, 2);

        Stack&lt;String&gt; ops  = new Stack&lt;String&gt;();
        Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;();

        Scanner stdin = new Scanner(System.in);
        while (stdin.hasNext()) {

            String s = stdin.next();

            // 处理数字
            if (!precedence.containsKey(s)) {
                vals.push(Double.parseDouble(s));
                continue;
            }

            // 处理符号
            while (true) {
                if (ops.isEmpty() || s.equals(&quot;(&quot;) || (precedence.get(s) &gt; precedence.get(ops.peek()))) {
                    ops.push(s);
                    break;
                }

                // 计算表达式
                String op = ops.pop();

                if (op.equals(&quot;(&quot;)) {
                    assert s.equals(&quot;)&quot;);
                    break;
                }

                else {
                    double val2 = vals.pop();
                    double val1 = vals.pop();
                    vals.push(eval(op, val1, val2));
                }
            }
        }

        while (!ops.isEmpty()) {
            String op = ops.pop();
            double val2 = vals.pop();
            double val1 = vals.pop();
            vals.push(eval(op, val1, val2));
        }

        System.out.println(vals.pop());
        assert vals.isEmpty();
        assert ops.isEmpty();
    }
}
</code></pre><h3 id="约瑟夫问题">约瑟夫问题</h3>
<pre><code>public class Josephus {
    public static void main(String[] args) {
        int arg1 = Integer.parseInt(args[0]);
        int arg2 = Integer.parseInt(args[1]);
        Queue&lt;Integer&gt; q = new Queue&lt;Integer&gt;();
        for(int i = 0; i &lt; arg1; i++) {
            q.enqueue(i);
        }

        while(!q.isEmpty()) {
            for(int i = 1; i &lt; arg2; i++)
                q.enqueue(q.dequeue());
            System.out.print(q.dequeue() + &quot; &quot;);
        }
    }
}

</code></pre><h3 id="平衡括号">平衡括号</h3>
<pre><code>import java.util.Scanner;
public class Parentheses {
    private static final char LEFT_PAREN     = '(';
    private static final char RIGHT_PAREN    = ')';
    private static final char LEFT_BRACE     = '{';
    private static final char RIGHT_BRACE    = '}';
    private static final char LEFT_BRACKET   = '[';
    private static final char RIGHT_BRACKET  = ']';

    public static boolean isBalanced(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();
        for (int i = 0; i &lt; s.length(); i++) {
            if (s.charAt(i) == LEFT_PAREN)   stack.push(LEFT_PAREN);
            if (s.charAt(i) == LEFT_BRACE)   stack.push(LEFT_BRACE);
            if (s.charAt(i) == LEFT_BRACKET) stack.push(LEFT_BRACKET);

            if (s.charAt(i) == RIGHT_PAREN) {
                if (stack.isEmpty())           return false;
                if (stack.pop() != LEFT_PAREN) return false;
            }

            else if (s.charAt(i) == RIGHT_BRACE) {
                if (stack.isEmpty())           return false;
                if (stack.pop() != LEFT_BRACE) return false;
            }

            else if (s.charAt(i) == RIGHT_BRACKET) {
                if (stack.isEmpty())             return false;
                if (stack.pop() != LEFT_BRACKET) return false;
            }
        }
        return stack.isEmpty();
    }


    public static void main(String[] args) {
        Scanner stdin = new Scanner(System.in);
        String s = stdin.nextLine().trim();
        System.out.println(isBalanced(s));
    }
}

</code></pre><h3 id="十进制转二进制">十进制转二进制</h3>
<pre><code>public class DecToBin {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();
        while (n &gt; 0) {
            s.push(n % 2);
            n = n / 2;
        }
        while (!s.isEmpty())
            System.out.print(s.pop());
        System.out.println();
    }
}
</code></pre>
</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
