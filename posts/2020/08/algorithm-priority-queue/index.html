<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>优先队列的实现 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="学习二叉堆、大顶堆、小顶堆的实现" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/styles/base16/monokai.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>

<script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <span id="top"></span>
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>优先队列的实现</h1>
  <span class="post-date">
    2020-08-06 21:36 &nbsp;
    字数：<strong>1437</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/algorithm/">Algorithm</a>&nbsp;
  </span>

  <h2 id="最大优先队列">最大优先队列</h2>
<p><strong>API:</strong>
<code>public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MaxPQ(int max)</td>
<td style="text-align:center">创建一个初始容量为max的优先队列</td>
</tr>
<tr>
<td>void insert(Key x)</td>
<td style="text-align:center">向优先队列插入一个元素</td>
</tr>
<tr>
<td>Key delMax()</td>
<td style="text-align:center">删除最大元素并返回最大元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">返回队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">返回优先队列的元素个数</td>
</tr>
</tbody>
</table>
<pre><code>public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; {
    private Key[] pq;                    // 基于堆的完全二叉树
    private int N = 0;                   // 存储于pq[1..N]中，pq[0]没有使用

    public MaxPQ(int maxN) {
        pq = (Key[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return n == 0;
    }

    public int size() {
        return N;
    }

    public Key max() {
        if (isEmpty()) throw new NoSuchElementException(&quot;Priority queue underflow&quot;);
        return pq[1];
    }

    public void insert(Key x) {

        pq[++n] = x;
        swim(n);
    }

    public Key delMax() {
        Key max = pq[1]; // 从根结点得到最大元素
        exch(1, N--); // 将其和最后一个结点交换
        pq[n+1] = null; //防止对象游离
        sink(1); // 恢复堆的有序性
        return max;
    }

    // 辅助方法
    private void swim(int k) {
        while (k &gt; 1 &amp;&amp; less(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k &lt;= n) {
            int j = 2*k;
            if (j &lt; n &amp;&amp; less(j, j+1)) j++;
            if (!less(k, j)) break;
            exch(k, j);
            k = j;
        }
    }

    private boolean less(int i, int j) {
      return pq[i].compareTo(pq[j]) &lt; 0;
    }

    private void exch(int i, int j) {
        Key swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
    }

}

</code></pre><hr>
<h2 id="最小优先队列">最小优先队列</h2>
<p><strong>API:</strong></p>
<p><code>public class MinPQ&lt;Key extends Comparable&lt;Key&gt;&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MinPQ(int max)</td>
<td style="text-align:center">创建一个初始容量为max的优先队列</td>
</tr>
<tr>
<td>void insert(Key x)</td>
<td style="text-align:center">向优先队列插入一个元素</td>
</tr>
<tr>
<td>Key delMin()</td>
<td style="text-align:center">删除最小元素并返回最小元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">返回队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">返回优先队列的元素个数</td>
</tr>
</tbody>
</table>
<pre><code>public class MinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; {
	 private Key[] pq;
   private int N=0;

    public MinPQ(int initCapacity) {
        pq = (Key[]) new Comparable[initCapacity + 1];
    }

    public Key delMin() {
        Key min = pq[1];
        exch(1, N--);
        pq[N+1] = null;     
        sink(1);
        return min;
    }

    private void swim(int k) {
        while (k &gt; 1 &amp;&amp; greater(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k &lt;= n) {
            int j = 2*k;
            if (j &lt; n &amp;&amp; greater(j, j+1)) j++;
            if (!greater(k, j)) break;
            exch(k, j);
            k = j;
        }
    }
    private boolean greater(int i, int j) {
      return (pq[i]).compareTo(pq[j]) &gt; 0;
    }


    // isEmpty()、size()、insert()、exch()于MaxPQ的方法一样
}
</code></pre><hr>
<h2 id="索引最小优先队列">索引最小优先队列</h2>
<p><strong>API:</strong></p>
<p><code>public class IndexMinPQ&lt;Item extends Comparable&lt;Item&gt;&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexMinPQ(int maxN)</td>
<td style="text-align:center">创建一个初始容量为max的优先队列</td>
</tr>
<tr>
<td>void insert(int k, Item item)</td>
<td style="text-align:center">插入一个元素，将它和索引k相关联</td>
</tr>
<tr>
<td>void change(int k, Item item)</td>
<td style="text-align:center">将索引k的元素设备item</td>
</tr>
<tr>
<td>boolean contains(int k)</td>
<td style="text-align:center">是否存在索引为k的元素</td>
</tr>
<tr>
<td>void delete(int k)</td>
<td style="text-align:center">删去索引k及其相关联的元素</td>
</tr>
<tr>
<td>Item min()</td>
<td style="text-align:center">返回最小元素</td>
</tr>
<tr>
<td>int minIndex()</td>
<td style="text-align:center">返回最小元素的索引</td>
</tr>
<tr>
<td>int delMin()</td>
<td style="text-align:center">删除最大元素并返回它的索引</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">返回队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">返回优先队列的元素个数</td>
</tr>
</tbody>
</table>
<pre><code>public class IndexMinPQ&lt;Item extends Comparable&lt;Item&gt;&gt;{
	private int N; // PQ中元素数量
	private int[] pq; // 索引二叉堆，由1开始
	private int[] qp; // 逆序：qp[pq[i]] = pq[qp[i]] = i
	private Item[] items; // 有优先级之分的元素
	public IndexMinPQ(int maxN) {
		items = (Item[])new Comparable[maxN + 1];
		pq = new int[maxN + 1];
		qp = new int[maxN + 1];
		for(int i = 0; i &lt;= maxN; i++) qp[i] = -1;
	}

	public boolean isEmpty() {
		return N == 0;
	}

	public int size() {
		return N;
	}

	public boolean contains(int k) {
		return qp[k] != -1;
	}

	public void insert(int k, Item item) {
		N++;
		qp[k] = N;
		pq[N] = k;
	  items[i] = item;
		swim(N);
	}

	public Item min() {
		return items[pq[1]];
	}

	public int delMin() {
		int indexOfMin = pq[1];
		exch(1, N--);
		sink(1);
		items[pq[N+1]] = null;
		qp[pq[N+1]] = -1;
		return indexOfMin;
	}

	public int minIndex() {
		return pq[1];
	}

	public void change(int k, Item item) {
		items[k] = item;
    swim(qp[k]);
    sink(qp[k]);
	}


	public void delete(int k) {
		int index = qp[k];
		exch(index, N--);
		swim(index);
		sink(index);
		items[k] = null;
		qp[k] = -1;
	}

	private void swim(int k) {
		while(k &gt; 1 &amp;&amp; greater(k/2, k)) {
			exch(k, k/2);
			k = k/2;
		}
	}

	private void sink(int k) {
		while(2*k &lt;= n) {
			int j = 2*k;
			if(j &lt; n &amp;&amp; greater(j, j + 1)) j++;
			if(!greater(k, j)) break;
			exch(k, j);
			k = j;
		}
	}

	private boolean greater(int i, int j) {
		return items[pq[i]].compareTo(items[pq[j]]) &gt; 0;
	}

	private void exch(int i, int j) {
		int swap = pq[i];
		pq[i] = pq[j];
		pq[j] = swap;
		qp[pq[i]] = i;
		qp[pq[j]] = j;
	}
</code></pre><hr>
<h2 id="索引最大优先队列">索引最大优先队列</h2>
<p><strong>API:</strong></p>
<p><code>public class IndexMaxPQ&lt;Item extends Comparable&lt;Item&gt;&gt;</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IndexMaxPQ(int maxN)</td>
<td style="text-align:center">创建一个初始容量为max的优先队列</td>
</tr>
<tr>
<td>void insert(int k, Item item)</td>
<td style="text-align:center">插入一个元素，将它和索引k相关联</td>
</tr>
<tr>
<td>void change(int k, Item item)</td>
<td style="text-align:center">将索引k的元素设备item</td>
</tr>
<tr>
<td>boolean contains(int k)</td>
<td style="text-align:center">是否存在索引为k的元素</td>
</tr>
<tr>
<td>void delete(int k)</td>
<td style="text-align:center">删去索引k及其相关联的元素</td>
</tr>
<tr>
<td>Item max()</td>
<td style="text-align:center">返回最小元素</td>
</tr>
<tr>
<td>int maxIndex()</td>
<td style="text-align:center">返回最小元素的索引</td>
</tr>
<tr>
<td>int delMax()</td>
<td style="text-align:center">删除最大元素并返回它的索引</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td style="text-align:center">返回队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td style="text-align:center">返回优先队列的元素个数</td>
</tr>
</tbody>
</table>
<pre><code>public class IndexMaxPQ&lt;Item extends Comparable&lt;Item&gt;&gt; {
	private int N;
	private int[] pq;
	private int[] qp;  
	private Item[] items;

	public IndexMaxPQ(int maxN) {
		items = (Item[])new Comparable[maxN + 1];
		pq = new int[maxN + 1];
		qp = new int[maxN + 1];
		for(int i = 0; i &lt;= maxN; i++)
			qp[i] = -1;
	}

	public int maxIndex() {
		return pq[1];
	}

	public Item max()) {
		return items[pq[1]];
	}

	public int delMax() {
		int indexMax = pq[1];
		exch(1, N--);
		sink(1);
		items[pq[N+1]] = null;
		qp[pq[N+1]] =  -1;
		return indexMax;
	}

  private void swim(int k) {
      while (k &gt; 1 &amp;&amp; less(k/2, k)) {
          exch(k, k/2);
          k = k/2;
      }
  }

  private void sink(int k) {
      while (2*k &lt;= n) {
          int j = 2*k;
          if (j &lt; n &amp;&amp; less(j, j+1)) j++;
          if (!less(k, j)) break;
          exch(k, j);
          k = j;
      }
  }

	private boolean less(int i, int j) {
		return items[pq[i]].compareTo(keys[pq[j]]) &lt; 0;
	}

  // insert()、change()、contains()、delete()、isEmpty()、size()、和exch()与IndexMinPQ的一样
}
</code></pre><hr>
<h2 id="参考">参考</h2>
<ul>
<li>《算法》第四版</li>
</ul>

</div>


    </main>
    <a href="#top" class="backtop">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
    </svg>
</a>
    
      
    
  </body>
</html>
