<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.85.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Java对象序列化 &middot; 欢迎来到槎城小子的博客！</title>
  <meta name="description" content="Java编程思想读书笔记——序列化和反序列化" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/copy-code-button.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/toc.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/backtop.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/tabs.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="../../../../favicon.png">

  
  <link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/styles/base16/solarized-light.min.css" rel="stylesheet">

<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/properties.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/powershell.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/groovy.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.2.0/languages/gradle.min.js"></script>

<script src="../../../../jquery/jquery.min.js"></script>

<script src="../../../../js/copy-code-button.js"></script>
<script src="../../../../js/main.js"></script>


</head>

  <body class="theme-base-0d ">
    <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>欢迎来到槎城小子的博客！</h1></a>
      <p class="lead">
       不积硅步无以至千里，不积小流无以成江海。 
      </p>
    </div>
    
    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="https://github.com/qinry"> Github </a></li><li><a href="../../../../tags"> 分类标签 </a></li>
      </ul>
    </nav>

    <p>Copyright © 2021 槎城小子</p>
  </div>
</aside>

    

    <main class="content container">
    <div class="post">

  <h1>Java对象序列化</h1>
  <span class="post-date">
    2020-04-28 16:01 &nbsp;
    字数：<strong>1465</strong> &nbsp;
    标签：
              <a href="https://qinry.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
  </span>

  <h2 id="持久性">持久性</h2>
<p>如果对象能够在程序不运行还能保存其状态信息。可以通过将信息写入文件或数据库来达到程序下次执行时，对象重建后与上次拥有一致的信息。在Java中一切都是对象的思想下，把对象声明为“持久性”，可以省去一些细节，对程序员是种方便。对象的序列化，可以理解为把对象导入到文件中，通过<code>Serialize</code>接口实现。通过导入文件能够反序列化还原对象，达到持久性的目的。该特性支持计算机的远程方法调用，还有帮助Java Bean在设计阶段保存配置信息，并在启动程序后恢复配置信息。如果要把一个对象序列化，实现<code>Serialize</code>接口就可以了，此接口只是标记接口，不含方法。</p>
<h2 id="序列化写入文件">序列化写入文件</h2>
<pre><code>//: io/StoreCADState.java
// Saving the state of a pretend CAD system.
import java.io.*;
import java.util.*;

abstract class Shape implements Serializable {
    public static final int RED = 1, BLUE = 2, GREEN = 3;
    private int xPos, yPos, dimension;
    private static Random rand = new Random(47);
    private static int counter = 0;
    public abstract void setColor(int newColor);
    public abstract int getColor();
    public Shape(int xVal, int yVal, int dim) {
        xPos = xVal;
        yPos = yVal;
        dimension = dim;
    }
    public String toString() {
        return getClass() +
        &quot;color[&quot; + getColor() + &quot;] xPos[&quot; + xPos +
        &quot;] yPos[&quot; + yPos + &quot;] dim[&quot; + dimension + &quot;]\n&quot;;
    }
    public static Shape randomFactory() {
        int xVal = rand.nextInt(100);
        int yVal = rand.nextInt(100);
        int dim = rand.nextInt(100);
        switch(counter++ % 3) {
        default:
        case 0: return new Circle(xVal, yVal, dim);
        case 1: return new Square(xVal, yVal, dim);
        case 2: return new Line(xVal, yVal, dim);
        }
    }
}

class Circle extends Shape {
    private static int color = RED;
    public Circle(int xVal, int yVal, int dim) {
        super(xVal, yVal, dim);
    }
    public void setColor(int newColor) { color = newColor; }
    public int getColor() { return color; }
}

class Square extends Shape {
    private static int color;
    public Square(int xVal, int yVal, int dim) {
        super(xVal, yVal, dim);
        color = RED;
    }
    public void setColor(int newColor) { color = newColor; }
    public int getColor() { return color; }
}

class Line extends Shape {
private static int color = RED;
public static void
serializeStaticState(ObjectOutputStream os)
throws IOException { os.writeInt(color); }
public static void
deserializeStaticState(ObjectInputStream os)
throws IOException { color = os.readInt(); }
public Line(int xVal, int yVal, int dim) {
    super(xVal, yVal, dim);
}
public void setColor(int newColor) { color = newColor; }
public int getColor() { return color; }
}

public class StoreCADState {
    public static void main(String[] args) throws Exception {
        List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes =
        new ArrayList&lt;Class&lt;? extends Shape&gt;&gt;();
        // Add references to the class objects:
        shapeTypes.add(Circle.class);
        shapeTypes.add(Square.class);
        shapeTypes.add(Line.class);
        List&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();
        // Make some shapes:
        for(int i = 0; i &lt; 10; i++)
        shapes.add(Shape.randomFactory());
        // Set all the static colors to GREEN:
        for(int i = 0; i &lt; 10; i++)
        ((Shape)shapes.get(i)).setColor(Shape.GREEN);
        // Save the state vector:
        ObjectOutputStream out = new ObjectOutputStream(
        new FileOutputStream(&quot;CADState.out&quot;));
        out.writeObject(shapeTypes);
        Line.serializeStaticState(out);
        out.writeObject(shapes);
        // Display the shapes:
        System.out.println(shapes);
    }
}
</code></pre><p>ObjectOutputStream的<code>writeObject(Object)</code>该方法先检查传入的Serialize对象是否实现了<code>private writeObject(ObjectOutputStream) throws IOException</code>方法(可以在其内部调用OjbectOutputStream的<code>defaultWriteObject()</code>)有会自动调用，接着序列化到ObjectOutputStream关联的文件上,如果要序列化保存<code>static</code>域，要自己手动创建一个方法来实现操作，如上的serializeStaticState()方法,还要注意维护对象写入序列化文件的顺序。在有部分不需要序列化的域标记为<code>transient</code>即可,它要在构造器初始化;想全部不需要所有的域可以实现<code>Externalizable</code>(继承了Serialize，没有transient那么的灵活控制不想序列化的域)，必须实现<code>writeExternal(ObjectOutput) throws IOException</code>和<code>readExternal(ObjectInput) throws IOException, ClassNotFoundException</code>这两个方法。</p>
<p>Output:</p>
<pre><code>[class Circlecolor[3] xPos[58] yPos[55] dim[93]
, class Squarecolor[3] xPos[61] yPos[61] dim[29]
, class Linecolor[3] xPos[68] yPos[0] dim[22]
, class Circlecolor[3] xPos[7] yPos[88] dim[28]
, class Squarecolor[3] xPos[51] yPos[89] dim[9]
, class Linecolor[3] xPos[78] yPos[98] dim[61]
, class Circlecolor[3] xPos[20] yPos[58] dim[16]
, class Squarecolor[3] xPos[40] yPos[11] dim[22]
, class Linecolor[3] xPos[4] yPos[83] dim[6]
, class Circlecolor[3] xPos[75] yPos[10] dim[42]
]
</code></pre>
<h2 id="读取文件反序列化">读取文件反序列化</h2>
<pre><code>//: io/RecoverCADState.java
// Restoring the state of the pretend CAD system.
// {RunFirst: StoreCADState}
import java.io.*;
import java.util.*;

public class RecoverCADState {
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(
        new FileInputStream(&quot;CADState.out&quot;));
        // Read in the same order they were written:
        List&lt;Class&lt;? extends Shape&gt;&gt; shapeTypes =
        (List&lt;Class&lt;? extends Shape&gt;&gt;)in.readObject();
        Line.deserializeStaticState(in);
        List&lt;Shape&gt; shapes = (List&lt;Shape&gt;)in.readObject();
        System.out.println(shapes);
    }
}
</code></pre><p>Output:</p>
<pre><code>[class Circlecolor[1] xPos[58] yPos[55] dim[93]
, class Squarecolor[0] xPos[61] yPos[61] dim[29]
, class Linecolor[3] xPos[68] yPos[0] dim[22]
, class Circlecolor[1] xPos[7] yPos[88] dim[28]
, class Squarecolor[0] xPos[51] yPos[89] dim[9]
, class Linecolor[3] xPos[78] yPos[98] dim[61]
, class Circlecolor[1] xPos[20] yPos[58] dim[16]
, class Squarecolor[0] xPos[40] yPos[11] dim[22]
, class Linecolor[3] xPos[4] yPos[83] dim[6]
, class Circlecolor[1] xPos[75] yPos[10] dim[42]
]
</code></pre>
<p>ObjectInputStream的<code>readObject()</code>会检查恢复的Serialize对象是否实现<code>private readObject() throws IOException, ClassNotFoundException</code>，有则自动调用, 接着返回要恢复的对象，根据序列化的顺序一样的次序，反序列化，注意类型的转换，<code>static</code>域的恢复也是要手动实现。</p>

</div>


    </main>
    <button class="backtop-btn">
<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="chevron-circle-up" class="svg-inline--fa fa-chevron-circle-up fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
    <path fill="currentColor" d="M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z">
    </path>
</svg>
</button>
    
      
    
  </body>
</html>
