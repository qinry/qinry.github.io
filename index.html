<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.79.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>qinry&#39;s blog</title>
  <meta name="description" content="在此写下学习日志，努力充电中～" />

  
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://qinry.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://qinry.github.io/index.xml" rel="alternate" type="application/rss+xml" title="qinry's blog" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qinry.github.io/"><h1>qinry&#39;s blog</h1></a>
      <p class="lead">
       在此写下学习日志，努力充电中～ 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://qinry.github.io/">Home</a> </li>
        <li><a href="/categories"> Categories </a></li><li><a href="https://github.com/qinry"> Github </a></li>
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2021-01-16-setup-de/">Java开发环境搭建与介绍</a>
  </h1>
  <time datetime="2021-01-16T19:11:45&#43;0800" class="post-date">Sat, Jan 16, 2021</time>
  一、环境搭建 开发Java工程离不开JDK（Java Development Kit Java开发工具包），这个是最基本的必须下载和安装，还有为了方便开发者编写、运行和调试
  
  <div class="read-more-link">
    <a href="/posts/2021-01-16-setup-de/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-11-16-designpatterns-singleton/">设计模式——单件模式</a>
  </h1>
  <time datetime="2020-11-16T08:08:26&#43;0800" class="post-date">Mon, Nov 16, 2020</time>
  单件模式 什么是单件模式 单件模式是在设计模式中常用的一种需要为类只实例化唯一对象的设计方案。意思是说，对于某个类来说，其对象只能创建一个，且每
  
  <div class="read-more-link">
    <a href="/posts/2020-11-16-designpatterns-singleton/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-08-06-algorithm-priority-queue/">优先队列的实现</a>
  </h1>
  <time datetime="2020-08-06T21:36:55&#43;0800" class="post-date">Thu, Aug 6, 2020</time>
  最大优先队列¶ API: public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; 方法 功能描述 MaxPQ(int max) 创建一个初始容量为max的优先队列 void insert(Key x) 向优先队列插入一个元素 Key delMax() 删除最大元素并返回最大元素 boolean isEmpty() 返
  
  <div class="read-more-link">
    <a href="/posts/2020-08-06-algorithm-priority-queue/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-08-06-algorithm-sort/">排序</a>
  </h1>
  <time datetime="2020-08-06T08:00:11&#43;0800" class="post-date">Thu, Aug 6, 2020</time>
  参考于《算法》第四版第二章 排序算法类的模板 public class Example { public static void sort(Comparable[] a){ // ... 见下面详解 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i];a[i] = a[j];a[j] = t; }
  
  <div class="read-more-link">
    <a href="/posts/2020-08-06-algorithm-sort/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-07-06-algorithm-union-find/">并查集的实现</a>
  </h1>
  <time datetime="2020-07-06T07:34:59&#43;0800" class="post-date">Mon, Jul 6, 2020</time>
  参考于《算法》第4版第一章第五节 问题描述：输入一对整数p、q，程序判断它们是否相连，如果相连，忽略这对数并处理下对数；否则将它们相连。p和q
  
  <div class="read-more-link">
    <a href="/posts/2020-07-06-algorithm-union-find/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-05-12-java-annotation/">注解</a>
  </h1>
  <time datetime="2020-05-12T22:06:42&#43;0800" class="post-date">Tue, May 12, 2020</time>
  定义注解 import java.lang.annotation.*; @Target(ElementType.METHOND) @Retention(RetentionPolicy.RUNTIME) public @interface UseCase { int id(); String description() default &#34;no description&#34;; } 使用注解 import java.util.*; public class PasswordUtils { @UseCase(id = 47, description = &#34;Passwords must contain at least one numeric&#34;) public boolean validatePassword(String passwd) { return (passwd.matches(&#34;\\w*\\d\\w*&#34;)); } @UseCase(id = 48) public String encryptPassword(String passwd) { return new StringBuilder(passwd) .reverse().toString(); } @UseCase(id = 49, description = &#34;New passwords
  
  <div class="read-more-link">
    <a href="/posts/2020-05-12-java-annotation/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-05-06-algorithm-basic-datastructure/">背包、栈、队列实现</a>
  </h1>
  <time datetime="2020-05-06T08:24:50&#43;0800" class="post-date">Wed, May 6, 2020</time>
  API: 背包 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; 方法 功能描述 Bag() 创建一个空包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 先进先出队列(FIFO) public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; 方法 功能描
  
  <div class="read-more-link">
    <a href="/posts/2020-05-06-algorithm-basic-datastructure/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-05-04-java-generics/">泛型</a>
  </h1>
  <time datetime="2020-05-03T23:29:33&#43;0800" class="post-date">Sun, May 3, 2020</time>
  有些一些方法处理不同类型，这些方法之间只有操作的类型的不同，方法名相同，方法的行为相似甚至相同，那么可以使用参数化类型，也叫泛型，用一个方法
  
  <div class="read-more-link">
    <a href="/posts/2020-05-04-java-generics/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-05-02-java-containers/">容器</a>
  </h1>
  <time datetime="2020-05-02T21:30:16&#43;0800" class="post-date">Sat, May 2, 2020</time>
  留意 此文列出一些有可能常用的api，肯定没有文档列的全也没必要全面，还有旨在会用这些操作容器的方法即可，要了解更多回看《Thinking in J
  
  <div class="read-more-link">
    <a href="/posts/2020-05-02-java-containers/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-05-02-java-arrays/">数组</a>
  </h1>
  <time datetime="2020-05-02T21:27:15&#43;0800" class="post-date">Sat, May 2, 2020</time>
  数组的优势，在于它存储和执行的效率，支持随机访问元素。不过，数组对象使用前它的大小是固定，不可改变。这意味着创建固定大小的数组，以后要扩大其
  
  <div class="read-more-link">
    <a href="/posts/2020-05-02-java-arrays/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-04-28-java-newio/">新I/O</a>
  </h1>
  <time datetime="2020-04-28T20:16:54&#43;0800" class="post-date">Tue, Apr 28, 2020</time>
  通道是数据存储的地方，缓冲器充当着通道与外部数据交换的媒介 通道Channel FileChannel可以通过FileOutputStream、
  
  <div class="read-more-link">
    <a href="/posts/2020-04-28-java-newio/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-04-28-java-file-iostream/">文件路径与I/O流</a>
  </h1>
  <time datetime="2020-04-28T17:42:29&#43;0800" class="post-date">Tue, Apr 28, 2020</time>
  File类 File类作用和它的名字不太相符，File除了可以代表一个特定的文件，还可以表示一个目录（包含一组文件），最准确认为是“路径”。还
  
  <div class="read-more-link">
    <a href="/posts/2020-04-28-java-file-iostream/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-04-28-java-serialize/">对象序列化</a>
  </h1>
  <time datetime="2020-04-28T16:01:24&#43;0800" class="post-date">Tue, Apr 28, 2020</time>
  持久性 如果对象能够在程序不运行还能保存其状态信息。可以通过将信息写入文件或数据库来达到程序下次执行时，对象重建后与上次拥有一致的信息。在Ja
  
  <div class="read-more-link">
    <a href="/posts/2020-04-28-java-serialize/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-04-28-java-zip/">压缩类</a>
  </h1>
  <time datetime="2020-04-28T14:50:00&#43;0800" class="post-date">Tue, Apr 28, 2020</time>
  Java I/O库提供压缩功能输入、输出流，这些类是按字节方式处理，常用的压缩类有DeflaterOutputStream和它的子类ZipOutpu
  
  <div class="read-more-link">
    <a href="/posts/2020-04-28-java-zip/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2020-04-27-algorithm-recursion/">简简单单知道递归</a>
  </h1>
  <time datetime="2020-04-27T20:21:23&#43;0800" class="post-date">Mon, Apr 27, 2020</time>
  递归的含义 递归就是函数或方法通过调用自己本身来达到解决问题的目的，这种解法形式叫递归。用欧几里得算法的Java描述说明问题： 任意一对非负整数
  
  <div class="read-more-link">
    <a href="/posts/2020-04-27-algorithm-recursion/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-11-28-java-typeinfo/">类型信息</a>
  </h1>
  <time datetime="2019-11-28T18:25:37&#43;0800" class="post-date">Thu, Nov 28, 2019</time>
  Class对象 每个类都存在包含类型信息的Class对象，Class对象属于Java类中Class类型。有两种方法获得某类型的Class 对象，
  
  <div class="read-more-link">
    <a href="/posts/2019-11-28-java-typeinfo/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-11-25-java-strings/">字符串</a>
  </h1>
  <time datetime="2019-11-25T09:46:16&#43;0800" class="post-date">Mon, Nov 25, 2019</time>
  String对象不可变 String对象被创建后不可修改，某些方法看似是修改源字符串，其实是重新创建新字符串来代替。 StringBuilder 在循环体中对String
  
  <div class="read-more-link">
    <a href="/posts/2019-11-25-java-strings/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-11-24-java-exceptions/">异常处理</a>
  </h1>
  <time datetime="2019-11-24T08:47:23&#43;0800" class="post-date">Sun, Nov 24, 2019</time>
  异常抛出 创建一个异常对象，然后从当前环境对象抛出，阻止当前方法或作用域的执行。 语法: throw new NullPointerException, 关键字throw之后，和创建普通对象一样创建异常对
  
  <div class="read-more-link">
    <a href="/posts/2019-11-24-java-exceptions/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-24-java-innerclass/">内部类</a>
  </h1>
  <time datetime="2019-10-24T16:48:18&#43;0800" class="post-date">Thu, Oct 24, 2019</time>
  创建内部类 直接将内部类置于外围类中 // innerclasses/Parcel1.java // Creating inner classes public class Parcel1 { class Contents { private int i = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } String readLabel() { return label; } } // Using inner classes looks just like
  
  <div class="read-more-link">
    <a href="/posts/2019-10-24-java-innerclass/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-22-java-interfaces/">接口</a>
  </h1>
  <time datetime="2019-10-22T16:29:48&#43;0800" class="post-date">Tue, Oct 22, 2019</time>
  抽象类和抽象方法 抽象方法：仅有声明而没有方法体。 如： abstract void f(); 抽象类： 包含抽象方法的类。 如果一个类包含一个或多个抽象方法，该类必须限定为抽象的。
  
  <div class="read-more-link">
    <a href="/posts/2019-10-22-java-interfaces/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-21-java-polymorphism/">多态</a>
  </h1>
  <time datetime="2019-10-21T17:01:44&#43;0800" class="post-date">Mon, Oct 21, 2019</time>
  多态的作用 消除类型间的耦合关系 改善代码的组织结构和可读性，还能够创建可扩展程序 绑定 将一个方法调用同一个方法主体关联起来称为绑定。若在程序执行
  
  <div class="read-more-link">
    <a href="/posts/2019-10-21-java-polymorphism/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-21-java-reuse/">复用类</a>
  </h1>
  <time datetime="2019-10-21T12:54:56&#43;0800" class="post-date">Mon, Oct 21, 2019</time>
  从现有类生成新类型 组合： 一般将现有类型作为新类型底层实现一部分来加以复用 继承：仅仅复用接口 用到 extends关键字 继承 继承中的初始化 在构造器
  
  <div class="read-more-link">
    <a href="/posts/2019-10-21-java-reuse/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-21-java-access/">访问权限</a>
  </h1>
  <time datetime="2019-10-21T09:06:40&#43;0800" class="post-date">Mon, Oct 21, 2019</time>
  访问权限控制 public （公共访问权限, 谁都可以访问） private （类内私有，用户无法访问） protected （继承访问权限，也提供包内访问） 包访问权限（没有关键词修饰，供包内
  
  <div class="read-more-link">
    <a href="/posts/2019-10-21-java-access/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-20-java-initialization/">初始化和清理</a>
  </h1>
  <time datetime="2019-10-20T09:28:44&#43;0800" class="post-date">Sun, Oct 20, 2019</time>
  构造器确保初始化 构造器确保初始化，名字与类名一致，允许重载，且是特殊的无返回值(与void不同)的方法。 在Java中，初始化与创建绑定在一起
  
  <div class="read-more-link">
    <a href="/posts/2019-10-20-java-initialization/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-20-git-simple-usage/">git入门使用</a>
  </h1>
  <time datetime="2019-10-20T08:50:01&#43;0800" class="post-date">Sun, Oct 20, 2019</time>
  配置Git 提供Git用户名和邮箱 $ git config &ndash;global user.name &ldquo;username&rdquo; $ git config &ndash;global user.email &ldquo;usernaem@example.com&rdquo; 忽略文件 创建文件 .gitignore ，让Git忽略某目录中的所有文件(不跟踪这些文件)，使用它可以避免
  
  <div class="read-more-link">
    <a href="/posts/2019-10-20-git-simple-usage/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-19-java-control-flow/">控制流程</a>
  </h1>
  <time datetime="2019-10-19T20:27:47&#43;0800" class="post-date">Sat, Oct 19, 2019</time>
  关键词：if-else, while, do-while, for, return, break, continue, switch 条件判断 (if-else) 判断某个条件是否为真，若为真，则执行 if 后的语句;为假执行else后的语句 例如: int i = 47; if (i %
  
  <div class="read-more-link">
    <a href="/posts/2019-10-19-java-control-flow/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-18-java-operator/">操作符</a>
  </h1>
  <time datetime="2019-10-18T21:55:03&#43;0800" class="post-date">Fri, Oct 18, 2019</time>
  静态导入 通过封装，自建类库已到达更简短语句答应字符串。可以静态导入（import static LibraryName）类库中静态对象 表达式 副作用：有些运
  
  <div class="read-more-link">
    <a href="/posts/2019-10-18-java-operator/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-18-java-objects/">一切都是对象</a>
  </h1>
  <time datetime="2019-10-18T20:41:27&#43;0800" class="post-date">Fri, Oct 18, 2019</time>
  对象及内存分布 在Java中一切都被视为对象，但操纵的标识符实际上是对象的“引用” 字符串可以用带引号的初始值， 如： String s = &quot;sdf&quot;; 关键字 new 用来创建一个
  
  <div class="read-more-link">
    <a href="/posts/2019-10-18-java-objects/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://qinry.github.io/posts/2019-10-17-algorithm-beginning/">数据结构与算法分析(笔记) -- 开始</a>
  </h1>
  <time datetime="2019-10-17T23:29:10&#43;0800" class="post-date">Thu, Oct 17, 2019</time>
  递归使用的基本法则 基准情形：要有退出条件 不断推进：从初始条件趋向退出条件 设计准则 ：假设递归准确执行 合成效益法则：防止重复工作，比如生成斐波那
  
  <div class="read-more-link">
    <a href="/posts/2019-10-17-algorithm-beginning/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
