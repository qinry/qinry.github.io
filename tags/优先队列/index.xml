<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>优先队列 on qinry&#39;s blog</title>
    <link>http://qinry.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 优先队列 on qinry&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 06 Aug 2020 21:36:55 +0800</lastBuildDate><atom:link href="http://qinry.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优先队列的实现</title>
      <link>http://qinry.github.io/posts/2020-08-06-algorithm-priority-queue/</link>
      <pubDate>Thu, 06 Aug 2020 21:36:55 +0800</pubDate>
      
      <guid>http://qinry.github.io/posts/2020-08-06-algorithm-priority-queue/</guid>
      <description>参考于《算法》第四版第二章第四节
基于堆的优先队列 API: 最大优先队列
public class MaxPQ&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;&amp;gt;
   方法 功能描述     MaxPQ(int max) 创建一个初始容量为max的优先队列   void insert(Key x) 向优先队列插入一个元素   Key delMax() 删除最大元素并返回最大元素   boolean isEmpty() 返回队列是否为空   int size() 返回优先队列的元素个数    public class MaxPQ&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;&amp;gt; { private Key[] pq; // 基于堆的完全二叉树  private int N = 0; // 存储于pq[1..N]中，pq[0]没有使用  public MaxPQ(int maxN) { pq = (Key[]) new Comparable[maxN + 1]; } public boolean isEmpty() { return n == 0; } public int size() { return N; } public Key max() { if (isEmpty()) throw new NoSuchElementException(&amp;#34;Priority queue underflow&amp;#34;); return pq[1]; } public void insert(Key x) { pq[++n] = x; swim(n); } public Key delMax() { Key max = pq[1]; // 从根结点得到最大元素  exch(1, N--); // 将其和最后一个结点交换  pq[n+1] = null; //防止对象游离  sink(1); // 恢复堆的有序性  return max; } // 辅助方法  private void swim(int k) { while (k &amp;gt; 1 &amp;amp;&amp;amp; less(k/2, k)) { exch(k, k/2); k = k/2; } } private void sink(int k) { while (2*k &amp;lt;= n) { int j = 2*k; if (j &amp;lt; n &amp;amp;&amp;amp; less(j, j+1)) j++; if (!</description>
    </item>
    
  </channel>
</rss>
